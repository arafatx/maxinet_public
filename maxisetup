#!/bin/bash
# =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
# Author: Arafat Ali | Email: webmaster@sofibox.com
APP_SPECIFIC_NAME="Maxisetup"
APP_STATUS="beta"
APP_VERSION="0.4.3.7-${APP_STATUS}"
# This is an initial server hardening script for CentOS and Debian.
# Compatible 100% with Directadmin. Supported OS: CentOS + Debian (Planned on FreeBSD)
# You can choose to install as the other stack server such as LEMP, (TODO) Laravel and more defined in config file
# In Directadmin, it will setup Directadmin from scratch, secure its installation with many security best practices
# At the end of installation, you will get a secured Directadmin control panel without needed to tweak more
# You can always re-run this script to resume installation if it's halt due to known error or script has performed reboot
# URL (public): github.com/sofibox/maxisetup_public | (private) github.com/sofibox/maxisetup (need access token)
# =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
# Run installation with log output: ./maxisetup --setup 2>&1 | tee maxisetup.log
# Run initialize installation with log output: ./maxisetup --init-server init-all rebuild-iso 2>&1 | tee maxisetup.log
# TOP TO DO LIST:
# TODO: Enable DNSSEC https://help.directadmin.com/item.php?id=651 (also check mail configuration to support new ipv6)
# TODO: enable --dry-run (that will simulate testing for this script)
# TODO: provide an optional option to automatically create google domain verification TXT record through API (need Google business account at console) - Google site verification
# TODO: create hostname and setup dkim, dmarc, at linode spf at linode (use common subdomain, ftp, mail, www, smtp, pop) - normally it should be created first before installing DA but dkim need to be updated.

# This function is used to unlock LUKS disk encryption on boot via terminal
# Usage: ssh_luks_unlock <drop_bear_port> <disk_luks_password>
# Note 1: The drop_bear_port is setup using dropbear-initramfs (This is set in OS preseed-file and config file)
# Note 2: The disk_luks_password is the OS LUKS encryption password (This is set in OS preseed-file and config file)
# Note 3: The unlock method required a port and a password. It will use a normal SSH with certificate (Certificate is set in OS preseed-file)
# Note 4: After it has successfully logged into the system via SSH, we write the disk_luks_password using this code and the OS will automatically unlock it: "echo -ne \"${pass}\" > /lib/cryptsetup/passfifo"
# eg calling within code: ssh_luks_unlock 2222 "1234"
# eg calling outside code: <script_name> --ssh-luks-unlock 2222 "1234"
function ssh_luks_unlock() {
  local port pass rsa_private_key
  port="$1"
  pass="$2"
  echo >/root/.ssh/known_hosts
  rsa_private_key_local="${SCRIPT_PATH}/secure/ssh/root_root_${BOX_HOSTNAME_FQDN}.id_rsa"
  rsa_private_key_remote="/root/.ssh/root_root_${BOX_HOSTNAME_FQDN}.id_rsa"
  cp "${rsa_private_key_local}" /root/.ssh/
  chmod -R 600 /root/.ssh/
  _log default "Unlocking LUKS encryption disk on boot ..."
  if [ -f "${rsa_private_key_remote}" ]; then
    _log default "Connecting to SSH to unlock LUKS encryption disk on boot ..."
    ssh -o "StrictHostKeyChecking no" -q -p "${port}" -i "${rsa_private_key_remote}" "${BOX_HOSTNAME_FQDN}" "echo -ne \"${pass}\" > /lib/cryptsetup/passfifo"
  else
    _log red "Error, remote private key ${rsa_private_key_remote} does not exist!"
    _exit 1
  fi
}

# This function will check if defined server and port is available (in a listening state)
# Usage: check_server_port <server> <port>
# eg: check_server_port test.sofibox.com 22
# It will return 0 (if available), and other return codes (if listening state for the port is not available)
function check_server_port() {
  local server port result
  server="$1"
  port="$2"
  nc -z -v -w5 "${server}" "${port}" >/dev/null
  result=$?
  echo "${result}"
}
# This function is used to manage SSH key (create, get, copy)
# Usage: ssh_key_manager create-key|create-key-with-putty <group_name> <user> <comment>
# Note 1: create-key will create normal ssh key
# Note 2: create-key-with-putty will create ssh key with putty format
# eg: ssh_key_manager "create-key-with-putty" "group" "user" "comment"
# eg: ssh_key_manager "get-public-key" "group" "user"
# eg: ssh_key_manager "copy-all-pubkeys"
# group_name = user, admin, root, rescue, backup, os, diradmin ...
function ssh_key_manager() {
  local action="$1"
  shift
  local group uname rsa_public_key rsa_private_key_ppk comment
  group="$1"
  uname="$2"

  mkdir -p "${SCRIPT_PATH}/secure/ssh"

  rsa_public_key="${SCRIPT_PATH}/secure/ssh/${group}_${uname}_${BOX_HOSTNAME_FQDN}.id_rsa.pub"
  rsa_private_key="${SCRIPT_PATH}/secure/ssh/${group}_${uname}_${BOX_HOSTNAME_FQDN}.id_rsa"
  rsa_private_key_ppk="${SCRIPT_PATH}/secure/ssh/${group}_${uname}_${BOX_HOSTNAME_FQDN}.ppk"

  if [ "${action}" == "create-key" ]; then
    comment="$3"
    if [ $# -eq 3 ]; then
      _log default "Creating SSH key ..."
      ssh-keygen -f "${rsa_private_key}" -t rsa -b 4096 -P "" -C "${comment}" <<<y
    else
      _log warning "Warning, not enough argument to create key!"
      return 1
    fi
  elif [ "${action}" == "create-key-with-putty" ]; then
    comment="$3"
    if [ $# -eq 3 ]; then
      install_required "putty-tools"
      _log default "Creating SSH key ..."
      ssh-keygen -f "${rsa_private_key}" -t rsa -b 4096 -P "" -C "${comment}" <<<y
      _log default "Creating SSH key for putty ..."
      puttygen "${rsa_private_key}" -o "${rsa_private_key_ppk}"
    else
      _log default "Warning, not enough argument to create key!"
      return 1
    fi
  elif [ "${action}" == "get-public-key" ]; then
    if [ -f "${rsa_public_key}" ]; then
      cat "${rsa_public_key}"
    else
      _log red "Warning, public key does not exist. Please create it first"
      return 1
    fi
    # Warning this will replace existing key
  elif [ "${action}" == "copy-all-pubkeys" ]; then
    _log default "Resetting known_hosts and copying all public key to /root/.ssh/* ..."
    echo >/root/.ssh/known_hosts
    cp "${SCRIPT_PATH}"/secure/ssh/*.id_rsa* /root/.ssh/
    chmod -R 600 /root/.ssh/
  else
    _log red "Warning, unknown action argument specified when calling ssh_key_manager function!"
    return 1
  fi
}
# This function is used to login into server (SSH login)
# It can be supplied with script and run in silent/noisy mode
# Usage: ssh_login "<server>:<port>" "<group>:<user>" <silent> optional_script_path>
# eg: ssh_login test.sofibox.com:897 root:root silent/noisy /path_to_script
# eg2: ssh_login test.sofibox.com:897 root:root /path_to_script
# eg3: ssh_login test.sofibox.com:897 root:root
# eg4: ssh_login test.sofibox.com:897 root:root "noisy"
function ssh_login() {
  if [ -z "$1" ]; then
    echo ""
    _log yellow "Usage: ssh_login sun.sofibox.com:port group:user optional_silent_mode optional_script"
    _log yellow "eg: ssh_login sun.sofibox.com:897 root:root silent /path_to_script.sh"
    echo ""
    _exit 1
  fi
  # For LUKS:  ssh -o "StrictHostKeyChecking no" -q -p 2222 -i "/root/.ssh/root_sun.sofibox.com.id_rsa" "sun.sofibox.com" "echo -ne \"abma892\" > /lib/cryptsetup/passfifo"
  #shift
  install_required "sshpass"
  local server_port group_user script mode hostname_fqdn host_port ssh_group ssh_user
  server_port="$1"
  group_user="$2"
  mode="$3"

  if [[ "${mode}" == "silent" || "${mode}" == "noisy" ]]; then
    script="$4"
  else
    mode="noisy"
    script="$3"
  fi

  hostname_fqdn=$(echo "${server_port}" | awk -F':' '{ print $1 }')
  host_port=$(echo "${server_port}" | awk -F':' '{ print $2 }')
  ssh_group=$(echo "${group_user}" | awk -F':' '{ print $1 }')
  ssh_user=$(echo "${group_user}" | awk -F':' '{ print $2 }')

  # Remove all known hosts (reset)
  echo >/root/.ssh/known_hosts
  # Copying all ssh public keys into /root/.ssh/
  cp "${SCRIPT_PATH}"/secure/ssh/*.id_rsa* /root/.ssh/
  # Make sure they have 600 permission
  chmod -R 600 /root/.ssh/
  if [ "${ssh_user}" == "root" ]; then
    :
  else
    ssh_user_append="${ssh_user}@"
  fi
  echo "Connecting to ${hostname_fqdn} using port ${host_port} with private key ${ssh_group}_${ssh_user}_${BOX_HOSTNAME_FQDN}.id_rsa ..."
  if [[ -n "${script}" && "${mode}" == "silent" ]]; then
    #echo "Script given and it's quite mod"
    ssh -q -o "StrictHostKeyChecking no" -p "${host_port}" -i "/root/.ssh/${ssh_group}_${ssh_user}_${BOX_HOSTNAME_FQDN}.id_rsa" "${IPV4_ADD0}" /dev/null <"${script}" 2>&1 &
  elif [[ "${mode}" == "noisy" && -n "${script}" ]]; then
    # echo "script given but not quite mode"
    ssh -o "StrictHostKeyChecking no" -p "${host_port}" -i "/root/.ssh/${ssh_group}_${ssh_user}_${BOX_HOSTNAME_FQDN}.id_rsa" "${IPV4_ADD0}" <"${script}"
  elif [[ "${mode}" == "silent" && -z "${script}" ]]; then
    #echo "Script not given but it's quite mode"
    ssh -q -o "StrictHostKeyChecking no" -p "${host_port}" -i "/root/.ssh/${ssh_group}_${ssh_user}_${BOX_HOSTNAME_FQDN}.id_rsa" "${IPV4_ADD0}"
  elif [[ "${mode}" == "noisy" && -z "${script}" ]]; then
    #echo "Script not given and no quite mod"
    ssh -o "StrictHostKeyChecking no" -p "${host_port}" -i "/root/.ssh/${ssh_group}_${ssh_user}_${BOX_HOSTNAME_FQDN}.id_rsa" "${ssh_user_append}${IPV4_ADD0}"
  fi
}
# This function is use to transfer file over SSH using scp
# Usage: ssh_transfer <hostname_fqdn>:<port> <group>:<user> <local_path> <remote_path>
# To transfer multiple files, quote the local_path for example:
# ssh_transfer sun.sofibox.com:897 root:root "/local/test1.txt local/test2.txt" ~/
function ssh_transfer() {
  if [ -z "$1" ]; then
    echo ""
    _echo 'yellow' "Usage: ssh_transfer sun.sofibox.com:port group:user local_path remote_path"
    _echo 'yellow' "eg: ssh_transfer sun.sofibox.com:897 root:root /local/mini.iso ~/mini.iso"
    _echo 'yellow' "To transfer multiple files, quote the local_path"
    echo ""
    _exit 1
  fi

  install_required "sshpass"
  local server_port group_user local_path remote_path hostname_fqdn host_port ssh_group ssh_user
  server_port="$1"
  group_user="$2"
  local_path="$3"
  remote_path="$4"

  hostname_fqdn=$(echo "${server_port}" | awk -F':' '{ print $1 }')
  host_port=$(echo "${server_port}" | awk -F':' '{ print $2 }')
  ssh_group=$(echo "${group_user}" | awk -F':' '{ print $1 }')
  ssh_user=$(echo "${group_user}" | awk -F':' '{ print $2 }')

  # Remove all known hosts (reset)
  echo >/root/.ssh/known_hosts
  # Copying all ssh public keys into /root/.ssh/
  cp "${SCRIPT_PATH}"/secure/ssh/*.id_rsa* /root/.ssh/
  # Make sure they have 600 permission
  chmod -R 600 /root/.ssh/
  # Do not quote local_path to enable multiple file transfers
  echo "Transferring file local files(s) ${local_path} into remote SSH ${remote_path} ..."
  scp -o "StrictHostKeyChecking no" -P "${host_port}" -i "/root/.ssh/${ssh_group}_${ssh_user}_${hostname_fqdn}.id_rsa" ${local_path} "${IPV4_ADD0}:${remote_path}" 2> >(grep -v 'Permanently' 1>&2)
}
# This function is used to check linode status until a specified condition and then it will break
# Usage: check_linode_status_until online/offline
# To recursively check linode status until offline
# eg: check_linode_status_until offline
function check_linode_status_until() {
  option="$1"
  if [[ "${option}" == "offline" ]]; then
    echo "Checking linode status ..."
    while :; do
      linode_status=$(linode_api_admin "get-linode-status" "${BOX_HOSTNAME_FQDN}" | tail -n 1)
      if [ "${linode_status}" == "online" ]; then
        spinner start "Linode is online, waiting for offline status"
        # Re-execute reboot command
        ssh -o "StrictHostKeyChecking no" -i /root/.ssh/linode_lish.id_rsa -tt "${DNS_PROVIDER_USER}@${DNS_PROVIDER_TERMINAL_SERVER}" "${BOX_HOSTNAME_FQDN}" /dev/null <"${SCRIPT_PATH}/linode/reboot_command.sh" 2>&1 &
      elif [ "${linode_status}" == "offline" ]; then
        spinner stop "Success, Linode is offline"
        break
      else
        spinner start "Linode status is ${linode_status}, waiting for offline status"
      fi
    done
  elif [[ "${option}" == "online" ]]; then
    echo "Checking linode status ..."
    while :; do
      linode_status=$(linode_api_admin "get-linode-status" "${BOX_HOSTNAME_FQDN}" | tail -n 1)
      if [ "${linode_status}" == "online" ]; then
        spinner stop "Success, Linode is online"
        break
      elif [ "${linode_status}" == "offline" ]; then
        spinner start "Linode is offline, waiting for online status"
      else
        spinner start "Linode status is ${linode_status}, waiting for offline status"
      fi
    done
  else
    _echo 'red' "Error, unknown argument passed!"
  fi
}

# This function will display spinning progress.
# SPIN_PROGRESS and SPIN_COUNT must be declared outside function
# Use inside function with loop to show animation of the spinner
# Usage:
# spinner <start/stop> <message>
# to start spinner: spinner start "Deleting that one ..."
# output: Deleting that one ... /
# to stop spinner and replace with success message: spinner stop "Success deleted that one!"
# output: Success deleted that one!
# Not recommend to use long string for the spinning message that fill up the width of the terminal with weird output.
function spinner() {
  local option strings_start strings_end
  option="$1"
  #string_count=0
  if [[ "${option}" == "spin" || "${option}" == "start" ]]; then
    shift
    strings_start="$1"
    echo -ne "\r${strings_start} ${SPIN_PROGRESS:SPIN_COUNT++:1}"
    ((SPIN_COUNT == ${#SPIN_PROGRESS})) && SPIN_COUNT=0
  elif [[ "${option}" == "endspin" || "${option}" == "stop" ]]; then
    shift
    strings_end="$*"
    #add \033[K or \e[K after the \r to clear text
    echo -ne "\r\e[K${strings_end}\n"
  fi
}
# This function will validate if config is valid, if one of the variables missing, it will complain and exit
function validate_config() {
  local count_user total_valid_user this_da_owner_uname
  echo "[${SCRIPT_NAME}]: Checking DA users configuration ... " 2>&1 | tee -a "${REPORT_FILE}"
  total_valid_user=0
  # Owner not support multiple users yet so checking is simple without loop
  typeset -n "this_da_owner_uname"="DA_OWNER_USERNAME1"
  typeset -n "this_da_owner_password"="DA_OWNER_USERPASS1"
  typeset -n "this_da_owner_name"="DA_OWNER_NAME1"
  typeset -n "this_da_owner_system_email"="DA_OWNER_SYSTEM_EMAIL1"
  typeset -n "this_da_owner_security_q"="DA_OWNER_SECURITY_Q1"
  typeset -n "this_da_owner_security_a"="DA_OWNER_SECURITY_A1"

  #if [[ -z "${this_da_owner_uname+x}" ]]; then
  # echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner username is not set. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
  # _exit 1
  if [[ "${#this_da_owner_uname}" -lt 2 ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner username length is ${#this_da_owner_uname} but the minimum should be 2. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
    _exit 1
  elif [[ "${#this_da_owner_uname}" -gt ${DA_MAX_UNAME_LENGTH} ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner username length is ${#this_da_owner_uname} but the maximum should be ${DA_MAX_UNAME_LENGTH}. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
    _exit 1
  elif [[ -z "${this_da_owner_name+x}" ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} doesn't have name set in config file. Please check configuration file" 2>&1 | tee -a "${REPORT_FILE}"
    _exit 1
  elif [[ -z "${this_da_owner_password+x}" ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} doesn't have password set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
    _exit 1
  elif [[ "${#this_da_owner_password}" -lt 6 ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} has password set length of ${#DA_OWNER_USERPASS1} but the minimum is 6 characters. Please check configuration file" 2>&1 | tee -a "${REPORT_FILE}"
    _exit 1
  elif [[ "${#this_da_owner_password}" -gt 64 ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} has password set length of ${#DA_OWNER_USERPASS1} but the maximum is 64 characters. Please check configuration file" 2>&1 | tee -a "${REPORT_FILE}"
    _exit 1
  elif [[ "${this_da_owner_password}" =~ ['&+'] ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} has password set with forbidden special character &+ in config file. Please check configuration file" 2>&1 | tee -a "${REPORT_FILE}"
    _exit 1
  elif [[ -z "${this_da_owner_system_email+x}" ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} doesn't have system email set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
    _exit 1
  elif [[ -z "${this_da_owner_security_q+x}" ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} doesn't have security question set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
    _exit 1
  elif [[ -z "${this_da_owner_security_a+x}" ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} doesn't have security answer set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
    _exit 1
  elif [[ ${#this_da_owner_security_q[@]} -ne ${#this_da_owner_security_a[@]} ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} has security question and answer defined with different length of array" 2>&1 | tee -a "${REPORT_FILE}"
    _exit 1
  else
    echo "[${SCRIPT_NAME}]: OK, all variables for owner ${DA_OWNER_USERNAME1} are set." 2>&1 | tee -a "${REPORT_FILE}"
    ((total_valid_user++))
  fi

  # Admin test multiple
  local da_admin_unames da_admin_unames_count this_da_admin_uname this_da_admin_password this_da_admin_name \
    this_da_admin_system_email this_da_admin_security_q this_da_admin_security_a this_da_user_ssl_sub_name

  da_admin_unames="${!DA_ADMIN_USERNAME@}"
  da_admin_unames_count=$(echo "${da_admin_unames}" | wc -w)

  count_user=1
  # Validate admins
  while [[ ${count_user} -le ${da_admin_unames_count} ]]; do
    typeset -n "this_da_admin_uname"="DA_ADMIN_USERNAME${count_user}"
    typeset -n "this_da_admin_password"="DA_ADMIN_USERPASS${count_user}"
    typeset -n "this_da_admin_name"="DA_ADMIN_NAME${count_user}"
    typeset -n "this_da_admin_system_email"="DA_ADMIN_SYSTEM_EMAIL${count_user}"
    typeset -n "this_da_admin_security_q"="DA_ADMIN_SECURITY_Q${count_user}"
    typeset -n "this_da_admin_security_a"="DA_ADMIN_SECURITY_A${count_user}"
    #  if [[ -z "${this_da_admin_uname+x}" ]]; then
    #  echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin username is not set. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
    #  _exit 1
    if [[ "${#this_da_admin_uname}" -lt 2 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin username length is ${#this_da_admin_uname} but the minimum should be 2. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ "${#this_da_admin_uname}" -gt ${DA_MAX_UNAME_LENGTH} ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin username length is ${#this_da_admin_uname} but the maximum should be ${DA_MAX_UNAME_LENGTH}. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1

    elif [[ -z "${this_da_admin_password+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} doesn't have password set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ "${#this_da_admin_password}" -lt 6 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} has password set length of ${#this_da_admin_password} but the minimum is 6 characters. Please check configuration file" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ "${#this_da_admin_password}" -gt 64 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} has password set length of ${#this_da_admin_password} but the maximum is 64 characters. Please check configuration file" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ "${this_da_admin_password}" =~ ['&+'] ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} has password set with forbidden special character &+ in config file. Please check configuration file" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_admin_name+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} doesn't have name set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_admin_system_email+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} doesn't have system email set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_admin_security_q+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} doesn't have security question set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_admin_security_a+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} doesn't have security answer set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ ${#this_da_admin_security_q[@]} -ne ${#this_da_admin_security_a[@]} ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} has security question and answer defined with different length of array" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    else
      echo "[${SCRIPT_NAME}]: OK, all variables for admin ${this_da_admin_uname} are set." 2>&1 | tee -a "${REPORT_FILE}"

    fi
    ((count_user++))
    ((total_valid_user++))
  done

  local da_reseller_unames da_reseller_unames_count this_da_reseller_uname this_da_reseller_name this_da_reseller_system_email \
    this_da_reseller_mail_users this_da_reseller_mail_passwords this_da_reseller_domains this_da_reseller_wildcard_domains \
    this_da_reseller_subdomains this_da_reseller_package_name this_da_reseller_enable_domain_ssl this_da_reseller_ssl_sub_name \
    this_da_reseller_security_q this_da_reseller_security_a

  da_reseller_unames="${!DA_RESELLER_USERNAME@}"
  da_reseller_unames_count=$(echo "${da_reseller_unames}" | wc -w)

  count_user=1
  # Validate resellers
  while [[ ${count_user} -le ${da_reseller_unames_count} ]]; do
    typeset -n "this_da_reseller_uname"="DA_RESELLER_USERNAME${count_user}"
    typeset -n "this_da_reseller_password"="DA_RESELLER_USERPASS${count_user}"
    typeset -n "this_da_reseller_name"="DA_RESELLER_NAME${count_user}"
    typeset -n "this_da_reseller_system_email"="DA_RESELLER_SYSTEM_EMAIL${count_user}"
    typeset -n "this_da_reseller_mail_users"="DA_RESELLER_MAIL_USER${count_user}"
    typeset -n "this_da_reseller_mail_passwords"="DA_RESELLER_MAIL_PASSWORD${count_user}"
    typeset -n "this_da_reseller_domains"="DA_RESELLER_DOMAIN${count_user}"
    typeset -n "this_da_reseller_wildcard_domains"="DA_RESELLER_WILDCARD_DOMAIN${count_user}"
    typeset -n "this_da_reseller_subdomains"="DA_RESELLER_SUBDOMAIN${count_user}"
    typeset -n "this_da_reseller_package_name"="DA_RESELLER_PACKAGE_NAME${count_user}"
    typeset -n "this_da_reseller_enable_domain_ssl"="DA_RESELLER_ENABLE_DOMAIN_SSL${count_user}"
    typeset -n "this_da_reseller_ssl_sub_name"="DA_RESELLER_SSL_SUB_NAME${count_user}"
    typeset -n "this_da_reseller_security_q"="DA_RESELLER_SECURITY_Q${count_user}"
    typeset -n "this_da_reseller_security_a"="DA_RESELLER_SECURITY_A${count_user}"
    if [[ "${#this_da_reseller_uname}" -lt 2 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller username length is ${#this_da_reseller_uname} but the minimum should be 2. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ "${#this_da_reseller_uname}" -gt ${DA_MAX_UNAME_LENGTH} ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller username length is ${#this_da_reseller_uname} but the maximum should be ${DA_MAX_UNAME_LENGTH}. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1

    elif [[ -z "${this_da_reseller_password+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have password set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ "${#this_da_reseller_password}" -lt 6 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} has password set length of ${#this_da_reseller_password} but the minimum is 6 characters. Please check configuration file" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ "${#this_da_reseller_password}" -gt 64 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} has password set length of ${#this_da_reseller_password} but the maximum is 64 characters. Please check configuration file" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ "${this_da_reseller_password}" =~ ['&+'] ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} has password set with forbidden special character &+ in config file. Please check configuration file" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_reseller_name+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have name set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1

    elif [[ -z "${this_da_reseller_system_email+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have system email set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_reseller_mail_users+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have email inbox set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_reseller_mail_passwords+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have email password set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
      # Just use a normal variable to check (even it is array)
    elif [[ -z "${this_da_reseller_domains+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have domain set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_reseller_wildcard_domains+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have wildcard domain set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_reseller_subdomains+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have subdomains set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ $(awk -F':' '{print NF-1}' <<<"${this_da_reseller_subdomains}") -lt 1 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_user_uname} has invalid subdomains format in config file. eg: <domain>:<sub1>+<sub2> ... . Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ $(awk -F':' '{print NF-1}' <<<"${this_da_reseller_subdomains}") -gt 1 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_user_uname} has invalid subdomains format in config file. eg: <domain>:<sub1>+<sub2> ... . Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ ${#this_da_reseller_mail_users[@]} -ne ${#this_da_reseller_mail_passwords[@]} ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} has mail users and mail passwords defined with different length of array" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_reseller_package_name+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have package name set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_reseller_enable_domain_ssl+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have domain enable ssl set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ $(awk -F':' '{print NF-1}' <<<"${this_da_reseller_ssl_sub_name}") -lt 2 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} has invalid ssl subdomains format in config file. eg: <provider>:<domain>:<sub1>+<sub2> ... . Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ $(awk -F':' '{print NF-1}' <<<"${this_da_reseller_ssl_sub_name}") -gt 2 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} has invalid ssl subdomains format in config file. eg: <provider>:<domain>:<sub1>+<sub2> ... . Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_reseller_security_q+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have security question set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_reseller_security_a+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have security answer set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ ${#this_da_reseller_security_q[@]} -ne ${#this_da_reseller_security_a[@]} ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} has security question and answer defined with different length of array" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    else
      echo "[${SCRIPT_NAME}]: OK, all variables for reseller ${this_da_reseller_uname} are set." 2>&1 | tee -a "${REPORT_FILE}"
    fi
    ((count_user++))
    ((total_valid_user++))
  done

  local da_user_unames da_user_count this_da_user_uname this_da_user_password this_da_user_name this_da_user_system_email \
    this_da_user_mail_users this_da_user_mail_passwords this_da_user_domains this_da_user_wildcard_domains this_da_user_subdomains \
    this_da_user_package_name this_da_user_enable_domain_ssl this_da_user_security_q this_da_user_security_a

  da_user_unames="${!DA_USER_USERNAME@}"
  da_user_count=$(echo "${da_user_unames}" | wc -w)

  count_user=1
  # Validate users
  while [[ ${count_user} -le ${da_user_count} ]]; do
    typeset -n "this_da_user_uname"="DA_USER_USERNAME${count_user}"
    typeset -n "this_da_user_password"="DA_USER_USERPASS${count_user}"
    typeset -n "this_da_user_name"="DA_USER_NAME${count_user}"
    typeset -n "this_da_user_system_email"="DA_USER_SYSTEM_EMAIL${count_user}"
    typeset -n "this_da_user_mail_users"="DA_USER_MAIL_USER${count_user}"
    typeset -n "this_da_user_mail_passwords"="DA_USER_MAIL_PASSWORD${count_user}"
    typeset -n "this_da_user_domains"="DA_USER_DOMAIN${count_user}"
    typeset -n "this_da_user_wildcard_domains"="DA_USER_WILDCARD_DOMAIN${count_user}"
    typeset -n "this_da_user_subdomains"="DA_USER_SUBDOMAIN${count_user}"
    typeset -n "this_da_user_package_name"="DA_USER_PACKAGE_NAME${count_user}"
    typeset -n "this_da_user_enable_domain_ssl"="DA_USER_ENABLE_DOMAIN_SSL${count_user}"
    typeset -n "this_da_user_ssl_sub_name"="DA_USER_SSL_SUB_NAME${count_user}"
    typeset -n "this_da_user_security_q"="DA_USER_SECURITY_Q${count_user}"
    typeset -n "this_da_user_security_a"="DA_USER_SECURITY_A${count_user}"
    if [[ "${#this_da_reseller_uname}" -lt 2 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user username length is ${#this_da_user_uname} but the minimum should be 2. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ "${#this_da_user_uname}" -gt ${DA_MAX_UNAME_LENGTH} ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user username length is ${#this_da_user_uname} but the maximum should be ${DA_MAX_UNAME_LENGTH}. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_user_password+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have password set in config file. Please check configuration file" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ "${#this_da_user_password}" -lt 6 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} has password set length of ${#this_da_user_password} but the minimum is 6 characters. Please check configuration file" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ "${#this_da_user_password}" -gt 64 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} has password set length of ${#this_da_user_password} but the maximum is 64 characters. Please check configuration file" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ "${this_da_user_password}" =~ ['&+'] ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} has password set with forbidden special character &+ in config file. Please check configuration file" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_user_name+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have name set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_user_system_email+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have system email set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_user_mail_users+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have email inbox set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_user_mail_passwords+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have email password set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
      # Just use a normal variable to check (even it is array)
    elif [[ -z "${this_da_user_domains+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have domain set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_user_wildcard_domains+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have wildcard domain set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_user_subdomains+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have subdomains set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ $(awk -F':' '{print NF-1}' <<<"${this_da_user_subdomains}") -lt 1 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} has invalid subdomains format in config file. eg: <domain>:<sub1>+<sub2> ... . Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ $(awk -F':' '{print NF-1}' <<<"${this_da_user_subdomains}") -gt 1 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} has invalid subdomains format in config file. eg: <domain>:<sub1>+<sub2> ... . Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ ${#this_da_user_mail_users[@]} -ne ${#this_da_user_mail_passwords[@]} ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} has mail users and mail passwords defined with different length of array" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_user_package_name+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have package name set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_user_enable_domain_ssl+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have domain enable ssl set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ $(awk -F':' '{print NF-1}' <<<"${this_da_user_ssl_sub_name}") -lt 2 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} has invalid ssl subdomains format in config file. eg: <provider>:<domain>:<sub1>+<sub2> ... . Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ $(awk -F':' '{print NF-1}' <<<"${this_da_user_ssl_sub_name}") -gt 2 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} has invalid ssl subdomains format in config file. eg: <provider>:<domain>:<sub1>+<sub2> ... . Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_user_security_q+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have security question set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ -z "${this_da_user_security_a+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have security answer set in config file. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    elif [[ ${#this_da_user_security_q[@]} -ne ${#this_da_user_security_a[@]} ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} has security question and answer defined with different length of array" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    else
      echo "[${SCRIPT_NAME}]: OK, all variables for user ${this_da_user_uname} are set." 2>&1 | tee -a "${REPORT_FILE}"
      ((total_valid_user++))
    fi
    ((count_user++))
  done

  echo "[${SCRIPT_NAME}]: Total user with valid config is: ${total_valid_user}" 2>&1 | tee -a "${REPORT_FILE}"
  #exit 1
}

# This function is used to handle exit trap that can accept multiple trap arguments
# syntax: _traps <trap_clean_function> SIG1 SIG2 SIG3 OTHER_SIG ...
# eg: _traps _trap_cleanup QUIT INT TERM EXIT
function _traps() {
  local clean_func
  clean_func="$1"
  shift
  for sig; do
    # Test each signal from function called
    # shellcheck disable=SC2064
    # include shellcheck disable directive because: https://github.com/koalaman/shellcheck/issues/2131
    trap "${clean_func} ${sig}" "${sig}"
  done
}

# This function is used by _traps function to clean exit
function _trap_cleanup() {
  # The first argument will have the name of the trap signal executed:
  # echo "Trapped: $1"
  ((CTRL_C_COUNT++))
  # Check if the locking directory is exist, if yes, remove it
  if [ -d "${LOCK_DIR}" ]; then
    rm -rf "${LOCK_DIR}"
    echo ""
    echo "[${SCRIPT_NAME}]: OK, locked flag removed from ${LOCK_DIR}"
  fi
  # this if condition will determine that this cleanup function is only called a single time CTRL_C_COUNT=1
  # this function might be called several times because we passed long arguments for trap to call this function
  if [[ ${CTRL_C_COUNT} == 1 ]]; then
    echo ""
    # if the trapped signal is INT (interactive) then we know this is interactive exit executed by a user.
    if [ "$1" == "INT" ]; then
      # so print the current user who terminated this script
      echo "[${SCRIPT_NAME}]: *** Warning, this script has been terminated by user: ${USER}! ***"
    else
      # for other trap signals, we just print out the trap signal
      echo "[${SCRIPT_NAME}]: This script has been terminated with signal: ${1}"
    fi
    echo ""
    echo "-------------------------------END-----------------------------------------"
    echo "Remember you can always resume installation with:"
    echo "For local installation: ${SCRIPT_NAME} --setup"
    echo "For remote installation: ${SCRIPT_NAME} --ssh-login \"${BOX_HOSTNAME_FQDN}:${SSH_PORT}\" \"root:${ROOT_USERNAME}\" \"${SCRIPT_PATH}/maxisetup_ssh.sh\""
  fi
  # clean exit
  exit 1
}
# This function gets the operating system ID and version number
# syntax: get_linux_os <id|version>
# eg: get_linux_os id | sample output: centos
function get_linux_os() {
  local arg distro_id distro_version
  arg="$1"
  # any new Linux distribution must have this (it is a standard file os checking for linux)
  if [ -e /etc/os-release ]; then
    # get the distro ID from /etc/os-release and make sure it is in lowercase format without any double quotations
    distro_id=$(awk -F= '$1 == "ID" {print $2}' /etc/os-release | LC_ALL=C tr '[:upper:]' '[:lower:]' | tr -d "\"")
    distro_version=$(awk -F= '$1 == "VERSION_ID" {print $2}' /etc/os-release | tr -d "\"")
  # but just in case (a small case) if it doesn't have this then we can use lsb_release command
  elif type lsb_release >/dev/null 2>&1; then
    # get the distro id using lsb_release function.
    # if the ID has uppercase letter, cover it to lowercase
    distro_id=$(lsb_release -si | LC_ALL=C tr '[:upper:]' '[:lower:]')
    distro_version=$(lsb_release -sr)
  # else if that doesn't exist at all, we can use the standard checking version format: "Linux <version>"
  else
    # this will not printout a single distribution ID that we want (it prints out the Generic Linux kernel version)
    # but using this we should terminate this script because we only need single distribution ID (eg: debian)
    distro_id=$(uname -s)
    distro_version=$(uname -r)
  fi
  # return values here with echo
  if [ "${arg}" == "id" ]; then
    echo "${distro_id}"
  elif [ "${arg}" == "version" ]; then
    echo "${distro_version}"
  fi

}

# This will install required component automatically if doesn't exist,
# It will do nothing if the component exist.
# eg: install_required "htop" "vim"
function install_required() {
  required_cmds="$*"
  missing_count=0
  install_success=0
  install_failed=0
  detect_by=""
  # Do not quote the array, we want split elements:
  for required_cmd in ${required_cmds[*]}; do
    #command -v "${required_cmd}" &>/dev/null
    #cmd_status=$?
    dpkg_status=$(
      dpkg -s "${required_cmd}" 2>&1 | grep -qF "Status: install ok installed"
      echo $?
    )
    if [[ "${dpkg_status}" -eq 1 ]]; then
      ((missing_count++))

      if [ "${dpkg_status}" -eq 1 ]; then
        detect_by="dpkg_status"
        # elif [ "${cmd_status}" = 1 ]; then
        #   detect_by="cmd_status"
        # elif [[ "${dpkg_status}" == 1 && "${cmd_status}" == 1 ]]; then
        #   detect_by="dpkg_status and cmd_status"
      fi
      echo ""
      echo "Warning, missing ${required_cmd} component detected by ${detect_by}. Installing ${required_cmd} ..."
      if [ "${missing_count}" -eq 1 ]; then
        echo ""
        echo "Running apt-get update for the first missing package ..."
        apt-get -y update
        echo ""
      fi
      apt-get -y install "${required_cmd}"
      retval=$?
      if [[ "${retval}" -eq 0 ]]; then
        ((install_success++))
      else
        ((install_failed++))
      fi
    fi
  done
  if [ "${missing_count}" -gt 0 ]; then
    echo ""
    echo "Total missing component: ${missing_count}"
    echo "Total success installed: ${install_success}"
    echo "Total failed installed: ${install_failed}"
    echo ""
  fi
}
# This is a random string that will return alphabet character (lower and uppercase)
# syntax: get_rnd_alpha <length>
# eg: get_rnd_alpha 10
function get_rnd_alpha() {
  local length
  length="$1"
  tr -dc A-Za-z </dev/urandom | head -c "${length}"
  echo ''
}
# This function will transform a plain-text password into a hash encrypted password + salt generation which is more secure
# eg: test=$(get_hash_pwd "mypassword")
function get_hash_pwd() {
  local password="$1" sha_pass
  sha_pass=$(mkpasswd -m sha-512 -S "$(pwgen -ns 16 1)" "$1")
  echo "${sha_pass}"
}

# This function will pause the current running terminal
# It will interactively ask to press enter or wait within <duration_in_seconds> to continue the next command
# syntax: _pause <optional_duration>
# eg: _pause | no timeout means we need to press enter to continue
# eg: _pause 10 | wait 10 seconds or press enter to continue
function _pause() {
  local duration=$1
  # If argument is not an integer, we disable read timeout
  # TODO validate this statement again
  if [[ ${duration} =~ ^[0-9]+$ ]]; then
    read -t "${duration}" -r -s -n 1 -p "[${SCRIPT_NAME}]: Press any key or wait within ${duration} second(s) to continue or press (Ctrl+c) to cancel ..." 2>&1 | tee -a "${REPORT_FILE}"
  else
    read -r -s -n 1 -p "[${SCRIPT_NAME}]: Terminal is paused! Press any key to continue or press (Ctrl+c) to cancel ..." 2>&1 | tee -a "${REPORT_FILE}"
  fi
  echo ""
}

# This function will display a confirmation to continue (force continue; no exit function)
function _confirm() {
  # call with a prompt string or use a default
  read -r -p "[${SCRIPT_NAME}]: ${1:-Continue? [y]} " response
  case "$response" in
  [yY][eE][sS] | [yY])
    return 0
    ;;
  *)
    echo "[${SCRIPT_NAME}]: Invalid response to the question!"
    _confirm "$1"
    ;;
  esac
}
# This function is used to terminate a current running script.
# pass the normal exit code
# syntax: _exit <exit_code>
# eg: _exit 3
function _exit() {
  exit "$1"
}

# _echo red "Hello World" - red color
# _echo default "Hello World" - default color
function _echo() {
  option="$1"
  shift
  if [ "${option}" == "black" ]; then
    echo -e "\033[1;30m${*}\033[0m"
  elif [[ "${option}" == "red" || "${option}" == "error" || "${option}" == "warning" ]]; then
    echo -e "\033[1;31m${*}\033[0m"
  elif [[ "${option}" == "green" || "${option}" == "ok" ]]; then
    echo -e "\033[1;32m${*}\033[0m"
  elif [ "${option}" == "yellow" ]; then
    echo -e "\033[1;33m${*}\033[0m"
  elif [ "${option}" == "blue" ]; then
    echo -e "\033[1;34m${*}\033[0m"
  elif [ "${option}" == "purple" ]; then
    echo -e "\033[1;35m${*}\033[0m"
  elif [ "${option}" == "cyan" ]; then
    echo -e "\033[1;36m${*}\033[0m"
  else
    # If color argument is not specified
    echo -e "${*}"
  fi
}

#  This function is used to print log file with timestamp
# syntax: _log <color> <message> <optional_log_file_path>
# _log red "hello wassup" "${REPORT_FILE}"
# Without color: _log default "hello there"
function _log() {
  local color info log_file
  color=$1
  info=$2
  log_file=$3

  if [[ $# -eq 3 ]]; then
    if [ -f "${log_file}" ]; then
      _echo "${color}" "[${SCRIPT_NAME}|$(date +'%d-%m-%Y %H:%M:%S')]: ${info}" | tee "${log_file}"
    else
      _echo yellow "[${SCRIPT_NAME}|$(date +'%d-%m-%Y %H:%M:%S')]: Warning log file [${log_file}] does not exist! Creating the log file [${log_file}] for the first time ..."
      touch "${log_file}"
      chmod 644 "${log_file}"
      #_exit 1
    fi
  elif [[ $# -eq 2 ]]; then
    if [ -f "${log_file}" ]; then
      :
    else
      _echo "${color}" "[${SCRIPT_NAME}|$(date +'%d-%m-%Y %H:%M:%S')]: ${info}"
    fi
  else
    _echo "red" "[${SCRIPT_NAME}|$(date +'%d-%m-%Y %H:%M:%S')]: Invalid number of argument in _log() function call"
    # log_file="${REPORT_FILE}"
  fi
  #_echo "${color}" "[${SCRIPT_NAME}|$(date +'%d-%m-%Y %H:%M:%S')]: ${info}" | tee "${log_file}"
}

# This function is used to reboot the system using force reboot -r now without any arguments
# syntax _reboot
function _reboot() {
  # an exit ASCII symbol invented by MaXi32
  echo "[${SCRIPT_NAME}]: Rebooting system ..." 2>&1 | tee -a "${REPORT_FILE}"
  echo "--<]--"
  shutdown -r now
}

# This function is used to shutdown the system using force shutdown -h now without any arguments
# syntax _shutdown
function _shutdown() {
  # a shutdown ASCII symbol invented by MaXi32
  echo "[${SCRIPT_NAME}]: Shutting down system ..." 2>&1 | tee -a "${REPORT_FILE}"
  echo "--[]--"
  shutdown -h now
}

# This function display the current time spent for running this script.
# It uses the built-in bash SECONDS to get the real execution statement
function script_time() {
  local spent_secs hrs mins secs
  spent_secs=${SECONDS}
  hrs=$((spent_secs / 3600))
  mins=$(((spent_secs - hrs * 3600) / 60))
  secs=$((spent_secs - hrs * 3600 - mins * 60))
  printf "[${SCRIPT_NAME}]: Time spent: %02d H:%02d M :%02d S\n" ${hrs} ${mins} ${secs} 2>&1 | tee -a "${REPORT_FILE}"
}
# This function will shift the current directory into another directory specified in argument
# it will terminate with return error code 1 if the specified path in argument given is not valid
# Usage: cd_to_path <valid_path>
# or : cd_to_path "pre" - to return to previous path after executing the previous cd_to_path <valid_path>
function cd_to_path() {
  local to_path="$1"
  # PREPATH holds a previous path (see global variable of PREPATH in this script)
  if [[ "${to_path}" == "pre" || "${to_path}" == "previous" || "${to_path}" == "prepath" || "${to_path}" == "PREPATH" || "${to_path}" == "back" || "${to_path}" == "oldpath" || "${to_path}" == "oldpwd" || "${to_path}" == "OLDPWD" ]]; then
    to_path="${PREPATH}"
  else
    PREPATH="${PWD}"
  fi
  echo "[${SCRIPT_NAME}]: Entering directory ${to_path} ..." 2>&1 | tee -a "${REPORT_FILE}"
  cd "${to_path}" || {
    echo "Failed to enter into directory" 2>&1 | tee -a "${REPORT_FILE}"
    _exit 1
  }
}

# Store long file text creation in function to avoid duplication
# create_file <name> <optional_path>
function create_file() {
  local name path box_main_disk
  name="$1"
  path="$2"
  box_main_disk="${BOX_MAIN_DISK}"
  if [[ ${name} == "debian-preseed" ]]; then
    install_required "whois" "pwgen"
    {
      # 1 Good reading: https://serverfault.com/questions/893483/what-means-3-numbers-in-manual-partitioning-of-hdd-in-preseed-for-ubuntu
      # 2 Useful setting for SSH: https://github.com/coreprocess/linux-unattended-installation/blob/master/ubuntu/20.04/custom/preseed.cfg
      # 3 This one contains setting for CD rom not in new documentation: https://images.validation.linaro.org/kvm/debian-8.3.0-cd1-preseed.cfg
      echo "# ==============================================="
      echo "# This configuration file was generated by ${SCRIPT_NAME}"
      echo "# Author: ${ADMIN_NAME} | Email: ${ADMIN_EMAIL} | Web: ${BOX_DOMAIN}"
      echo "# ==============================================="
      echo "#### Preseed preconfiguration file (for Debian buster)"
      echo "### Partman early command"

      #echo "d-i partman/early_command \\"
      #echo "string sed -i.bak 's/-f \$id\/skip_erase/-d \$id/g' /lib/partman/lib/crypto-base.sh"

      echo "### Kernal parameter"
      echo "d-i debian-installer/add-kernel-opts string net.ifnames=0 biosdevname=0 console=ttyS0,19200n8"
      echo "### Localization"
      #echo "Test: Fixing no common CDROM on linode:"
      #=============================================
      #https://lists.debian.org/debian-boot/2011/01/msg00169.html
      #https://github.com/uweplonus/adia-install/blob/master/initrd/preseed.cfg#L3
      #https://serverfault.com/questions/685302/unattended-installation-of-ubuntu-from-usb-drive-not-mounted-correctly
      #echo "d-i partman/early_command string mount /dev/sdb /cdrom"
      #echo "d-i preseed/early_command string mount /dev/sdb /cdrom"
      #echo "d-i cdrom-detect/cdrom_device string /dev/sdb"
      #echo "d-i preseed/early_command string \\"
      #echo "umount /cdrom; \\"1
      #echo "mkdir -p /cdrom; \\"
      #echo "mount -t vfat /dev/sdb /cdrom;"
      # All above fixes are not working (left it as reference) because this ISO installer doesn't support booting from hard drive. Need to follow this:
      # https://www.debian.org/releases/buster/amd64/ch04s04.en.html (BOOTING WITH GRUB OR LILO)
      #================================================
      echo "d-i debian-installer/locale string ${BOX_LOCALE}"
      echo "d-i debian-installer/language string ${BOX_LANGUAGE_CODE}"
      echo "d-i debian-installer/country string ${BOX_COUNTRY_CODE}"
      echo ""
      echo "### Keyboard selection"
      echo "d-i keyboard-configuration/xkb-keymap select ${BOX_KEYBOARD}"
      echo ""
      echo "###  Network configuration"
      # This one has many bug reported in Debian forum, need to put in kernel parameter: netcfg/choose_interface eth0 (if not working)
      echo "d-i netcfg/choose_interface select eth0"
      echo "d-i netcfg/use_dhcp string false"
      # If I disable autoconfig, I will get mirror error if network is not configured correctly
      # Actually no need to set IP4 and IPv6 because I use late command is better.
      echo "d-i netcfg/disable_autoconfig boolean true"
      echo "d-i netcfg/dhcp_failed note"
      echo "d-i netcfg/dhcp_options select Configure network manually"
      echo "# IPv4 Static network configuration"
      echo "d-i netcfg/get_ipaddress string ${IPV4_ADD0}"
      echo "d-i netcfg/get_netmask string ${IPV4_NETMASK_IP0}"
      echo "d-i netcfg/get_gateway string ${IPV4_DEF_GATEWAY0}"
      echo "d-i netcfg/get_nameservers string ${NAME_SERVER1}"
      echo "d-i netcfg/confirm_static boolean true"
      echo ""
      # IPv6 will be set using late command below
      #echo "# IPv6 Static network configuration"
      #echo "d-i netcfg/get_ipaddress string ${IPV6_ADD0}"
      #echo "d-i netcfg/get_netmask string ${IPV6_NETMASK0}"
      #echo "d-i netcfg/get_gateway string ${IPV6_DEF_GATEWAY0}"
      #echo "d-i netcfg/get_nameservers string ${NAME_SERVER1}"
      #echo "d-i netcfg/confirm_static boolean true"
      #echo ""
      echo "# Set a hostname"
      echo "d-i netcfg/get_hostname string ${BOX_HOSTNAME}"
      echo "d-i netcfg/get_domain string ${BOX_DOMAIN}"
      echo "# Force a hostname"
      echo "d-i netcfg/hostname string ${BOX_HOSTNAME_FQDN}"
      echo "# Disable that annoying WEP key dialog"
      echo "d-i netcfg/wireless_wep string"
      echo ""
      echo "### Mirror settings"
      echo "d-i mirror/country string manual"
      echo "d-i mirror/http/hostname string deb.debian.org"
      echo "d-i mirror/http/directory string /debian"
      echo "d-i mirror/http/proxy string"
      echo ""
      echo "### Account setup"
      echo "# Skip creation of a normal user account"
      echo "d-i passwd/make-user boolean false"

      echo "# Set root password"
      #echo "d-i passwd/root-password password ${ROOT_USERPASS_INITIAL}"
      #echo "d-i passwd/root-password-again password ${ROOT_USERPASS_INITIAL}"
      echo "# or encrypted using a crypt(3)  hash."
      echo "d-i passwd/root-password-crypted password $(get_hash_pwd "${ROOT_USERPASS_INITIAL}")"
      echo ""
      echo "### Clock and time zone setup"
      echo "# Set hardware clock to UTC"
      echo "d-i clock-setup/utc boolean true"
      echo "# Set timezone"
      echo "d-i time/zone string ${BOX_TIMEZONE}"
      echo "# Use NTP clock during installation"
      echo "d-i clock-setup/ntp boolean true"
      echo ""
      echo "### Partitioning"
      # TODO make a custom LUKS partition here
      # Good reading :https://gist.github.com/chuckn246/ca24d26c048b3cc4ffa8188708f5dccf
      # Another good one: https://www.linuxjournal.com/content/preseeding-full-disk-encryption (it has a way to disable wipe disk)
      # Very nice info: https://secopsmonkey.com/custom-partioning-using-preseed.html
      # Useful maybe https://github.com/uweplonus/adia-install/blob/master/initrd/preseed.cfg#L3
      # Updated very nice: https://gist.github.com/chuckn246/ca24d26c048b3cc4ffa8188708f5dccf

      #echo "# Normal method"
      #echo "d-i partman-auto/disk string ${box_main_disk}"
      #echo "d-i partman-auto/method string lvm"
      #echo "d-i partman-auto-lvm/guided_size string max"
      #echo "d-i partman-lvm/device_remove_lvm boolean true"
      #echo "d-i partman-md/device_remove_md boolean true"
      #echo "d-i partman-lvm/confirm boolean true"
      #echo "d-i partman-lvm/confirm_nooverwrite boolean true"
      #echo "d-i partman-auto/choose_recipe select atomic"
      #echo "d-i partman-partitioning/confirm_write_new_label boolean true"
      #echo "d-i partman/choose_partition select finish"
      #echo "d-i partman/confirm boolean true"
      #echo "d-i partman/confirm_nooverwrite boolean true"
      #echo "d-i partman-md/confirm boolean true"
      #echo "d-i partman-partitioning/confirm_write_new_label boolean true"
      #echo "d-i partman/choose_partition select finish"
      #echo "d-i partman/confirm boolean true"
      #echo "d-i partman/confirm_nooverwrite boolean true"

      echo "# LVM LUKS method"

      #echo "# method to use: regular, lvm or crypto"
      echo "d-i partman-auto/method string crypto"

      #echo "# remove existing LVM"
      echo "d-i partman-lvm/device_remove_lvm boolean true"
      #echo "# remove existing RAID"
      echo "d-i partman-md/device_remove_md boolean true"

      #echo "# Confirm to write LVM partition"
      echo "d-i partman-lvm/confirm boolean true"
      #echo "# amount space to use with LVM"
      echo "d-i partman-auto-lvm/guided_size string max"
      echo "d-i partman-auto-lvm/new_vg_name string ${LVM_VOLUME_GROUP}"
      #echo "#select root disk to use"
      echo "d-i partman-auto/disk string /dev/sda"

      echo "d-i partman-auto/choose_recipe select boot-crypto"
      echo "d-i partman-lvm/confirm_nooverwrite boolean true"

      echo "d-i partman-crypto/passphrase string ${LUKS_PASS}"
      echo "d-i partman-crypto/passphrase-again string ${LUKS_PASS}"
      echo "d-i partman-crypto/weak_passphrase boolean true"
      echo "d-i partman-crypto/confirm boolean true"
      echo "# When disk encryption is enabled, skip wiping the partitions beforehand."
      echo "d-i partman-auto-crypto/erase_disks boolean false"

      echo "d-i partman-auto/expert_recipe string \\"
      echo "boot-crypto :: \\"
      echo "  ${BOX_BOOT_SIZE} ${BOX_BOOT_SIZE} ${BOX_BOOT_SIZE} ext4 \\"
      echo "          \$primary{ } \$bootable{ } \\"
      echo "          method{ format } format{ } \\"
      echo "          use_filesystem{ } filesystem{ ext4 } \\"
      echo "          mountpoint{ /boot } \\"
      echo "          label{ boot } \\"
      echo "  . \\"
      echo "  ${BOX_ROOT_SIZE} ${BOX_ROOT_SIZE} ${BOX_ROOT_SIZE}  ext4 \\"
      echo "          \$lvmok{ } lv_name{ root } \\"
      echo "          in_vg { ${LVM_VOLUME_GROUP} } \\"
      #echo "          \$primary{ } \\"
      echo "          method{ format } format{ } \\"
      echo "          use_filesystem{ } filesystem{ ext4 } \\"
      echo "          mountpoint{ / } \\"
      echo "          label{ root } \\"
      echo "  . \\"
      echo "  ${BOX_TMP_SIZE} ${BOX_TMP_SIZE} ${BOX_TMP_SIZE} ext4 \\"
      echo "          \$lvmok{ } lv_name{ tmp } \\"
      echo "          in_vg { ${LVM_VOLUME_GROUP} } \\"
      #echo "          \$primary{ } \\"
      echo "          method{ format } format{ } \\"
      echo "          use_filesystem{ } filesystem{ ext4 } \\"
      echo "          mountpoint{ /tmp } \\"
      echo "          options/nosuid{ nosuid } \\"
      echo "          options/noexec{ noexec } \\"
      echo "          label{ tmp } \\"
      echo "  . \\"
      echo "  ${BOX_SWAP_SIZE} ${BOX_SWAP_SIZE} ${BOX_SWAP_SIZE} linux-swap \\"
      echo "          \$lvmok{ } lv_name{ swap } \\"
      echo "          in_vg { ${LVM_VOLUME_GROUP} } \\"
      #echo "          \$primary{ } \\"
      echo "          method{ swap } format{ } \\"
      echo "          label{ swap } \\"
      echo "  . \\"
      # The rest of the space
      echo "  40960 61440 ${BOX_HOME_SIZE} ext4 \\"
      echo "          \$lvmok{ } lv_name{ home } \\"
      echo "          in_vg { ${LVM_VOLUME_GROUP} } \\"
      #echo "          \$primary{ } \\"
      echo "          method{ format } format{ } \\"
      echo "          use_filesystem{ } filesystem{ ext4 } \\"
      echo "          mountpoint{ /home } \\"
      echo "          options/nosuid{ nosuid } \\"
      echo "          label{ home } \\"
      echo "  ."

      echo "d-i partman-basicfilesystems/no_mount_point boolean false"
      echo "d-i partman-partitioning/confirm_write_new_label boolean true"
      echo "d-i partman/choose_partition select finish"
      echo "d-i partman/confirm boolean true"
      echo "d-i partman/confirm_nooverwrite boolean true"

      echo ""
      echo "### Apt setup"
      # Disable mirror will cause problem with software selection
      #echo "#d-i apt-setup/use_mirror boolean false"
      echo "d-i apt-setup/cdrom/set-first boolean false"
      echo "d-i apt-setup/cdrom/set-next boolean false"
      echo "d-i apt-setup/cdrom/set-failed boolean false"
      echo "d-i apt-setup/services-select multiselect security, updates"
      echo "d-i apt-setup/security_host string security.debian.org"
      #echo ""
      echo "### Package selection"
      echo "tasksel tasksel/first multiselect standard"
      echo "# Individual additional packages to install"
      echo "d-i pkgsel/include string openssh-server"
      echo "popularity-contest popularity-contest/participate boolean false"
      echo ""
      echo "### Boot loader installation"
      echo "# Grub location"
      echo "d-i grub-installer/only_debian boolean true"
      echo "d-i grub-installer/with_other_os boolean true"
      echo "d-i grub-installer/bootdev string /dev/sda"
      echo ""
      echo "# Grub password"
      echo "#d-i grub-installer/password password r00tme"
      echo "#d-i grub-installer/password-again password r00tme"
      echo "# or encrypted using an MD5 hash, see grub-md5-crypt(8)."
      echo "#d-i grub-installer/password-crypted password [MD5 hash]"
      echo ""
      echo "### Finishing up the installation"
      echo "# Avoid that last message about the install being complete."
      echo "# This will skip the dialog box after installation finished"
      echo "d-i finish-install/reboot_in_progress note"
      echo "# This will shutdown after install"
      # Make sure to disable linode shutdown watchdog to turn off linode after installed else it will auto boot:
      echo "d-i debian-installer/exit/poweroff boolean true"
      # At this point, I can use API to determine if the system s shut down, then it means installation is finished.
      # Then if the port 893 is available I can use that port to login.
      # Good reading for executing script or store: https://github.com/uweplonus/adia-install/blob/master/initrd/preseed.cfg#L3
      echo "### Execute final scripts "
      # To install other package using late_command
      # new line separated by \
      echo "d-i preseed/late_command string \\"
      echo "in-target apt-get -y install htop wget git dropbear-initramfs; \\"
      # Allow root login (TODO: make sure it used cert to login)
      # For encryption https://stackoverflow.com/questions/33113363/debian-preseed-late-command-not-executed
      # Another tip: https://askubuntu.com/questions/364051/how-do-you-preseed-an-ssh-key
      # UNLOCK LUKS doc here: https://www.cyberciti.biz/security/how-to-unlock-luks-using-dropbear-ssh-keys-remotely-in-linux/
      #echo "in-target cp /cdrom/configure_box.sh /usr/local/bin/ ;\\"
      #echo "in-target chmod +x /usr/local/bin/configure.sh ;\\"
      #echo "in-target /usr/local/bin/configure_box.sh; \\"
      echo "mkdir -p /target/root/.ssh; \\"
      #echo "cat ${rsa_private_key} > /target/root/.ssh/authorized_keys; \\"
      echo "cp /cdrom/root_${ROOT_USERNAME}_${BOX_HOSTNAME_FQDN}.id_rsa.pub /target/root/.ssh/authorized_keys; \\"
      echo "cp /cdrom/user_${SSH_USERNAME}_${BOX_HOSTNAME_FQDN}.id_rsa.pub /target/root/user_${SSH_USERNAME}_${BOX_HOSTNAME_FQDN}.id_rsa.pub; \\"
      echo "chmod -R go-rwx /target/root/.ssh; \\"
      echo "sed -i 's/^#PermitRootLogin.*/PermitRootLogin prohibit-password/g' /target/etc/ssh/sshd_config; \\"
      echo "sed -i 's/^#PubkeyAuthentication.*/PubkeyAuthentication yes/g' /target/etc/ssh/sshd_config; \\"
      echo "sed -i \"s/^#Port 22/Port ${SSH_PORT}/\" /target/etc/ssh/sshd_config; \\"
      # This will disable the interface name convention (just put in kernel line)
      #echo "in-target sed -i 's/GRUB_CMDLINE_LINUX=\"[^\"]*/&net.ifnames=0 biosdevname=0/' /etc/default/grub; \\"
      echo "echo "\"GRUB_TERMINAL=serial\""  >> /target/etc/default/grub; \\"
      echo "echo "\"GRUB_SERIAL_COMMAND=\\"\"serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1\\\"\"" \>\> /target/etc/default/grub\; \\""
      echo "in-target update-grub; \\"
      # This will write a new static IP and use the default interface eth0
      echo "echo "\"source /target/etc/network/interfaces.d/*\"" > /target/etc/network/interfaces; \\"
      echo "echo "\"auto lo\"" >> /target/etc/network/interfaces; \\"
      echo "echo "\"iface lo inet loopback\"" >> /target/etc/network/interfaces; \\"
      echo "echo "\"auto ${NIC_INTERFACE_NAME}\"" >> /target/etc/network/interfaces; \\"
      echo "echo "\"iface ${NIC_INTERFACE_NAME} inet static\"" >> /target/etc/network/interfaces; \\"
      echo "echo "\"address ${IPV4_ADD0}${IPV4_NETMASK0}\"" >> /target/etc/network/interfaces; \\"
      echo "echo "\"gateway ${IPV4_DEF_GATEWAY0}\"" >> /target/etc/network/interfaces; \\"
      echo "echo "\"iface ${NIC_INTERFACE_NAME} inet6 static\"" >> /target/etc/network/interfaces; \\"
      echo "echo "\"address ${IPV6_ADD0}${IPV6_NETMASK0}\"" >> /target/etc/network/interfaces; \\"
      echo "echo "\"address ${IPV6_DEF_GATEWAY0}\"" >> /target/etc/network/interfaces; \\"
      # This will write a new resolve at /etc/resolv.conf
      echo "echo "\"search ${BOX_DOMAIN}\"" > /target/etc/resolv.conf; \\"
      echo "echo "\"domains ${BOX_HOSTNAME_FQDN}\"" >> /target/etc/resolv.conf; \\"
      echo "echo "\"options rotate\"" > /target/etc/resolv.conf; \\"
      echo "echo "\"nameserver ${NAME_SERVER1}\"" >> /target/etc/resolv.conf; \\"
      echo "echo "\"nameserver ${NAME_SERVER2}\"" >> /target/etc/resolv.conf; \\"
      echo "echo "\"nameserver ${NAME_SERVER3}\"" >> /target/etc/resolv.conf; \\"
      # For LUKS auto login
      echo "sed -i 's/^#DROPBEAR_OPTIONS=/DROPBEAR_OPTIONS=\"-I 180 -j -k -p ${DROP_BEAR_PORT} -s\"/' /target/etc/dropbear-initramfs/config; \\"
      echo "echo "\"IP=${IPV4_ADD0}::${IPV4_DEF_GATEWAY0}:${IPV4_NETMASK_IP0}:${BOX_HOSTNAME}:${NIC_INTERFACE_NAME}:off\"" >> /target/etc/initramfs-tools/initramfs.conf; \\"
      echo "cp /cdrom/root_${ROOT_USERNAME}_${BOX_HOSTNAME_FQDN}.id_rsa.pub /target/etc/dropbear-initramfs/authorized_keys; \\"
      echo "in-target update-initramfs -u;"

      # Installing some packages

    } >"${path}"
  fi
}
function create_rescue_iso() {
  install_required "genisoimage" "wget" "pwgen" "whois" "xorriso" "debconf" "isolinux" "syslinux-utils" "squashfs-tools" "putty-tools"
  dbx_cli="${SCRIPT_PATH}/storage/os/debian/usr/local/maxicode/maxicloud/dropbox/dbx"
  if [[ "${HOST_MAX_PROCESSOR}" -lt 2 ]]; then
    _echo 'red' "Warning, this process will run slower when using compression tool because HOST_MAX_PROCESSOR is set less than 2"
    echo ""
  fi
  echo "Creating a new RSA Key for rescue root login ..."
  ssh_key_manager "create-key-with-putty" "rescue" "root" "${BOX_HOSTNAME_FQDN}_secure_auth"

  # Good guide : https://www.dotpointer.ga/?section=notes&view=note&id_notes=164
  # Good guide 2: https://rmprepusb.com/tutorials/011-make-an-image-recovery-usb-drive-using-finnix/
  local action="$1"
  local retval=0
  local method="$1"
  local option="$2"
  local root_temp_path isofile isofile_final isomount_location finnix_select_version isodir_write iso_url isofile_final_base_name file_direct_link

  if [ $# -gt 3 ]; then
    echo "Argument shouldn't be more than 3 for now. See --help for more information"
    _exit 1
  fi
  root_temp_path="/root/tmp_iso/debian"
  isofile="${root_temp_path}/finnix-122.iso"
  isofile_final="${root_temp_path}/finnix_mod.iso"
  isofile_final_base_name="$(basename -- ${isofile_final})"
  iso_output_path="/mnt/c/Users/Maxibi/IdeaProjects/maxisetup/storage/os/debian/finnixmod.iso"
  isomount_location="/mnt/mount_riso"
  isodir_write="${root_temp_path}/riso-rw"

  #https://www.finnix.org/releases/122/finnix-122.iso
  finnix_select_version="122"

  iso_url="https://www.finnix.org/releases/${finnix_select_version}/finnix-${finnix_select_version}.iso"

  echo "Removing previous file ${isofile_final} ..."
  rm -rf "${isofile_final}"
  echo ""
  echo "Removing previous file ${isodir_write} ..."
  rm -rf "${isodir_write}"

  mkdir -p "${root_temp_path}"
  mkdir -p "${isomount_location}"
  mkdir -p "${isodir_write}"
  echo ""

  echo "Creating a custom Finnix rescue disk for hard disk booting ..."
  echo ""
  if [[ "${option}" == "--update-iso" || -z "${option}" ]]; then
    if [ -f "${isofile}" ]; then
      rm -rf "${isofile}"
      echo "Re-downloading system image ..."
    else
      echo "Downloading new system image ..."
    fi

    wget -nc -O "${isofile}" "${iso_url}" || true
  elif [[ "${option}" == "--no-update-iso" ]]; then
    if [ -f "${isofile}" ]; then
      echo "Using the existing ISO file ..."
    else
      echo "Warning, existing ISO file is missing! Use --update-iso option to download new file"
      _exit 1
    fi
    # Do nothing
  else
    echo "Invalid option supplied: ${option}"
    echo "${SCRIPT_NAME} ${action} --update-iso , to download the new ISO file where --update-iso is a default command if not specified"
    echo "${SCRIPT_NAME} ${action} --no-update-iso , to use existing ISO file"
    _exit 1
  fi
  echo ""
  echo "Copying ISO file content into writeable directory ${isodir_write} ..."
  xorriso -osirrox on -indev ${isofile} -extract / ${isodir_write}/
  echo ""
  echo "Removing initial ISO file ..."
  rm -rf "${isofile}"
  echo ""
  echo "Disabling startup timer menu (straight boot to the default menu) ..."
  sed -i "s/timeout .*/timeout 1/" ${isodir_write}/isolinux/isolinux.cfg
  echo ""
  #echo "Adding noeject and noprompt boot parameter at grub.cfg ..."
  #{
  #  echo "source /boot/grub/config.cfg"
  #  echo "# Live boot"
  #  echo "menuentry \"Live system\" --hotkey=l {"
  #  echo "    linux	/live/vmlinuz-5.10.0-3-amd64 quiet"
  #  echo "    initrd	/live/initrd.img-5.10.0-3-amd64"
  #  echo "}"
  #} >${isodir_write}/boot/grub/grub.cfg
  echo ""
  echo "Creating startup script on startup ..."
  #Guide here: https://www.finnix.org/Overlays (Startup shell scripts)
  mkdir -p "${isodir_write}/finnix/arch/indep/rc"
  echo "#!/bin/bash" >"${isodir_write}/finnix/arch/indep/rc/initial.sh"
  echo "#any startup script here" >>"${isodir_write}/finnix/arch/indep/rc/initial.sh"
  chmod +x "${isodir_write}/finnix/arch/indep/rc/initial.sh"
  echo ""
  echo "Creating working directory ${isodir_write}/live/workdir"
  mkdir -p "${isodir_write}/live/workdir"
  echo ""
  echo "Moving ${isodir_write}/live/filesystem.squashfs into ${isodir_write}/live/workdir ..."
  mv "${isodir_write}/live/filesystem.squashfs" "${isodir_write}/live/workdir"
  echo ""
  cd_to_path "${isodir_write}/live/workdir"
  echo "Extracting squashfs file filesystem.squashfs ..."
  unsquashfs -processors "${HOST_MAX_PROCESSOR}" filesystem.squashfs
  echo ""
  echo "Removing the old filesystem.squashfs file ..."
  rm -rf filesystem.squashfs
  echo ""
  #exit 1
  # Now we have all file in here: isodir_write/live/workdir/squashfs-root/*
  echo "Creating .ssh directory in ${isodir_write}/live/workdir/squashfs-root/root/.ssh ..."
  mkdir -p "${isodir_write}/live/workdir/squashfs-root/root/.ssh"
  echo ""
  echo "Copying RSA certificate in ${isodir_write}/live/workdir/squashfs-root/root/.ssh/authorized_keys ..."

  #cp "${SCRIPT_PATH}/secure/rescue_root_${BOX_HOSTNAME_FQDN}.id_rsa.pub" "${isodir_write}/live/workdir/squashfs-root/root/.ssh/authorized_keys"
  ssh_key_manager "get-public-key" "rescue" "root" >"${isodir_write}/live/workdir/squashfs-root/root/.ssh/authorized_keys"

  echo ""
  echo "Raising permission of .ssh folder ..."
  chmod -R go-rwx "${isodir_write}/live/workdir/squashfs-root/root/.ssh"
  echo ""
  echo "Disabling SSH root login in sshd_config ..."
  sed -i 's/^.*PermitRootLogin.*/PermitRootLogin no/g' "${isodir_write}/live/workdir/squashfs-root/etc/ssh/sshd_config"
  echo ""

  echo "Changing SSH login port to ${RESCUE_SSH_PORT} ..."
  sed -i "s/#Port 22/Port ${RESCUE_SSH_PORT}/" "${isodir_write}/live/workdir/squashfs-root/etc/ssh/sshd_config"
  echo ""

  echo "Creating startup script at .profile to restart ssh on startup ..."
  echo "systemctl restart ssh" >>"${isodir_write}/live/workdir/squashfs-root/root/.profile"
  #chmod +x "${isodir_write}/live/workdir/squashfs-root/etc/rc.local"
  echo ""

  echo "Recreating the squashfs	filesystem from filesystem.squashfs ..."
  mksquashfs squashfs-root filesystem.squashfs -b 1024k -comp xz -Xbcj x86 -e boot -processors "${HOST_MAX_PROCESSOR}"
  echo ""

  echo "Moving filesystem.squashfs into ${isodir_write}/live/filesystem.squashfs ..."
  mv filesystem.squashfs ${isodir_write}/live/filesystem.squashfs
  echo ""
  echo "Removing working directory ..."
  rm -rf ${isodir_write}/live/workdir
  echo ""
  cd_to_path "${isodir_write}"
  echo "Creating new sha256sum checksum for sha256sum.txt ..."
  chmod +w sha256sum.txt
  find "${isodir_write}" -follow -type f ! -name sha256sum.txt -print0 | xargs -0 sha256sum >sha256sum_tmp.txt
  mv -f sha256sum_tmp.txt sha256sum.txt
  chmod -w sha256sum.txt
  echo ""
  echo "Creating standalone ISO installation inside ${isofile_final} ..."
  xorriso -as mkisofs \
    -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin \
    -c isolinux/boot.cat \
    -b isolinux/isolinux.bin \
    -no-emul-boot \
    -boot-load-size 4 \
    -boot-info-table \
    -eltorito-alt-boot \
    -isohybrid-gpt-basdat \
    -o ${isofile_final} \
    ${isodir_write}

  # Do not quote the path. If quote it will become redundant path: '/root/tmp_iso/debian/riso-rw/~/tmp_iso/debian/riso-rw'
  echo ""

  # Copying to shared folder
  echo "Creating installation disk at ${iso_output_path} ..."
  cp "${isofile_final}" "${iso_output_path}"
  echo ""
  echo "Copying RSA private keys inside ISO output ..."
  cp "${rsa_private_key}" "$(dirname "${iso_output_path}")/"
  cp "${rsa_private_key_ppk}" "$(dirname "${iso_output_path}")/"
  # Uploading to dropbox
  echo ""
  echo "Uploading ${isofile_final} into dropbox /files/${isofile_final_base_name} ..."
  ${dbx_cli} upload "${isofile_final}" "/files"

  echo "Creating download link ..."
  file_direct_link=$(${dbx_cli} share "/files/${isofile_final_base_name}" | awk '{ print $4}' | sed 's/0$/1/g')
  echo "File direct link is: ${file_direct_link}"
  echo ""
  echo "Creating rescue disk script ..."
  _echo 'red' "=================================="
  echo ""
  echo "wget -O mini.iso \"${file_direct_link}\"" >"$(dirname "${iso_output_path}")/install.txt"
  echo "dd if=mini.iso of=/dev/sda" >>"$(dirname "${iso_output_path}")/install.txt"
  _echo 'green' "wget -O mini.iso \"${file_direct_link}\""
  _echo 'green' "dd if=mini.iso of=/dev/sda"
  _echo 'green' "mkdir /mnt/iso"
  _echo 'green' "mount mini.iso /mnt/iso"
  _echo 'green' "echo \"\""
  echo ""
  _echo 'red' "=================================="
  echo ""

  echo "Copying script into linode script ${SCRIPT_PATH}/linode... "
  {
    echo "#!/bin/bash"
    echo "wget -O mini.iso ${file_direct_link}"
    echo "dd if=mini.iso of=/dev/sda"
    # Need this option to reboot when reboot check
    echo "reboot -f"
    echo "exit 0"
  } >"${SCRIPT_PATH}/linode/rescue_write.sh"

  echo "Removing working directory ..."
  rm -rf "${isodir_write}"
}
function create_os_iso() {
  local action="$1"
  local retval=0
  local iso_os="${BOX_ISO_OS_TYPE}"
  local method="$1"
  local option="$2"
  if [ $# -gt 3 ]; then
    echo "Argument shouldn't be more than 3 for now. See --help for more information"
    _exit 1
  fi
  YEAR_MONTH_DAY=$(date "+%Y-%m-%d")
  ROOT_TEMP_PATH="/root/tmp_iso/debian"
  ISOFILE="${ROOT_TEMP_PATH}/debian-netinst.iso"
  ISOFILE_FINAL="${ROOT_TEMP_PATH}/deb10mod-final.iso"
  ISOFILE_FINAL_BASE_NAME="$(basename -- ${ISOFILE_FINAL})"
  ISOMOUNT_LOCATION="/mnt/mount_iso"
  ISODIR_WRITE="${ROOT_TEMP_PATH}/iso-rw"
  ISODIR_WRITE_TMP="${ROOT_TEMP_PATH}/iso-rw-tmp"
  PRESEED_FILE="${ROOT_TEMP_PATH}/preseed.txt"
  SOURCE_FILE="${ROOT_TEMP_PATH}/sources.list"
  DEBIAN_NAME="debian"
  DEBIAN_RELEASE="buster"
  DEBIAN_SELECT_VERSION="10.9.0"
  DEBIAN_SELECT_PLATFORM="amd64"
  DEBIAN_IMAGE_TYPE="iso-cd"
  DEBIAN_ISO_INSTALLATION_TYPE="netinst"

  ISO_URL="http://cdimage.debian.org/cdimage/release/current/${DEBIAN_SELECT_PLATFORM}/${DEBIAN_IMAGE_TYPE}/${DEBIAN_NAME}-${DEBIAN_SELECT_VERSION}-${DEBIAN_SELECT_PLATFORM}-${DEBIAN_ISO_INSTALLATION_TYPE}.iso"
  #http://cdimage.debian.org/cdimage/release/current/amd64/iso-cd/debian-10.9.0-amd64-netinst.iso
  INITRD_GZ_URL="http://ftp.debian.org/debian/dists/buster/main/installer-amd64/current/images/hd-media/initrd.gz"
  VMLINUZ_URL="http://ftp.debian.org/debian/dists/buster/main/installer-amd64/current/images/hd-media/vmlinuz"
  ISO_OUTPUT_PATH="/mnt/c/Users/Maxibi/IdeaProjects/maxisetup/storage/os/debian/deb10mod.iso"

  #if mountpoint -q ${ISOMOUNT_LOCATION}; then
  #  echo "Unmounting disk from ${ISOMOUNT_LOCATION} ..."
  #  sudo umount -f ${ISOMOUNT_LOCATION}
  #fi

  #echo "Removing previous files ..."

  rm -rf "${ISOFILE_FINAL}"
  rm -rf "${ISODIR_WRITE}"
  rm -rf "${ISODIR_WRITE_TMP}"
  rm -rf "${PRESEED_FILE}"
  rm -rf "${SOURCE_FILE}"

  mkdir -p "${ROOT_TEMP_PATH}"
  mkdir -p "${ISOMOUNT_LOCATION}"
  mkdir -p "${ISODIR_WRITE}"
  mkdir -p "${ISODIR_WRITE_TMP}"
  echo ""

  if [ "${method}" == "--legacy" ]; then
    echo "Building a custom ${iso_os} image file for server setup in legacy mode ..."
    # whois contains mkpasswd
    # List out required components here as an array to automatically install them:
    install_required "genisoimage" "wget" "pwgen" "whois" "xorriso" "debconf" "isolinux" "syslinux-utils"
    echo ""
    if [[ "${option}" == "--update-iso" || -z "${option}" ]]; then
      if [ -f ${ISOFILE} ]; then
        rm -rf "${ISOFILE}"
        echo "Re-downloading system image ..."
      else
        echo "Downloading new system image ..."
      fi
      wget -nc -O ${ISOFILE} ${ISO_URL} || true
    elif [[ "${option}" == "--no-update-iso" ]]; then
      if [ -f ${ISOFILE} ]; then
        echo "Using the existing ISO file ..."
      else
        echo "Warning, existing ISO file is missing! Use --update-iso option to download new file"
        _exit 1
      fi
      # Do nothing
    else
      echo "Invalid option supplied: ${option}"
      echo "${SCRIPT_NAME} ${action} --update-iso , to download the new ISO file where --update-iso is a default command if not specified"
      echo "${SCRIPT_NAME} ${action} --no-update-iso , to use existing ISO file"
      _exit 1
    fi
    echo ""
    #echo "Mounting ISO file ${ISOFILE} into ${ISOMOUNT_LOCATION} ..."
    #sudo mount -o loop ${ISOFILE} ${ISOMOUNT_LOCATION}
    #echo ""

    #echo "Copying ISOFILE content into writeable directory ${ISODIR_WRITE} ..."
    #cp -rT ${ISOMOUNT_LOCATION}/ ${ISODIR_WRITE}/
    # rsync -a -H --exclude=TRANS.TBL ${ISOMOUNT_LOCATION}/ ${ISODIR_WRITE}
    #echo ""
    #echo "Unmounting ISO ${ISOFILE} from ${ISOMOUNT_LOCATION} ..."
    #umount ${ISOMOUNT_LOCATION}
    #echo ""

    echo "Copying ISOFILE content into writeable directory ${ISODIR_WRITE} ..."
    xorriso -osirrox on -indev ${ISOFILE} -extract / ${ISODIR_WRITE}/

    echo "Removing initial ISO file ..."
    rm -rf "${ISOFILE}"
    #echo "Correcting permissions ..."
    #chmod 755 -R ${ISODIR_WRITE}
    #echo ""

    echo "Writing new preseed file config ..."
    create_file "debian-preseed" ${PRESEED_FILE}
    echo ""

    echo "Checking preseed syntax file ${PRESEED_FILE} ..."
    if ! debconf-set-selections -c "${PRESEED_FILE}"; then
      echo "There is an error in the preseed.cfg. Check the syntax of the preconfiguration file."
      _exit 1
    else
      echo "The preseed file ${PRESEED_FILE} syntax is ok"
    fi
    echo ""
    # Here I write custom preseed file based on CONFIG
    echo "Copying raw preseed file into ${ISODIR_WRITE}/preseed.cfg ..."
    cp "${PRESEED_FILE}" ${ISODIR_WRITE}/preseed.cfg
    #chmod 555 ${ISODIR_WRITE}/preseed.cfg
    echo ""

    # For text menu setup
    echo "Editing isolinux/txt.cfg to add extra arguments for initial setup ..."
    sed -i "s/initrd.gz/initrd.gz file=\/cdrom\/preseed.cfg locale=${BOX_LOCALE} keymap=${BOX_KEYBOARD} language=${BOX_LANGUAGE_CODE} country=${BOX_COUNTRY_CODE}/" ${ISODIR_WRITE}/isolinux/txt.cfg
    echo ""

    # For adtxt menu setup
    echo "Editing isolinux/adtxt.cfg to add extra arguments for initial setup ..."
    sed -i "s/initrd.gz/initrd.gz file=\/cdrom\/preseed.cfg locale=${BOX_LOCALE} keymap=${BOX_KEYBOARD} language=${BOX_LANGUAGE_CODE} country=${BOX_COUNTRY_CODE}/" ${ISODIR_WRITE}/isolinux/adtxt.cfg
    echo ""

    # For graphic menu setup
    echo "Editing isolinux/gtk.cfg to add extra arguments for initial setup ..."
    sed -i "s/initrd.gz/initrd.gz file=\/cdrom\/preseed.cfg locale=${BOX_LOCALE} keymap=${BOX_KEYBOARD} language=${BOX_LANGUAGE_CODE} country=${BOX_COUNTRY_CODE}/" ${ISODIR_WRITE}/isolinux/gtk.cfg
    echo ""

    # There are bunch of other cfg files like adtxt.cfg that required modification,
    # append it like above if it doesn't work for other system or just use BOX_OS_INSTALL_UI=custom for universal menu

    #  (https://serverfault.com/questions/238844/debian-installation-from-rescue-system-with-preseed-fully-automated)
    if [ "${BOX_OS_INSTALL_UI}" == "normal" ]; then
      echo "Editing isolinux/isolinux.cfg to disable setup menu (straight to the first menu on startup) ..."
      sed -i "s/timeout 0/timeout 3/" ${ISODIR_WRITE}/isolinux/isolinux.cfg
      echo ""
    elif [ "${BOX_OS_INSTALL_UI}" == "custom" ]; then
      {
        echo "default install"
        echo "LABEL install"
        echo "   kernel /install.amd/vmlinuz"
        echo "   append vga=normal initrd=/install.amd/initrd.gz preseed/file=/cdrom/preseed.cfg locale=${BOX_LOCALE} keymap=${BOX_KEYBOARD} language=${BOX_LANGUAGE_CODE} country=${BOX_COUNTRY_CODE} --"
        echo "LABEL linux"
        echo "   kernel /install.amd/vmlinuz"
        echo "   append vga=normal initrd=/install.amd/initrd.gz preseed/file=/cdrom/preseed.cfg locale=${BOX_LOCALE} keymap=${BOX_KEYBOARD} language=${BOX_LANGUAGE_CODE} country=${BOX_COUNTRY_CODE} --"
        echo "prompt 0"
        echo "timeout 1"
      } >${ISODIR_WRITE}/isolinux/isolinux.cfg
    elif [ "${BOX_OS_INSTALL_UI}" == "console" ]; then

      {
        # This will install OS using serial of console for system that doesn't support graphic install -- BETA
        echo "serial 0 115200"
        echo "console 0"
        echo "default install"
        echo "LABEL install"
        echo "   kernel /install.amd/vmlinuz"
        echo "   append priority=low vga=788 console=ttyS0,115200n8 initrd=/install.amd/initrd.gz preseed/file=/cdrom/preseed.cfg locale=${BOX_LOCALE} keymap=${BOX_KEYBOARD} language=${BOX_LANGUAGE_CODE} country=${BOX_COUNTRY_CODE} --- console=ttyS0,115200n8"
        echo "LABEL linux"
        echo "   kernel /install.amd/vmlinuz"
        echo "   append priority=low vga=788 console=ttyS0,115200n8 initrd=/install.amd/initrd.gz preseed/file=/cdrom/preseed.cfg locale=${BOX_LOCALE} keymap=${BOX_KEYBOARD} language=${BOX_LANGUAGE_CODE} country=${BOX_COUNTRY_CODE} --- console=ttyS0,115200n8"
        echo "prompt 0"
        echo "timeout 1"

      } >${ISODIR_WRITE}/isolinux/isolinux.cfg
    else
      echo "Error, invalid variable supplied for BOX_OS_INSTALL_UI: ${BOX_OS_INSTALL_UI}"
      _exit 1
    fi

    echo "Changing permission of ${ISODIR_WRITE}/preseed.cfg to own by root:root ..."
    chown root:root ${ISODIR_WRITE}/preseed.cfg
    echo ""
    echo "Lower the files permission from ${ISODIR_WRITE}/install.amd to +w ..."
    chmod +w -R "${ISODIR_WRITE}/install.amd"
    echo ""
    echo "Unzipping initrd.gz"
    gunzip "${ISODIR_WRITE}/install.amd/initrd.gz"
    echo ""
    echo "Inserting preseed.cfg in initrd ..."
    echo ${ISODIR_WRITE}/preseed.cfg | cpio -H newc -o -A -F "${ISODIR_WRITE}/install.amd/initrd"
    echo ""
    ##exit 1
    echo "Zipping initrd as initrd.gz ..."
    gzip ${ISODIR_WRITE}/install.amd/initrd
    echo ""
    echo "Change the folder permission of ${ISODIR_WRITE}/install.amd/ to -w ..."
    chmod -w -R ${ISODIR_WRITE}/install.amd/
    echo ""

    echo "Fixing md5sum checksum ..."
    cd_to_path "${ISODIR_WRITE}"
    #pushd ${ISODIR_WRITE}
    #  md5sum $(find -type f) > md5sum.txt
    #popd

    # A warning will be issued because ./debian is a symlink to . :
    # find: File system loop detected; ‘./debian’ is part of the same file system loop as ‘.’ :
    chmod +w md5sum.txt
    find "${ISODIR_WRITE}" -follow -type f ! -name md5sum.txt -print0 | xargs -0 md5sum >md5sum.txt
    chmod -w md5sum.txt

    #cd_to_path "${ROOT_TEMP_PATH}"
    #echo "The final path is ${PREPATH}"
    echo ""
    #exit 1
    echo "Creating ISO ..."

    #genisoimage -r -J -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -o "${ISOFILE_FINAL}" "${ISODIR_WRITE}"

    #xorriso -as mkisofs -o ${ISOFILE_FINAL} \
    #  -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin \
    #  -c isolinux/boot.cat -b isolinux/isolinux.bin -no-emul-boot \
    #  -boot-load-size 4 -boot-info-table ${ISODIR_WRITE}

    xorriso -as mkisofs \
      -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin \
      -c isolinux/boot.cat \
      -b isolinux/isolinux.bin \
      -no-emul-boot \
      -boot-load-size 4 \
      -boot-info-table \
      -eltorito-alt-boot \
      -e boot/grub/efi.img \
      -no-emul-boot \
      -isohybrid-gpt-basdat \
      -o ${ISOFILE_FINAL} \
      ${ISODIR_WRITE}

    echo ""
    # Copying to shared folder
    echo "Creating installation disk at ${ISO_OUTPUT_PATH} ..."
    cp "${ISOFILE_FINAL}" "${ISO_OUTPUT_PATH}"
    #echo "Uploading ISO file to dropbox"
    #dbxcli put "${ISO_OUTPUT_PATH}"
  # My custom method for server (Like the LILO or GRUB method)
  elif [[ "${method}" == "--hdd-iso" || "${method}" == "--hdd-boot" || "${method}" == "--hdd" || "${method}" == "--isolinux" ]]; then

    # For hard disk booting
    dbx_cli="${SCRIPT_PATH}/storage/os/debian/usr/local/maxicode/maxicloud/dropbox/dbx"
    echo "Creating new RSA Key for root login ..."
    # This will create 2 files one is private and another one with the extension .pub
    # For root
    ssh_key_manager "create-key-with-putty" "root" "${ROOT_USERNAME}" "${BOX_HOSTNAME_FQDN}_secure_auth"
    local rsa_public_key="${SCRIPT_PATH}/secure/ssh/root_${ROOT_USERNAME}_${BOX_HOSTNAME_FQDN}.id_rsa.pub"
    local rsa_private_key="${SCRIPT_PATH}/secure/ssh/root_${ROOT_USERNAME}_${BOX_HOSTNAME_FQDN}.id_rsa"
    local rsa_private_key_ppk="${SCRIPT_PATH}/secure/ssh/root_${ROOT_USERNAME}_${BOX_HOSTNAME_FQDN}.ppk"

    # For normal user
    ssh_key_manager "create-key-with-putty" "user" "${SSH_USERNAME}" "${BOX_HOSTNAME_FQDN}_secure_auth"

    if [ ! -f "${rsa_public_key}" ]; then
      echo "RSA public key file not found!"
      _exit 1
    else
      echo "Using RSA public key from ${rsa_public_key} ..."
    fi
    echo ""
    echo "Building a custom ${iso_os} image file for server setup in syslinux bootloader (Hardisk Booting) ..."
    echo ""
    # Fixing
    cd_to_path "${SCRIPT_PATH}"
    install_required "debconf" "isolinux" "syslinux-utils" "xorriso" "wget"
    if [[ "${option}" == "--update-iso" || -z "${option}" ]]; then
      # wget --timestamping option also can be used
      if [ -f ${ISOFILE} ]; then
        rm -rf "${ISOFILE}"
        echo "Re-downloading system image ..."
      else
        echo "Downloading new system image ..."
      fi
      wget -nc -O ${ISOFILE} ${ISO_URL} || true
    elif [[ "${option}" == "--no-update-iso" ]]; then
      if [ -f ${ISOFILE} ]; then
        echo "Using the existing ISO file ..."
      else
        echo "Warning, existing ISO file is missing! Use --update-iso or ignore the --no-update-iso option to download new file"
        _exit 1
      fi
    else
      echo "Invalid option supplied: ${option}"
      echo "${SCRIPT_NAME} ${action} --update-iso , to download the new ISO file where --update-iso is a default command if not specified"
      echo "${SCRIPT_NAME} ${action} --no-update-iso , to use existing ISO file"
      _exit 1
    fi
    echo ""
    echo "Writing new preseed file config ..."
    # Writing new preseed.cfg
    create_file "debian-preseed" ${PRESEED_FILE}
    echo ""
    echo "Checking preseed syntax file ${PRESEED_FILE} ..."
    if ! debconf-set-selections -c "${PRESEED_FILE}"; then
      echo "There is an error in the preseed.cfg. Check the syntax of the preconfiguration file."
      _exit 1
    else
      echo "The preseed file ${PRESEED_FILE} syntax is ok"
    fi
    echo ""
    echo "Copying ISOFILE content into temporary writeable directory ${ISODIR_WRITE_TMP} ..."
    xorriso -osirrox on -indev ${ISOFILE} -extract / ${ISODIR_WRITE_TMP}/
    echo ""
    echo "Removing initial ISO file ..."
    rm -rf "${ISOFILE}"

    #echo "Editing isolinux/isolinux.cfg to disable setup menu (straight to the first menu on startup) ..."
    #sed -i "s/timeout 0/timeout 1/" ${ISODIR_WRITE_TMP}/isolinux/isolinux.cfg
    echo ""
    echo "Copying raw preseed file into ${ISODIR_WRITE_TMP}/preseed.cfg ..."
    cp "${PRESEED_FILE}" ${ISODIR_WRITE_TMP}/preseed.cfg
    #chmod 555 ${ISODIR_WRITE}/preseed.cfg
    echo ""

    echo "Writing rsa public key (root) file into ${ISODIR_WRITE_TMP}/root_${ROOT_USERNAME}_${BOX_HOSTNAME_FQDN}.id_rsa.pub ..."
    #cp "${rsa_public_key}" "${ISODIR_WRITE_TMP}/root_${BOX_HOSTNAME_FQDN}.id_rsa.pub"
    ssh_key_manager "get-public-key" "root" "${ROOT_USERNAME}" >"${ISODIR_WRITE_TMP}/root_${ROOT_USERNAME}_${BOX_HOSTNAME_FQDN}.id_rsa.pub"
    echo ""
    echo "Writing rsa public key (user) file into ${ISODIR_WRITE_TMP}/user_${SSH_USERNAME}_${BOX_HOSTNAME_FQDN}.id_rsa.pub ..."
    ssh_key_manager "get-public-key" "user" "${SSH_USERNAME}" >"${ISODIR_WRITE_TMP}/user_${SSH_USERNAME}_${BOX_HOSTNAME_FQDN}.id_rsa.pub"

    echo ""

    echo "Changing permission of ${ISODIR_WRITE_TMP}/preseed.cfg to own by root:root ..."
    chown root:root ${ISODIR_WRITE_TMP}/preseed.cfg
    echo ""
    echo "Lower the files permission from ${ISODIR_WRITE_TMP}/install.amd to +w ..."
    chmod +w -R "${ISODIR_WRITE_TMP}/install.amd"
    echo ""
    echo "Unzipping initrd.gz"
    gunzip "${ISODIR_WRITE_TMP}/install.amd/initrd.gz"
    echo ""
    echo "Inserting preseed.cfg in initrd ..."
    echo ${ISODIR_WRITE_TMP}/preseed.cfg | cpio -H newc -o -A -F "${ISODIR_WRITE_TMP}/install.amd/initrd"
    echo ""
    ##exit 1
    echo "Zipping initrd as initrd.gz ..."
    gzip ${ISODIR_WRITE_TMP}/install.amd/initrd
    echo ""
    echo "Change the folder permission of ${ISODIR_WRITE_TMP}/install.amd/ to -w ..."
    chmod -w -R ${ISODIR_WRITE_TMP}/install.amd/
    echo ""

    echo "Fixing md5sum checksum ..."
    cd_to_path "${ISODIR_WRITE_TMP}"

    # Alternative method:
    #pushd ${ISODIR_WRITE}
    #  md5sum $(find -type f) > md5sum.txt
    #popd

    # A warning will be issued because ./debian is a symlink to . :
    # find: File system loop detected; ‘./debian’ is part of the same file system loop as ‘.’ :
    chmod +w md5sum.txt
    find -follow -type f ! -name md5sum.txt -print0 | xargs -0 md5sum >md5sum.txt
    chmod -w md5sum.txt
    echo ""

    echo "Creating standalone ISO installation inside ${ISODIR_WRITE}/${ISOFILE_FINAL} ..."
    xorriso -as mkisofs \
      -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin \
      -c isolinux/boot.cat \
      -b isolinux/isolinux.bin \
      -no-emul-boot \
      -boot-load-size 4 \
      -boot-info-table \
      -eltorito-alt-boot \
      -e boot/grub/efi.img \
      -no-emul-boot \
      -isohybrid-gpt-basdat \
      -o ${ISODIR_WRITE}/${DEBIAN_NAME}-${DEBIAN_RELEASE}-${DEBIAN_ISO_INSTALLATION_TYPE}.iso \
      ${ISODIR_WRITE_TMP}
    echo ""

    echo "Copying ${ISODIR_WRITE_TMP}/boot into ${ISODIR_WRITE} ..."
    cp -rp ${ISODIR_WRITE_TMP}/boot ${ISODIR_WRITE}
    echo ""
    echo "Creating new boot installation directory at ${ISODIR_WRITE}/boot/os ..."
    mkdir -p ${ISODIR_WRITE}/boot/os
    echo ""
    cd_to_path "${ISODIR_WRITE}/boot/os"
    echo "Downloading initrd.gz file into ${ISODIR_WRITE}/boot/os ..."
    wget -O initrd.gz ${INITRD_GZ_URL}
    echo ""
    echo "Downloading vmlinuz file into ${ISODIR_WRITE}/boot/os ..."
    wget -O vmlinuz ${VMLINUZ_URL}
    echo ""
    echo "Copying ${ISODIR_WRITE_TMP}/isolinux into ${ISODIR_WRITE} ..."
    cp -rp ${ISODIR_WRITE_TMP}/isolinux ${ISODIR_WRITE}
    echo ""

    echo "Backing up isolinux.cfg file at ${ISODIR_WRITE}/isolinux/isolinux.cfg ..."
    mv ${ISODIR_WRITE}/isolinux/isolinux.cfg ${ISODIR_WRITE}/isolinux/original_isolinux.cfg
    echo ""

    echo "Creating new menu for isolinux.cfg ..."
    {

      ## Reference: https://www.alteeve.com/an-repo/files/isolinux.cfg
      # Use high-color menu
      echo "UI vesamenu.c32"
      # Timeout unit is 1/10s, 100 means 10 seconds
      echo "TIMEOUT 100"
      echo "PROMPT 0"

      echo "DEFAULT Debian - Auto Installation"
      echo "# Console Prompt"
      echo "say **********************************************************************"
      echo "say Sofibox Cloud Sdn Bhd."
      echo "say TOSP, Cyberjaya Malaysia."
      echo "say sofibox.com, tosp.sofibox.com"
      echo "say OPERATING SYSTEM INSTALLER"
      echo "say Automatically booting: Debian - Auto Installation in 5 seconds ..."
      echo "say **********************************************************************"

      echo "# Allow client to edit the boot parameters"
      echo "ALLOWOPTIONS 1"

      # If don't set default would be 640x480
      #MENU RESOLUTION 1024 768

      # The background image
      #MENU BACKGROUND pxe_splash_1024_768.jpg

      echo "# Menu Title"
      echo "MENU TITLE Sofibox - Maxisetup Rescue Mode"

      echo "MENU AUTOBOOT Will boot the next device as configured in your BIOS in # second{,s}."
      echo "MENU TABMSG   Press the <tab> key to edit the boot parameters of the highlighted option."
      echo "MENU NOTABMSG Editing of this option is disabled."

      #Color
      echo "# Format is: MENU COLOR <Item> <ANSI Seq.> <foreground> <background> <shadow type>"
      echo "MENU COLOR screen      0  #80ffffff #00000000 std      # background colour not covered by the splash image"
      echo "MENU COLOR border      0  #ffffffff #ee000000 std      # The wire-frame border"
      echo "MENU COLOR title       0  #ffff3f7f #ee000000 std      # Menu title text"
      echo "MENU COLOR sel         0  #ff00dfdf #ee000000 std      # Selected menu option"
      echo "MENU COLOR hotsel      0  #ff7f7fff #ee000000 std      # The selected hotkey (set with ^ in MENU LABEL)"
      echo "MENU COLOR unsel       0  #ffffffff #ee000000 std      # Unselected menu options"
      echo "MENU COLOR hotkey      0  #ff7f7fff #ee000000 std      # Unselected hotkeys (set with ^ in MENU LABEL)"
      echo "MENU COLOR tabmsg      0  #c07f7fff #00000000 std      # Tab text"
      echo "MENU COLOR timeout_msg 0  #8000dfdf #00000000 std      # Timout text"
      echo "MENU COLOR timeout     0  #c0ff3f7f #00000000 std      # Timout counter"
      echo "MENU COLOR disabled    0  #807f7f7f #ee000000 std      # Disabled menu options, including SEPARATORs"
      echo "MENU COLOR cmdmark     0  #c000ffff #ee000000 std      # Command line marker - The '> ' on the left when editing an option"
      echo "MENU COLOR cmdline     0  #c0ffffff #ee000000 std      # Command line - The text being edited"
      echo "# Options below haven't been tested, descriptions may be lacking."
      echo "MENU COLOR scrollbar   0  #40000000 #00000000 std      # Scroll bar"
      echo "MENU COLOR pwdborder   0  #80ffffff #20ffffff std      # Password box wire-frame border"
      echo "MENU COLOR pwdheader   0  #80ff8080 #20ffffff std      # Password box header"
      echo "MENU COLOR pwdentry    0  #80ffffff #20ffffff std      # Password entry field"
      echo "MENU COLOR help        0  #c0ffffff #00000000 std      # Help text, if set via 'TEXT HELP ... ENDTEXT'"

      echo "LABEL Debian - Auto Installation"
      echo "    MENU LABEL ^1) Auto install Debian"
      echo "    MENU DEFAULT"
      echo "    KERNEL /boot/os/vmlinuz"
      #echo "important, preseed file location need to be cdrom"
      echo "    APPEND initrd=/boot/os/initrd.gz preseed/file=/cdrom/preseed.cfg locale=${BOX_LOCALE} keymap=${BOX_KEYBOARD} language=${BOX_LANGUAGE_CODE} country=${BOX_COUNTRY_CODE} --"
      echo "    TEXT HELP"
      echo "    * This is an auto installation"
      echo "    * WARNING: ALL DATA ON DISKS WILL BE OVERWRITTEN WITHOUT ANY QUESTIONS"
      echo "    ENDTEXT"
      echo "LABEL Debian - Manual installation"
      echo "   MENU LABEL ^2) Manual Debian Installation"
      echo "   KERNEL  /boot/os/vmlinuz"
      echo "   APPEND initrd=/boot/os/initrd.gz --"
      echo "    TEXT HELP"
      echo "    * This is a manual installation"
      echo "    * NOTE: USE THIS MENU IF YOU WANT TO INSTALL DEBIAN INTERACTIVELY"
      echo "    ENDTEXT"
      # TODO: This menu is beta
      echo "LABEL Debian - System Backup"
      echo "MENU LABEL ^3) Debian Full System Backup"
      echo "   KERNEL  /boot/os/vmlinuz"
      echo "   APPEND initrd=/boot/os/initrd.gz --"
      echo "    TEXT HELP"
      echo "    * This is an operating system full backup mode"
      echo "    * NOTE: USE THIS MENU IF YOU WANT TO MAKE FULL BACKUP (TESTING)"
      echo "    ENDTEXT"

    } >${ISODIR_WRITE}/isolinux/isolinux.cfg

    echo "Fixing md5sum checksum in ${ISODIR_WRITE_TMP} ..."
    cp -p ${ISODIR_WRITE_TMP}/md5sum.txt ${ISODIR_WRITE}
    rm -rf "${ISODIR_WRITE_TMP}"
    cd_to_path "${ISODIR_WRITE}"

    chmod +w md5sum.txt
    find -follow -type f ! -name md5sum.txt -print0 | xargs -0 md5sum >md5sum.txt
    chmod -w md5sum.txt
    echo ""

    echo "Creating the final ISO file ..."
    xorriso -as mkisofs \
      -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin \
      -c isolinux/boot.cat \
      -b isolinux/isolinux.bin \
      -no-emul-boot \
      -boot-load-size 4 \
      -boot-info-table \
      -eltorito-alt-boot \
      -e boot/grub/efi.img \
      -no-emul-boot \
      -isohybrid-gpt-basdat \
      -o ${ISOFILE_FINAL} \
      ${ISODIR_WRITE}
    echo ""
    # Copying to shared folder
    echo "Creating copy of installation disk at ${ISO_OUTPUT_PATH} ..."
    cp "${ISOFILE_FINAL}" "${ISO_OUTPUT_PATH}"

    # Uploading to dropbox
    echo "Uploading ${ISOFILE_FINAL} into dropbox /files/${ISOFILE_FINAL_BASE_NAME} ..."
    ${dbx_cli} upload "${ISOFILE_FINAL}" "/files"

    echo "Creating download link ..."
    file_direct_link=$(${dbx_cli} share "/files/${ISOFILE_FINAL_BASE_NAME}" | awk '{ print $4}' | sed 's/0$/1/g')
    echo "File direct link is: ${file_direct_link}"
    echo ""
    echo "Creating rescue disk script ..."
    _echo 'red' "=================================="
    echo ""
    echo "wget -O mini.iso \"${file_direct_link}\"" >"$(dirname "${iso_output_path}")/install.txt"
    echo "dd if=mini.iso of=/dev/sda" >>"$(dirname "${ISO_OUTPUT_PATH}")/install.txt"
    _echo 'green' "wget -O mini.iso \"${file_direct_link}\""
    _echo 'green' "dd if=mini.iso of=/dev/sda"
    _echo 'green' "mkdir /mnt/iso"
    _echo 'green' "mount mini.iso /mnt/iso"
    _echo 'green' "echo \"\""
    echo ""
    _echo 'red' "=================================="
    echo ""

    echo "Copying script into linode script ${SCRIPT_PATH}/linode... "
    {
      echo "#!/bin/bash"
      echo "wget -O mini.iso ${file_direct_link}"
      echo "dd if=mini.iso of=/dev/sda"
      # Need this option to reboot when reboot check
      echo "reboot -f"
      echo "exit 0"
    } >"${SCRIPT_PATH}/linode/os_write.sh"

    echo ""
    echo "Removing working directory ..."
    rm -rf "${ISODIR_WRITE}"
    echo ""
    echo "Removing preseed file ..."
    rm -rf "${PRESEED_FILE}"

    # My custom method
  elif [[ "${method}" == "--custom" ]]; then
    :
  else
    ################ ALTERNATIVE METHOD ####################################
    echo "Building a custom ${iso_os} image file for server setup in alternative mode ..."
    # Check required component:
    install_required "debconf" "isolinux" "syslinux-utils" "xorriso" "wget"
    echo ""
    if [[ "${option}" == "--update-iso" || -z "${option}" ]]; then
      # wget --timestamping - no need
      if [ -f ${ISOFILE} ]; then
        rm -rf "${ISOFILE}"
        echo "Re-downloading system image ..."
      else
        echo "Downloading new system image ..."
      fi

      wget -nc -O ${ISOFILE} ${ISO_URL} || true
    elif [[ "${option}" == "--no-update-iso" ]]; then
      if [ -f ${ISOFILE} ]; then
        echo "Using the existing ISO file ..."
      else
        echo "Warning, existing ISO file is missing! Use --update-iso option to download new file"
        _exit 1
      fi
      # Do nothing
    else
      echo "Invalid option supplied: ${option}"
      echo "${SCRIPT_NAME} ${action} --update-iso , to download the new ISO file where --update-iso is a default command if not specified"
      echo "${SCRIPT_NAME} ${action} --no-update-iso , to use existing ISO file"
      _exit 1
    fi
    echo ""
    echo "Writing new preseed file config ..."
    # Writing new preseed.cfg
    create_file "debian-preseed" ${PRESEED_FILE}

    echo "Checking preseed syntax file ${PRESEED_FILE} ..."
    if ! debconf-set-selections -c "${PRESEED_FILE}"; then
      echo "There is an error in the preseed.cfg. Check the syntax of the preconfiguration file."
      _exit 1
    else
      echo "The preseed file ${PRESEED_FILE} syntax is ok"
    fi

    echo "Copying ISOFILE content into writeable directory ${ISODIR_WRITE} ..."
    xorriso -osirrox on -indev ${ISOFILE} -extract / ${ISODIR_WRITE}/

    echo "Lowering the permission of install.amd ..."
    chmod +w -R ${ISODIR_WRITE}/install.amd/
    echo "Uncompress the initrd gzip ..."
    gunzip ${ISODIR_WRITE}/install.amd/initrd.gz
    echo "Copying the preseed file into the initrd archive ..."
    echo "${PRESEED_FILE}" | cpio -H newc -o -A -F ${ISODIR_WRITE}/install.amd/initrd
    echo ""

    echo "Creating new sources.list file ..."
    {
      echo "# The main Debian repository with contrib and non-free."
      echo "deb http://deb.debian.org/debian/ buster main contrib non-free"
      echo "# The security updates repository with contrib and non-free."
      echo "deb http://security.debian.org/debian-security buster/updates main contrib non-free"
      echo "# The buster-updates repository previously known as volatile."
      echo "deb http://deb.debian.org/debian/ buster-updates main contrib non-free"
    } >${SOURCE_FILE}

    echo "Copying the sources.list file into the initrd archive ..."
    echo "${SOURCE_FILE}" | cpio -H newc -o -A -F ${ISODIR_WRITE}/install.amd/initrd

    echo "Compressing the initrd using gzip ..."
    gzip ${ISODIR_WRITE}/install.amd/initrd
    echo ""
    echo "Raising the permission of install.amd ..."
    chmod -w -R ${ISODIR_WRITE}/install.amd/

    echo "Backing up grub.cfg file ..."
    mv ${ISODIR_WRITE}/boot/grub/grub.cfg ${ISODIR_WRITE}/boot/grub/original_grub.cfg
    echo "Writing new grub.cfg content .."
    cd_to_path "${ISODIR_WRITE}"
    {
      echo "if loadfont \$prefix/font.pf2 ; then"
      echo "  set gfxmode=800x600"
      echo "  set gfxpayload=keep"
      echo "  insmod efi_gop"
      echo "  insmod efi_uga"
      echo "  insmod video_bochs"
      echo "  insmod video_cirrus"
      echo "  insmod gfxterm"
      echo "  insmod png"
      echo "  terminal_output gfxterm"
      echo "fi"
      echo "if background_image /isolinux/splash.png; then"
      echo "  set color_normal=light-gray/black"
      echo "  set color_highlight=white/black"
      echo "elif background_image /splash.png; then"
      echo "  set color_normal=light-gray/black"
      echo "  set color_highlight=white/black"
      echo "else"
      echo "  set menu_color_normal=cyan/blue"
      echo "  set menu_color_highlight=white/blue"
      echo "fi"
      echo "default=\"0\""
      echo "timeout=5"
      echo "echo \"\""
      echo "echo \"The install starting automatically in 5 seconds, hit 'c' or 'e' to abort.\""
      echo "echo \"\""
      echo "insmod play"
      echo "play 2000 400 4 0 1 500 4 0 1 600 4 0 1 800 6"
      echo "menuentry --hotkey=a 'Start automated install...' {"
      echo "    set background_color=black"
      echo "    linux    /install.amd/vmlinuz auto=true priority=critical vga=788 --- quiet"
      echo "    initrd   /install.amd/initrd.gz"
      echo "}"
    } >boot/grub/grub.cfg

    echo "Generating checksums for each file using relative paths ..."
    pushd ${ISODIR_WRITE}/ || exit
    chmod +w md5sum.txt
    md5sum $(find -follow -type f) >md5sum.txt
    popd || exit

    #OUTPUT_FILE=${ISOFILE_FINAL}
    #YEAR_MONTH_DAY=$(date "+%Y-%m-%d")

    echo "Creating ISO ..."
    xorriso -as mkisofs \
      -r -V "preseed-iso-${YEAR_MONTH_DAY}" \
      -o ${ISOFILE_FINAL} \
      -cache-inodes \
      -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin \
      -b isolinux/isolinux.bin \
      -c isolinux/boot.cat \
      -boot-load-size 4 -boot-info-table -no-emul-boot \
      -eltorito-alt-boot \
      -e boot/grub/efi.img \
      -no-emul-boot -isohybrid-gpt-basdat -isohybrid-apm-hfsplus \
      ${ISODIR_WRITE}

    echo "Creating a checksum of the final file for transport ..."
    md5sum ${ISOFILE_FINAL} >${ISOFILE_FINAL}.md5

    echo "Copying final ${ISOFILE_FINAL} ISO into project path ${ISO_OUTPUT_PATH} ..."
    cp "${ISOFILE_FINAL}" "${ISO_OUTPUT_PATH}"

    echo "Removing the working directory ..."
    rm -rf ${ISODIR_WRITE}

  fi
}

# This function allows Directadmin to restart quickly but we don't take priority on other pending tasks.
# Better to restart DA with task.queue (this is what most documentation do) because DA needs to respect task.queue process
function restart_da() {
  echo "" 2>&1 | tee -a "${REPORT_FILE}"
  local wait_duration task_queue_file
  wait_duration=10
  # Directadmin recommends 60 seconds (or 1 minute). Longer than this something wrong with the task.queue
  max_wait=240
  task_queue_file="/usr/local/directadmin/data/task.queue"
  if [ -s ${task_queue_file} ]; then
    echo "[${SCRIPT_NAME}]: Warning, Directadmin task.queue still has pending task(s) to be executed with the following contents:" 2>&1 | tee -a "${REPORT_FILE}"
    echo ""
    echo "--"
    cat "${task_queue_file}"
    echo "--"
    echo "Waiting ${wait_duration} seconds to finish the pending task(s) ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep ${wait_duration}
    ((HOLD_SECONDS = HOLD_SECONDS + wait_duration))
    echo "Total sleep time in second: ${HOLD_SECONDS}"
    if [ "${HOLD_SECONDS}" -gt ${max_wait} ]; then
      # Force restart if waiting time is longer than 1 minute because task.queue maximum execution time is only 1 minute based on DA documentation
      # https://docs.directadmin.com/directadmin/general-usage/task-queue-processor/
      echo "[${SCRIPT_NAME}]: Warning, task.queue has not finished executing task(s) for more than ${max_wait} seconds. Forcing restart ..."
      echo "[${SCRIPT_NAME}]: Restarting Directadmin ..." 2>&1 | tee -a "${REPORT_FILE}"
      echo "action=directadmin&value=restart" >>/usr/local/directadmin/data/task.queue
      /usr/local/directadmin/dataskq d2000
    else
      # recursive function call again to recheck the task.queue content until condition satisfied and Directadmin will restart in clean mode
      restart_da
    fi
  else
    echo "[${SCRIPT_NAME}]: Restarting Directadmin ..." 2>&1 | tee -a "${REPORT_FILE}"
    # Writing restart query in task.queue
    echo "action=directadmin&value=restart" >>/usr/local/directadmin/data/task.queue
    # Force restart with debugging level d2000
    # this is optional because we knew no other pending tasks will be running at this condition
    /usr/local/directadmin/dataskq d2000
  fi
  echo "" 2>&1 | tee -a "${REPORT_FILE}"
}
# This is a linode API function used to manage linode DNS record
function linode_api_admin() {
  #echo "Continuing in 2 seconds ..."
  #sleep 2
  local retval
  install_required "bind9-host"
  if ! command -v linode-cli &>/dev/null; then
    echo "[${SCRIPT_NAME}]: Warning, missing linode-cli component. This utility requires linode-cli to be installed."
    if ! command -v pip3 &>/dev/null; then
      echo "[${SCRIPT_NAME}]: Installing python3-pip ..." 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      apt-get -y install python3-pip
    fi
    echo "[${SCRIPT_NAME}]: Installing linode-cli ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    pip3 install linode-cli --upgrade

    #apt-get -y install expect
    # Configuring the linode-cli using expect at the background
    #LINODE_CLI=$(expect -c "
    #          set timeout 3
    #          spawn linode-cli
    #          expect \"Personal Access Token:\"
    #          send \"${DNS_PROVIDER_API_KEY}\r\"
    #          expect \"Default Region (Optional):\"
    #          send \"\r\"
    #          expect \"Default Type of Linode (Optional):\"
    #          send \"\r\"
    #          expect \"Default Image (Optional):\"
    #          send \"\r\"
    #          expect eof
    #          ")
    # Display the result of expect configuration for linode-cli
    #echo "Result: "
    #echo "${LINODE_CLI}"
    # Remove expect we don't need it
    #apt-get -y remove expect

  fi

  if [ ! -s /root/.config/linode-cli ]; then
    echo "[${SCRIPT_NAME}]: Configuring linode-cli API key ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    mkdir -p /root/.config
    touch /root/.config/linode-cli
    {
      echo "[DEFAULT]"
      echo "default-user = ${DNS_PROVIDER_USER}"
      echo "[${DNS_PROVIDER_USER}]"
      echo "token = ${DNS_PROVIDER_API_KEY}"
    } >/root/.config/linode-cli
  fi
  # Make sure jq is installed
  if ! command -v jq &>/dev/null; then
    echo "[${SCRIPT_NAME}]: Warning, missing jq component. This utility requires jq to be installed." 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Installing jq ..." 2>&1 | tee -a "${REPORT_FILE}"
    apt-get -y install jq

  fi

  # Do another check for the second time
  if command -v linode-cli &>/dev/null; then
    LINODE_CLI_BIN=$(command -v linode-cli)
  else
    echo "[${SCRIPT_NAME}]: Warning, unable to find linode-cli binary. Please inspect why" 2>&1 | tee -a "${REPORT_FILE}"
    _exit 1
  fi
  # Do another check for the second time
  if command -v jq &>/dev/null; then
    JQ_BIN=$(command -v jq)
  else
    echo "[${SCRIPT_NAME}]: Warning, unable to find jq binary. Please inspect why" 2>&1 | tee -a "${REPORT_FILE}"
    _exit 1
  fi
  local action
  #shift
  action="$1"
  linode_max_page=2
  #linode_api_admin "get-domain-id" "maxibi.com"
  if [[ "${action}" == "get-domain-id" ]]; then
    shift
    local domain_id domain
    domain="$1"
    dis_args="${*:2}"
    if [[ -n "${dis_args}" ]]; then
      echo "[${SCRIPT_NAME}]: Warning, extra arguments discarded: ${dis_args}" 2>&1 | tee -a "${REPORT_FILE}"
    fi
    if [ $# -ge 1 ]; then
      domain_id=$(${LINODE_CLI_BIN} domains list --json --pretty | ${JQ_BIN} ".[] | select(.domain == \"${domain}\") | .id")
      # Traditional way without jq:
      #domain_id=$(${LINODE_CLI_BIN} domains list --domain "${domain}" --pretty --json | grep -F '"id":' | sed -r 's/[^0-9]//g')
      if [ -n "${domain_id}" ]; then
        # Here is the real result for domain ID:
        echo "${domain_id}"
      else
        echo "[${SCRIPT_NAME}]: Error, no ID found for domain ${domain}" 2>&1 | tee -a "${REPORT_FILE}"
        return 1
      fi
    else
      echo "[${SCRIPT_NAME}]: Error, usage: linode_api_admin ${action} <domain_name>" 2>&1 | tee -a "${REPORT_FILE}"
      return 2
    fi
  #linode_api_admin "create-domain" "master" "maxibi.com" "webmaster@sofibox.com"
  elif [[ ${action} == "create-domain" ]]; then
    shift
    local type domain email
    type="$1"
    domain="$2"
    email="$3"
    ${LINODE_CLI_BIN} domains create --type "${type}" --domain "${domain}" --soa_email "${email}" --json --pretty
  #linode_api_admin "add-dns-record" "maxibi.com" "TXT" "x._domainkey" "*i..2uiu1KJM@#9IU@J()!@IJI92" "5"
  # For mx record, linode_api_admin "add-dns-record" "maxibi.com" "MX" "mail" "sofibox.com." "5"
  elif [[ "${action}" == "add-dns-record" ]]; then
    shift
    local domain name ttl type value domain_id dis_args retval add_dns_record
    domain="$1"
    type="$2"
    name="$3"
    value="$4"
    # Linode ttl_sec is not replaced in API but it's working (bug?)
    ttl="$5"
    dis_args="${*:6}"

    if [[ -n "${dis_args}" ]]; then
      echo "[${SCRIPT_NAME}]: Warning, extra arguments discarded: ${dis_args}" 2>&1 | tee -a "${REPORT_FILE}"
    fi
    if [ $# -ge 5 ]; then
      echo "[${SCRIPT_NAME}]: Checking domain ID for domain ${domain} ..." 2>&1 | tee -a "${REPORT_FILE}"
      # domain_id=$(${LINODE_CLI_BIN} domains list --domain "${domain}" --pretty --json | grep -F '"id":' | sed -r 's/[^0-9]//g')
      domain_id=$(${LINODE_CLI_BIN} domains list --json --pretty | ${JQ_BIN} ".[] | select(.domain == \"${domain}\") | .id")
      if [ -n "${domain_id}" ]; then
        # Here is the real result for domain ID:
        # echo "${domain_id}"
        echo "[${SCRIPT_NAME}]: Adding new DNS record name ${name} in linode ..." 2>&1 | tee -a "${REPORT_FILE}"
        # MX record got extra priority
        if [ "${type}" == "MX" ]; then
          # TODO make sure priority can be passed via argument (currently set to 10 by default for MX record)
          #linode-cli domains records-create ${sofibox_id} --type MX --name mail --target sofibox.com. --priority 10 --ttl_sec 1
          add_dns_record=$(${LINODE_CLI_BIN} domains records-create "${domain_id}" --pretty --json \
            --type "${type}" --name "${name}" --target "${value}" --priority 10 --ttl_sec "${ttl}")
          retval=$?
        else
          add_dns_record=$(${LINODE_CLI_BIN} domains records-create "${domain_id}" --pretty --json \
            --type "${type}" --name "${name}" --target "${value}" --ttl_sec "${ttl}")
          retval=$?
        fi
        if [ ${retval} = 0 ]; then
          echo "=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"
          echo "Success, record has been successfully added into linode DNS management" 2>&1 | tee -a "${REPORT_FILE}"
        else
          echo "Error [${retval}], something is wrong when adding DNS record into linode DNS management" 2>&1 | tee -a "${REPORT_FILE}"
          _exit ${retval}
        fi

        echo "${add_dns_record}"
        echo "=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"
        return ${retval}

      else
        echo "[${SCRIPT_NAME}]: Error, no ID found for domain ${domain}" 2>&1 | tee -a "${REPORT_FILE}"
        return 1
      fi
    else
      echo "[${SCRIPT_NAME}]: Error, usage: linode_api_admin ${action} <domain_name> <record_type> <record_name> <record_value> <record_ttl>" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 2
    fi
    # linode_api_admin "get-linode-id" "<hostname_fqdn>"
  elif [[ "${action}" == "get-linode-id" ]]; then
    shift
    local linode_id hostname_fqdn
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    echo "[${SCRIPT_NAME}]: Getting linode ID for ${hostname_fqdn}..."
    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    #echo "${linode_id}"
  elif [[ "${action}" == "get-linode-status" ]]; then
    shift
    local linode_id linode_status hostname_fqdn
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    echo "[${SCRIPT_NAME}]: Getting linode status for ${hostname_fqdn} ..."
    linode_status=$(${LINODE_CLI_BIN} linodes view "${linode_id}" --json --pretty | ${JQ_BIN} -r ".[] | .status")
    echo "${linode_status}"

    #0=online
    #1=offline
    #3=other

    #if [ "${linode_status}" == "online" ]; then
    #  return 0
    #elif [ "${linode_status}"  == "offline" ]; then
    #  return 1
    #else
    #  return 3
    #fi
    # linode_api_admin "rescue-mode" <optional_hostname> <optional_mount_disk1_label> <optional_mount_disk2_label> <optional_mount_diskN_label> ... <optional_mount_disk9>"
  elif [[ "${action}" == "rescue-linode" || "${action}" == "rescue-reboot" || "${action}" == "rescue" || "${action}" == "reboot-rescue" || "${action}" == "rescue-mode" || "${action}" == "boot-rescue" || "${action}" == "boot-to-rescue" || "${action}" == "rescue-boot" ]]; then
    shift
    local linode_id hostname_fqdn linode_status config_disk_devsda config_disk_devsdb config_disk_devsdc \
      config_disk_devsdd config_disk_devsde config_disk_devsdf config_disk_devsdg config_disk_devsdh \
      disk_id config_disks wait_time
    local config_disk_devsda_id_option config_disk_devsdb_id_option config_disk_devsdc_id_option \
      config_disk_devsdd_id_option config_disk_devsde_id_option config_disk_devsdf_id_option \
      config_disk_devsdg_id_option config_disk_devsdh_id_option config_disks_id_options config_disks_label
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    config_disk_devsda="$1"
    config_disk_devsdb="$2"
    config_disk_devsdc="$3"
    config_disk_devsdd="$4"
    config_disk_devsde="$5"
    config_disk_devsdf="$6"
    config_disk_devsdg="$7"
    config_disk_devsdh="$8"
    config_disks=""
    wait_time=10
    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    # Convert the disk label to ID if not empty
    if [[ -n "${config_disk_devsda}" ]]; then
      config_disk_devsda_id=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_disk_devsda}\") | .id")
      if [ -z "${config_disk_devsda_id}" ]; then
        echo "[${SCRIPT_NAME}]: Warning, disk ${config_disk_devsda} not found. Please check if the disk is exist"
        _exit 1
      fi
      config_disk_devsda_id_option="--devices.sda.disk_id ${config_disk_devsda_id}"
      config_disks_id_options="${config_disks_id_options} ${config_disk_devsda_id_option}"
      config_disks_label="${config_disk_devsda}"
      # eg: Now config_disk_devsda is: --devices.sda.disk_id 123122
    fi

    # Convert the disk label to ID if not empty
    if [[ -n "${config_disk_devsdb}" ]]; then
      config_disk_devsdb_id=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_disk_devsdb}\") | .id")
      if [ -z "${config_disk_devsdb_id}" ]; then
        echo "[${SCRIPT_NAME}]: Warning, disk ${config_disk_devsdb} not found. Please check if the disk label is exist in linode disk"
        _exit 1
      fi
      config_disk_devsdb_id_option="--devices.sdb.disk_id ${config_disk_devsdb_id}"
      config_disks_id_options="${config_disks_id_options} ${config_disk_devsdb_id_option}"
      config_disks_label="${config_disks_label}, ${config_disk_devsdb}"
      # eg: Now config_disk_devsdb is: --devices.sdb.disk_id 123122
    fi
    # Convert the disk label to ID if not empty
    if [[ -n "${config_disk_devsdc}" ]]; then
      config_disk_devsdc_id=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_disk_devsdc}\") | .id")
      if [ -z "${config_disk_devsdc_id}" ]; then
        echo "[${SCRIPT_NAME}]: Warning, disk ${config_disk_devsdc} not found. Please check if the disk label is exist in linode disk"
        _exit 1
      fi
      config_disk_devsdc_id_option="--devices.sdc.disk_id ${config_disk_devsdc_id}"
      config_disks_id_options="${config_disks_id_options} ${config_disk_devsdc_id_option}"
      config_disks_label="${config_disks_label}, ${config_disk_devsdc}"
      # eg: Now config_disk_devsdc is: --devices.sdc.disk_id 123122
    fi
    # Convert the disk label to ID if not empty
    if [[ -n "${config_disk_devsdd}" ]]; then
      config_disk_devsdd_id=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_disk_devsdd}\") | .id")
      if [ -z "${config_disk_devsdd_id}" ]; then
        echo "[${SCRIPT_NAME}]: Warning, disk ${config_disk_devsdd} not found. Please check if the disk label is exist in linode disk"
        _exit 1
      fi
      config_disk_devsdd_id_option="--devices.sdd.disk_id ${config_disk_devsdd_id}"
      config_disks_id_options="${config_disks_id_options} ${config_disk_devsdd_id_option}"
      config_disks_label="${config_disks_label}, ${config_disk_devsdd}"
      # eg: Now config_disk_devsdd is: --devices.sdd.disk_id 123122
    fi
    # Convert the disk label to ID if not empty
    if [[ -n "${config_disk_devsde}" ]]; then
      config_disk_devsde_id=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_disk_devsde}\") | .id")
      if [ -z "${config_disk_devsde_id}" ]; then
        echo "[${SCRIPT_NAME}]: Warning, disk ${config_disk_devsde} not found. Please check if the disk label is exist in linode disk"
        _exit 1
      fi
      config_disk_devsde_id_option="--devices.sde.disk_id ${config_disk_devsde_id}"
      config_disks_id_options="${config_disks_id_options} ${config_disk_devsde_id_option}"
      config_disks_label="${config_disks_label}, ${config_disk_devsde}"
      # eg: Now config_disk_devsde is: --devices.sde.disk_id 123122
    fi
    # Convert the disk label to ID if not empty
    if [[ -n "${config_disk_devsdf}" ]]; then
      config_disk_devsdf_id=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_disk_devsdf}\") | .id")
      if [ -z "${config_disk_devsdf_id}" ]; then
        echo "[${SCRIPT_NAME}]: Warning, disk ${config_disk_devsdf} not found. Please check if the disk label is exist in linode disk"
        _exit 1
      fi
      config_disk_devsdf_id_option="--devices.sdf.disk_id ${config_disk_devsdf_id}"
      config_disks_id_options="${config_disks_id_options} ${config_disk_devsdf_id_option}"
      config_disks_label="${config_disks_label}, ${config_disk_devsdf}"
      # eg: Now config_disk_devsdf is: --devices.sdf.disk_id 123122
    fi
    # Convert the disk label to ID if not empty
    if [[ -n "${config_disk_devsdg}" ]]; then
      config_disk_devsdg_id=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_disk_devsdg}\") | .id")
      if [ -z "${config_disk_devsdg_id}" ]; then
        echo "[${SCRIPT_NAME}]: Warning, disk ${config_disk_devsdg} not found. Please check if the disk label is exist in linode disk"
        _exit 1
      fi
      config_disk_devsdg_id_option="--devices.sdg.disk_id ${config_disk_devsdg_id}"
      config_disks_id_options="${config_disks_id_options} ${config_disk_devsdg_id_option}"
      config_disks_label="${config_disks_label}, ${config_disk_devsdg}"
      # eg: Now config_disk_devsdg is: --devices.sdg.disk_id 123122
    fi
    # Convert the disk label to ID if not empty
    if [[ -n "${config_disk_devsdh}" ]]; then
      config_disk_devsdh_id=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_disk_devsdh}\") | .id")
      if [ -z "${config_disk_devsdh_id}" ]; then
        echo "[${SCRIPT_NAME}]: Warning, disk ${config_disk_devsdh} not found. Please check if the disk label is exist in linode disk"
        _exit 1
      fi
      config_disk_devsdh_id_option="--devices.sdh.disk_id ${config_disk_devsdh_id}"
      config_disks_id_options="${config_disks_id_options} ${config_disk_devsdh_id_option}"
      config_disks_label="${config_disks_label}, ${config_disk_devsdh}"
      # eg: Now config_disk_devsdh is: --devices.sdh.disk_id 123122
    fi
    #config_disks_id_options="${config_disk_devsda_id_option} ${config_disk_devsdb_id_option} ${config_disk_devsdc_id_option} ${config_disk_devsdd_id_option} ${config_disk_devsde_id_option} ${config_disk_devsdf_id_option} ${config_disk_devsdg_id_option} ${config_disk_devsdh_id_option}"
    #config_disks_label="${config_disk_devsda} ${config_disk_devsdb} ${config_disk_devsdc} ${config_disk_devsdd} ${config_disk_devsde} ${config_disk_devsdf} ${config_disk_devsdg} ${config_disk_devsdh}"

    #echo "Config_value:pre_${config_disks}_post"

    if [[ -z "${config_disks_id_options}" ]]; then
      echo "[${SCRIPT_NAME}]: Config disk option is blank. Linode will boot into rescue mode without mounting any disks"
    else
      echo "[${SCRIPT_NAME}]: Notice, Linode will boot into rescue mode and mount the following disk(s) in order:"
      echo ""
      echo "Disk Label: ${config_disks_label}"
      echo "Disk ID: ${config_disks_id_options}"
      echo ""
    fi
    echo "[${SCRIPT_NAME}]: Putting linode ${hostname_fqdn} into rescue mode ..."
    ${LINODE_CLI_BIN} linodes rescue "${linode_id}" ${config_disks_id_options}
    echo "[${SCRIPT_NAME}]: Waiting for linode to finish booting into rescue mode ..."
    # sleep ${wait_time}
    while :; do
      linode_status=$(${LINODE_CLI_BIN} linodes view "${linode_id}" --json --pretty | ${JQ_BIN} -r ".[] | .status")
      if [[ "${linode_status}" == "running" ]]; then
        #echo "[${SCRIPT_NAME}]: Success, linode ${hostname_fqdn} has been successfully booted into rescue mode."
        spinner stop "[${SCRIPT_NAME}]: Success, linode ${hostname_fqdn} has been successfully booted into rescue mode."
        #echo "[${SCRIPT_NAME}]: Server status is: ${linode_status}"
        break
      else
        #echo "[${SCRIPT_NAME}]: Linode status is: ${linode_status}"
        #echo "[${SCRIPT_NAME}]: Allowing ${wait_time} seconds to finish booting into rescue mode"
        #sleep ${wait_time}
        spinner start "[${SCRIPT_NAME}]: Linode status is ${linode_status}. Waiting for running status ..."
      fi
    done
    # linode-api shutdown-linode
    # linode-api shutdown-linode <hostname_fqdn>
  elif [[ "${action}" == "shutdown-linode" || "${action}" == "poweroff-linode" || "${action}" == "turnoff-linode" || "${action}" == "shutdown" || "${action}" == "poweroff" || "${action}" == "turnoff" ]]; then
    shift
    local linode_id hostname_fqdn linode_status #shutdown_wait shutdown_wait_max shutdown_wait_total
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    #shutdown_wait=10
    #shutdown_wait_total=0
    #shutdown_wait_max=240
    echo "[${SCRIPT_NAME}]: Shutting down linode ${hostname_fqdn} ..."
    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    linode_status=$(${LINODE_CLI_BIN} linodes view "${linode_id}" --json --pretty | ${JQ_BIN} -r ".[] | .status")
    #echo "LINODE STATUS: ${linode_status}"
    if [[ "${linode_status}" == "offline" ]]; then
      echo "[${SCRIPT_NAME}]: Notice, linode ${hostname_fqdn} status is already offline!"
    else
      echo "[${SCRIPT_NAME}]: Notice, linode ${hostname_fqdn} status is ${linode_status}"
      #count_off=0
      echo "[${SCRIPT_NAME}]: Shutting down linode ${hostname_fqdn} ..."
      ${LINODE_CLI_BIN} linodes shutdown "${linode_id}"
      while :; do
        linode_status=$(${LINODE_CLI_BIN} linodes view "${linode_id}" --json --pretty | ${JQ_BIN} -r ".[] | .status")
        #if [ "${count_off}" -gt 0 ]; then
        #  echo "[${SCRIPT_NAME}]: Allowing another ${shutdown_wait} seconds to finish shutting down linode ${hostname_fqdn} ..."
        #else
        #  echo "[${SCRIPT_NAME}]: Allowing the first ${shutdown_wait} seconds to finish shutting down linode ${hostname_fqdn} ..."
        #fi
        #sleep "${shutdown_wait}"
        if [ "${linode_status}" == "running" ]; then
          echo "[${SCRIPT_NAME}]: Linode for ${hostname_fqdn} status is: running"
        elif [ "${linode_status}" == "offline" ]; then
          spinner stop "[${SCRIPT_NAME}]: Success, linode for ${hostname_fqdn} status is: offline"
          #echo "Total wait in second is: ${shutdown_wait_total}"
          #echo "Max wait in second is: ${shutdown_wait_max}"
          break
        elif [ "${linode_status}" == "shutting_down" ]; then
          #echo "[${SCRIPT_NAME}]: Linode for ${hostname_fqdn} status is: shutting_down"
          spinner start "[${SCRIPT_NAME}]: Linode for ${hostname_fqdn} status is: shutting_down"
        # Do more statement here based on linode_status string
        else
          # echo "[${SCRIPT_NAME}]: Warning, linode for ${hostname_fqdn} has unknown unidentified status: ${linode_status}"
          spinner start "[${SCRIPT_NAME}]: Warning, linode for ${hostname_fqdn} has unknown unidentified status: ${linode_status}"
          # Don't exit still give time
          #_exit 1
        fi
        # Sometimes linode is stuck at terminal when reboot, start or shutdown, so we need to display error for inspection here:
        #((shutdown_wait_total = shutdown_wait_total + shutdown_wait))
        #if [ "${shutdown_wait_total}" -gt ${shutdown_wait_max} ]; then
        #  echo "[${SCRIPT_NAME}]: Warning, something is wrong while trying to turn off linode for ${hostname_fqdn}. It took more than ${shutdown_wait_total} seconds. Please, inspect why!"
        #  echo "Total wait in second is: ${shutdown_wait_total}"
        #  echo "Max wait in second is: ${shutdown_wait_max}"
        #  _exit 1
        #fi
        #((count_off++))
      done
    fi
    # linode_api_admin "boot-linode" "sun.sofibox.com" "Boot_Config"
  elif [[ "${action}" == "start-linode" || "${action}" == "boot-linode" || "${action}" == "boot" || "${action}" == "start" ]]; then
    shift
    local linode_id hostname_fqdn config_label config_id wait_time
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    config_label="$1"
    #wait_time=10
    echo "[${SCRIPT_NAME}]: Booting linode ${hostname_fqdn} using config label ${config_label} ..."
    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    config_id=$(${LINODE_CLI_BIN} linodes configs-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_label}\") | .id")
    if [ -z "${config_id}" ]; then
      echo "[${SCRIPT_NAME}]: Warning, no config ${config_label} is found!"
      return 1
    fi
    linode_status=$(${LINODE_CLI_BIN} linodes view "${linode_id}" --json --pretty | ${JQ_BIN} -r ".[] | .status")
    ${LINODE_CLI_BIN} linodes shutdown "${linode_id}"

    echo "[${SCRIPT_NAME}]: Booting linode ${hostname_fqdn} ..."
    ${LINODE_CLI_BIN} linodes boot "${linode_id}" --config_id "${config_id}"
    echo "[${SCRIPT_NAME}]: Waiting linode to finish booting using config ${config_label} ..."
    #sleep ${wait_time}
    while :; do
      linode_status=$(${LINODE_CLI_BIN} linodes view "${linode_id}" --json --pretty | ${JQ_BIN} -r ".[] | .status")
      if [[ "${linode_status}" == "running" ]]; then
        #echo "[${SCRIPT_NAME}]: Success, linode ${hostname_fqdn} has been successfully booted using config ${config_label}."
        #echo "[${SCRIPT_NAME}]: Server status is: ${linode_status}"
        spinner stop "[${SCRIPT_NAME}]: Success, linode ${hostname_fqdn} has been successfully booted using config ${config_label}"
        break
        # elif [[ "${linode_status}" == "offline" ]]; then
        #   ${LINODE_CLI_BIN} linodes boot "${linode_id}" --config_id "${config_id}"
      else
        #echo "[${SCRIPT_NAME}]: Linode status is: ${linode_status}"
        #echo "[${SCRIPT_NAME}]: Allowing ${wait_time} seconds to finish booting using config ${config_label}"
        #sleep ${wait_time}
        spinner start "[${SCRIPT_NAME}]: Linode status is ${linode_status}. Waiting for running status ..."

      fi
    done
  elif [[ "${action}" == "restart-linode" || "${action}" == "reboot-linode" || "${action}" == "restart" || "${action}" == "reboot" ]]; then
    shift
    local linode_id hostname_fqdn wait_time
    hostname_fqdn="$1"
    #wait_time=10
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    echo "[${SCRIPT_NAME}]: Rebooting linode ${hostname_fqdn} ..."
    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    ${LINODE_CLI_BIN} linodes reboot "${linode_id}"

    echo "[${SCRIPT_NAME}]: Waiting linode to finish rebooting using config ${config_label} ..."
    #sleep ${wait_time}
    while :; do
      linode_status=$(${LINODE_CLI_BIN} linodes view "${linode_id}" --json --pretty | ${JQ_BIN} -r ".[] | .status")
      if [[ "${linode_status}" == "running" ]]; then
        #echo "[${SCRIPT_NAME}]: Success, linode ${hostname_fqdn} has been successfully rebooted"
        #echo "[${SCRIPT_NAME}]: Server status is: ${linode_status}"
        spinner stop "[${SCRIPT_NAME}]: Success, linode ${hostname_fqdn} has been successfully rebooted"

        break
      else
        #echo "[${SCRIPT_NAME}]: Linode status is: ${linode_status}"
        #echo "[${SCRIPT_NAME}]: Allowing ${wait_time} seconds to finish rebooting"
        #sleep ${wait_time}
        spinner start "[${SCRIPT_NAME}]: Linode status is ${linode_status}. Waiting for running status ..."
      fi
    done

  # linode-api view-linode
  # linode-api view-linode <hostname_fqdn>
  elif [[ "${action}" == "view-linode" || "${action}" == "lookup-linode" ]]; then
    shift
    local linode_id hostname_fqdn
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    echo "[${SCRIPT_NAME}]: Viewing linode ${hostname_fqdn} ..."
    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    ${LINODE_CLI_BIN} linodes view "${linode_id}"
    echo "Status: $?"
    # --linode-api get-disk-id "sun.sofibox.com" "Boot_Disk"
  elif [[ "${action}" == "get-disk-id" ]]; then
    shift
    local linode_id hostname_fqdn disk_label disk_id
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    disk_label="$1"
    echo "[${SCRIPT_NAME}]: listing config ${hostname_fqdn} ..."
    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    disk_id=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${disk_label}\") | .id")
    echo "${disk_id}"
  elif [[ "${action}" == "list-disks" || "${action}" == "lookup-disks" ]]; then
    shift
    local linode_id hostname_fqdn
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    echo "[${SCRIPT_NAME}]: listing config ${hostname_fqdn} ..."
    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    ${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty
    echo $?
    # linode_api_admin "delete-disk" <hostname_fqdn> <disk_label>
  elif [[ "${action}" == "delete-disk" || "${action}" == "remove-disk" ]]; then
    # Make sure to shutdown linode first
    shift
    local linode_id disk_ids hostname_fqdn disk_status disk_ids_count disk_count linode_status
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift

    disk_label="$1"
    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    linode_status=$(${LINODE_CLI_BIN} linodes view "${linode_id}" --json --pretty | ${JQ_BIN} -r ".[] | .status")
    #echo "LINODE STATUS: ${linode_status}"
    if [[ "${linode_status}" == "offline" ]]; then
      echo "[${SCRIPT_NAME}]: Deleting disk ${disk_label} created from linode ${hostname_fqdn} ..."
      linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
      disk_id=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${disk_label}\") | .id")
      if [ -n "${disk_id}" ]; then
        echo "[${SCRIPT_NAME}]: Deleting disk ${disk_label} with ID ${disk_id} from ${hostname_fqdn} (this may take some time) ..."
        #echo ""
        ${LINODE_CLI_BIN} linodes disk-delete "${linode_id}" "${disk_id}"
        #sleep 1 # Pause 1 second
      else
        echo "[${SCRIPT_NAME}]: Warning, no disk label ${disk_label} is found!"
        # Return 1 and end this function to caller
        return 1
      fi
      # Deleting disks take time, wait for new status
      #  Lowering this deleting_wait value will cause API rate limit (when checking disk status) but it's fast
      #deleting_wait=1
      while :; do
        disk_status=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} -r ".[] | select(.id == ${disk_id}) | .status")
        if [[ -z "${disk_status}" ]]; then
          # If disk_status is empty meaning that it has been deleted!
          # stop spinner and replace with success message
          spinner stop "[${SCRIPT_NAME}]: Success, the linode disk ID ${disk_id} has been deleted!"
          break
        elif [[ ${disk_status} == "deleting" ]]; then
          # Show spinner
          spinner start "[${SCRIPT_NAME}]: Deleting ..."
          # Below code has wait time that is good if API is limited:
          #echo "[${SCRIPT_NAME}]: Linode Disk ID ${disk_id} status is: ${disk_status}"
          #echo "[${SCRIPT_NAME}]: Allowing ${deleting_wait} seconds to finish deleting disk ID ${disk_id} for ${BOX_HOSTNAME_FQDN} ..."
          #sleep "${deleting_wait}"
        else
          echo "[${SCRIPT_NAME}]: Warning, unknown disk status: ${disk_status}"
          _exit 1
        fi
      done

    else
      echo "[${SCRIPT_NAME}]: Error, linode ${hostname_fqdn} must be offline first to delete disk but its current status is ${linode_status}"
      _exit 1
    fi

    # linode_api_admin "delete-disks" <hostname_fqdn> # Plural disks remove all
  elif [[ "${action}" == "delete-disks" || "${action}" == "remove-disks" ]]; then
    # Make sure to shutdown linode first
    shift
    echo "[${SCRIPT_NAME}]: Deleting all the disks created for linode ${hostname_fqdn} ..."
    local linode_id disk_ids hostname_fqdn disk_status disk_ids_count disk_count
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    disk_ids=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | .id")
    disk_ids_count=$(echo "${disk_ids}" | wc -w)
    echo "[${SCRIPT_NAME}]: Total disk found is ${disk_ids_count}."
    disk_count=0
    for disk_id in ${disk_ids}; do
      ((disk_count++))
      echo "[${SCRIPT_NAME}]: Deleting disk ${disk_count} out of ${disk_ids_count} with ID ${disk_id} ..."
      ${LINODE_CLI_BIN} linodes disk-delete "${linode_id}" "${disk_id}"
      # Deleting disks take time, wait at least 10 seconds
      #deleting_wait=10
      while :; do
        disk_status=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} -r ".[] | select(.id == ${disk_id}) | .status")
        if [[ -z "${disk_status}" ]]; then
          # If disk_status is empty meaning that it has been deleted!
          spinner stop "[${SCRIPT_NAME}]: Success, the linode disk ID ${disk_id} has been deleted!"
          #echo "[${SCRIPT_NAME}]: Success, the linode disk ID ${disk_id} has been deleted!"
          break
        elif [[ ${disk_status} == "deleting" ]]; then
          spinner start "[${SCRIPT_NAME}]: Deleting ..."
          #echo "[${SCRIPT_NAME}]: Linode Disk ID ${disk_id} status is: ${disk_status}"
          #echo "[${SCRIPT_NAME}]: Allowing ${deleting_wait} seconds to finish deleting disk ID ${disk_id} for ${BOX_HOSTNAME_FQDN} ..."
          #sleep "${deleting_wait}"
        else
          echo "Other status: ${disk_status}"
          _exit 1
        fi
      done
    done
    # --linode-api check-disk-status sun.sofibox.com <disk_label>
  elif [[ "${action}" == "check-disk-status" || "${action}" == "disk-status" ]]; then
    shift
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    disk_label="$1"
    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    echo "[${SCRIPT_NAME}]: Checking disk status ${disk_label} from ${hostname_fqdn} ..."
    rescue_disk_status=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} -r ".[] | select(.label == \"${disk_label}\") | .status" | tail -n 1)
    if [ "${rescue_disk_status}" == "ready" ]; then
      #echo "[${SCRIPT_NAME}]: Rescue Disk status is now ready"
      return 0
    else
      #echo "[${SCRIPT_NAME}]: Disk status is not ready"
      return 1
    fi
    # --linode-api create-disk sun.sofibox.com <disk_label> <disk_filetype> <disk_size_in_MB>
  elif [[ "${action}" == "create-disk" || "${action}" == "add-disk" ]]; then
    echo ""
    echo "[${SCRIPT_NAME}]: Creating new disk ..."
    # Make sure to shutdown linode first
    shift
    local linode_id hostname_fqdn disk_label disk_filetype disk_size disk_label_created
    #wait_second wait_second_max wait_second_total
    hostname_fqdn="$1"
    #echo "Hostname from argument is ${hostname_fqdn}"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    echo ""
    disk_label="$1"
    echo "Disk label: ${disk_label}"
    disk_filetype="$2"
    echo "Disk file type: ${disk_filetype}"
    disk_size="$3"
    echo "Disk size: ${disk_size}"
    echo ""
    #wait_second=10
    #wait_second_max=240
    #wait_second_total=0

    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    echo "[${SCRIPT_NAME}]: Creating new disk for ${hostname_fqdn} ..."

    disk_label_created=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} -r ".[] | select(.label == \"${disk_label}\") | .label" | tail -n 1)

    # Do not create duplicated label
    if [ -z "${disk_label_created}" ]; then
      echo "[${SCRIPT_NAME}]: Notice, no disk label ${disk_label} exist in linode"
    fi

    if [[ ${disk_label_created} == "${disk_label}" ]]; then
      echo "[${SCRIPT_NAME}]: Warning, there is already a disk label called ${disk_label_created}. Nothing to create"
    else
      echo "[${SCRIPT_NAME}]: Creating a new disk with label ${disk_label} ..."
      # This is first attempt
      ${LINODE_CLI_BIN} linodes disk-create "${linode_id}" --label "${disk_label}" --filesystem "${disk_filetype}" --size "${disk_size}"
      echo "[${SCRIPT_NAME}]: Checking disk status ... (this may take some time)"
      #sleep ${wait_second}
      while :; do
        disk_status=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} -r ".[] | select(.label == \"${disk_label}\") | .status" | tail -n 1)
        if [ "${disk_status}" == "ready" ]; then

          spinner stop "[${SCRIPT_NAME}]: Disk status is now ready"
          break
        elif [ "${disk_status}" == "not ready" ]; then
          #echo "[${SCRIPT_NAME}]: Disk status is not ready yet. Allowing ${wait_second} seconds to finish creating"
          spinner start "[${SCRIPT_NAME}]: Disk status is not ready. Waiting for disk status to be ready ..."
          #sleep ${wait_second}
        else
          #echo "[${SCRIPT_NAME}]: Warning, unknown/empty disk status (not in condition): ${disk_status}"
          spinner start "[${SCRIPT_NAME}]: Warning, unknown/empty disk status (not in condition): [${disk_status}]. Waiting for disk status to be ready ..."
          #echo "[${SCRIPT_NAME}]: Waiting ${wait_second} second(s) for new disk status ..."
          #sleep ${wait_second}
          # From my test, linode has issue where sometimes (randomly) the status is not shown after creating a first disk
          # So, if the condition is other than above, we still wait, do not terminate this script
          #return 1
        fi

        #((wait_second_total = wait_second_total + wait_second))

        #if [ "${wait_second_total}" -gt ${wait_second_max} ]; then
        #  echo "[${SCRIPT_NAME}]: Warning, something is wrong while trying to create disk in linode for ${hostname_fqdn}. It took more than ${shutdown_wait_total} seconds. Please, inspect why!"
        #  echo "Total wait in second is: ${wait_second_total}"
        #  echo "Max wait in second is: ${wait_second_max}"
        #  _exit 1
        #fi
      done
    fi
    # --linode-api "list-configs" <hostname_fqdn>
  elif [[ "${action}" == "list-configs" || "${action}" == "lookup-configs" ]]; then
    shift
    local linode_id hostname_fqdn
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    echo "[${SCRIPT_NAME}]: listing config ${hostname_fqdn} ..."
    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    ${LINODE_CLI_BIN} linodes configs-list "${linode_id}" --json --pretty
    # --linode-api "delete-configs" <hostname_fqdn> # Plural configs remove all
  elif [[ "${action}" == "delete-configs" || "${action}" == "remove-configs" ]]; then
    shift
    local linode_id config_ids hostname_fqdn
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    echo "[${SCRIPT_NAME}]: Deleting all config profile for ${hostname_fqdn} ..."
    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    config_ids=$(${LINODE_CLI_BIN} linodes configs-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | .id")
    for config_id in ${config_ids}; do
      echo "[${SCRIPT_NAME}]: Deleting config ID ${config_id} from ${hostname_fqdn} ..."
      ${LINODE_CLI_BIN} linodes config-delete "${linode_id}" "${config_id}"
    done

    # --linode-api "delete-config" <hostname_fqdn> <label>
    # --linode-api "delete-config" sun.sofibox.com Boot_Config
  elif [[ "${action}" == "delete-config" || "${action}" == "remove-config" ]]; then
    shift
    local linode_id config_id config_label hostname_fqdn
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    config_label="$1"

    echo "[${SCRIPT_NAME}]: Deleting config ${config_label} profile for ${hostname_fqdn} ..."
    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    config_id=$(${LINODE_CLI_BIN} linodes configs-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_label}\") | .id")

    if [ -n "${config_id}" ]; then
      echo "[${SCRIPT_NAME}]: Deleting config ID ${config_id} from ${hostname_fqdn} ..."
      ${LINODE_CLI_BIN} linodes config-delete "${linode_id}" "${config_id}"
      #echo $?
    else
      echo "[${SCRIPT_NAME}]: Warning, no config ${config_label} is found!"
      return 1
    fi

    # --linode-api config-view <hostname_fqdn> <config_label>
  elif [[ "${action}" == "config-view" ]]; then
    shift
    local linode_id hostname_fqdn config_id config_label
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    config_label="$1"
    echo "[${SCRIPT_NAME}]: listing config ${hostname_fqdn} ..."
    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    config_id=$(${LINODE_CLI_BIN} linodes configs-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_label}\") | .id")
    echo "Viewing config ID ${config_id} from ${hostname_fqdn} ..."
    ${LINODE_CLI_BIN} linodes config-view "${linode_id}" "${config_id}" --json --pretty

  # --linode-api create-config sun.sofibox.com <config_label> <config_comment> <config_virmode> \
  #<config_kernel> <config_runlevel> <config_rootdevice> <disk_label_in_order_a-h>
  #eg: --linode-api create-config "sun.sofibox.com" "Boot_Config" "The installer boot configuration" "paravirt" "linode/direct-disk" "default" "/dev/sdb" "OS_Disk" "Boot_Disk"
  #2nd eg: eg: --linode-api create-config "sun.sofibox.com" "OS_Config" "The operating boot configuration" "paravirt" "linode/direct-disk" "default" "/dev/sda" "OS_Disk" "Boot_Disk"
  elif [[ "${action}" == "create-config" || "${action}" == "add-config" ]]; then
    shift
    local linode_id hostname_fqdn config_label config_comment config_virmode config_kernel \
      config_runlevel config_disk_devsda config_disk_devsdb config_disk_devsdc \
      config_disk_devsdd config_disk_devsde config_disk_devsdf config_disk_devsdg config_disk_devsdh \
      disk_id config_disks

    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${BOX_HOSTNAME_FQDN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    config_label="$1"
    config_comment="$2"
    config_virmode="$3"
    config_kernel="$4"
    config_runlevel="$5"
    # Only disk for now
    config_rootdevice="$6"

    config_disk_devsda="$7"
    config_disk_devsdb="$8"
    config_disk_devsdc="$9"
    config_disk_devsdd="${10}"
    config_disk_devsde="${11}"
    config_disk_devsdf="${12}"
    config_disk_devsdg="${13}"
    config_disk_devsdh="${14}"
    config_disks=""

    linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")

    # Convert the disk label to ID if not empty
    if [[ -n "${config_disk_devsda}" ]]; then
      config_disk_devsda=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_disk_devsda}\") | .id")
      config_disk_devsda="--devices.sda.disk_id ${config_disk_devsda}"
      # eg: Now config_disk_devsda is: --devices.sda.disk_id 123122
    fi

    # Convert the disk label to ID if not empty
    if [[ -n "${config_disk_devsdb}" ]]; then
      config_disk_devsdb=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_disk_devsdb}\") | .id")
      config_disk_devsdb="--devices.sdb.disk_id ${config_disk_devsdb}"
      # eg: Now config_disk_devsdb is: --devices.sdb.disk_id 123122
    fi
    # Convert the disk label to ID if not empty
    if [[ -n "${config_disk_devsdc}" ]]; then
      config_disk_devsdc=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_disk_devsdc}\") | .id")
      config_disk_devsdc="--devices.sdc.disk_id ${config_disk_devsdc}"
      # eg: Now config_disk_devsdc is: --devices.sdc.disk_id 123122
    fi
    # Convert the disk label to ID if not empty
    if [[ -n "${config_disk_devsdd}" ]]; then
      config_disk_devsdd=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_disk_devsdd}\") | .id")
      config_disk_devsdd="--devices.sdd.disk_id ${config_disk_devsdd}"
      # eg: Now config_disk_devsdd is: --devices.sdd.disk_id 123122
    fi
    # Convert the disk label to ID if not empty
    if [[ -n "${config_disk_devsde}" ]]; then
      config_disk_devsde=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_disk_devsde}\") | .id")
      config_disk_devsde="--devices.sde.disk_id ${config_disk_devsde}"
      # eg: Now config_disk_devsde is: --devices.sde.disk_id 123122
    fi
    # Convert the disk label to ID if not empty
    if [[ -n "${config_disk_devsdf}" ]]; then
      config_disk_devsdf=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_disk_devsdf}\") | .id")
      config_disk_devsdf="--devices.sdf.disk_id ${config_disk_devsdf}"
      # eg: Now config_disk_devsdf is: --devices.sdf.disk_id 123122
    fi
    # Convert the disk label to ID if not empty
    if [[ -n "${config_disk_devsdg}" ]]; then
      config_disk_devsdg=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_disk_devsdg}\") | .id")
      config_disk_devsdg="--devices.sdg.disk_id ${config_disk_devsdg}"
      # eg: Now config_disk_devsdg is: --devices.sdg.disk_id 123122
    fi
    # Convert the disk label to ID if not empty
    if [[ -n "${config_disk_devsdh}" ]]; then
      config_disk_devsdh=$(${LINODE_CLI_BIN} linodes disks-list "${linode_id}" --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${config_disk_devsdh}\") | .id")
      config_disk_devsdh="--devices.sdh.disk_id ${config_disk_devsdh}"
      # eg: Now config_disk_devsdh is: --devices.sdh.disk_id 123122
    fi
    echo "[${SCRIPT_NAME}]: Creating new config for ${config_label} for ${hostname_fqdn} with the following disk mount options:"
    config_disks="${config_disk_devsda} ${config_disk_devsdb} ${config_disk_devsdc} ${config_disk_devsdd} ${config_disk_devsde} ${config_disk_devsdf} ${config_disk_devsdg} ${config_disk_devsdh}"
    echo "${config_disks}"
    #exit 1
    #linode_id=$(${LINODE_CLI_BIN} linodes list --json --pretty | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    ${LINODE_CLI_BIN} linodes config-create "${linode_id}" --label "${config_label}" --comments "${config_comment}" \
      --virt_mode "${config_virmode}" --kernel "${config_kernel}" --run_level "${config_runlevel}" --root_device "${config_rootdevice}" \
      --helpers.distro "false" \
      --helpers.updatedb_disabled "false" \
      --helpers.modules_dep "false" \
      --helpers.devtmpfs_automount "false" \
      --helpers.network "false" \
      --root_device "${config_rootdevice}" ${config_disks} # Do not double quote this, because we want to split the string for options
    echo ""

  elif [[ "${action}" == "help" ]]; then

    echo "=== Linode API Syntax and example (Help Section) ==="
    echo ""
    echo "Get linode ID: "
    echo "  linode_api_admin get-linode-id <hostname_fqdn>"
    echo ""
    echo "Shutdown/turn off linode:"
    echo "  linode_api_admin shutdown-linode <hostname_fqdn>"
    echo ""
    echo "Boot/start linode: "
    echo "  linode_api_admin boot-linode <hostname_fqdn>"
    echo ""
    echo "Reboot/Restart linode: "
    echo "   linode_api_admin reboot-linode <hostname_fqdn>"
    echo ""
    echo "View linode information: "
    echo "   linode_api_admin view-linode <hostname_fqdn>"
    echo ""
    echo "View all linode configs information: "
    echo "   linode_api_admin list-configs <hostname_fqdn>"
    echo ""

  elif [[ "${action}" == "delete-dns-record" ]]; then
    shift
    local domain name dis_args record_id record_ids record_ids_count
    domain="$1"
    # Record name
    name="$2"
    type="$3"
    dis_args="${*:4}"

    if [[ -n "${dis_args}" ]]; then
      echo "[${SCRIPT_NAME}]: Warning, extra arguments discarded: ${dis_args}" 2>&1 | tee -a "${REPORT_FILE}"
    fi

    if [ $# -ge 3 ]; then
      echo "Checking record for domain ${domain} with record name ${name} and type ${type} ..." 2>&1 | tee -a "${REPORT_FILE}"
      #domain_id=$(${LINODE_CLI_BIN} --pretty --json domains list --domain "${domain}" | grep -F '"id":' | sed -r 's/[^0-9]//g')
      domain_id=$(${LINODE_CLI_BIN} domains list --json --pretty | ${JQ_BIN} ".[] | select(.domain == \"${domain}\") | .id")
      if [ -n "${domain_id}" ]; then
        #${LINODE_CLI_BIN} --pretty --json domains records-list --page 2 "${domain_id}"
        # Domain ID is correct now we execute next statement:
        # The record list is huge, use loop to scan based on maximum $linode_max_page
        #count=2
        #record_ids=$(${LINODE_CLI_BIN} --pretty --json domains records-list --page ${count} "${domain_id}" | ${JQ_BIN} ".[] | select((.name == \"${name}\") and (.type==\"${type}\")) | .id")
        #record_ids=$(${LINODE_CLI_BIN} --pretty --json domains records-list --page ${count} "${domain_id}" | ${JQ_BIN} ".[] | select((.name == \"${name}\") and (.type==\"${type}\")) | .id | first")
        #echo "${record_ids}"
        count=1
        while [[ ${count} -le ${linode_max_page} ]]; do
          record_ids=$(${LINODE_CLI_BIN} --pretty --json domains records-list --page ${count} "${domain_id}" | ${JQ_BIN} ".[] | select((.name == \"${name}\") and (.type==\"${type}\")) | .id")
          #  # Without using jq (traditional way):
          #  #| grep \"name\"": \"${name}\"" -B 1 \
          #  #| sed -r 's/[^0-9]//g' #\
          #  #| head -n 1
          # Break if found result for that page
          if [[ -n ${record_ids} ]]; then
            break
          fi
          ((count++))
        done
        # Without -n condition, the record will be counted as 1 even it's empty line
        if [[ -n "${record_ids}" ]]; then
          record_ids_count=$(echo "${record_ids}" | wc -l)
          #echo "${record_ids}"
          echo "[${SCRIPT_NAME}]: Total record ID found for the record name ${name} is ${record_ids_count}" 2>&1 | tee -a "${REPORT_FILE}"
          #c2=1
          #exit 1
          #record_ids_count=$(echo "${record_ids}" | wc -l)
          echo "[${SCRIPT_NAME}]: Deleting ${record_ids_count} record(s):" 2>&1 | tee -a "${REPORT_FILE}"
          success=0
          for record_id in ${record_ids}; do
            #Debug:
            echo "[${SCRIPT_NAME}]: Deleting record ID ${record_id} ..." 2>&1 | tee -a "${REPORT_FILE}"
            ${LINODE_CLI_BIN} --json --pretty domains records-delete "${domain_id}" "${record_id}"
            retval=$?
            if [ "${retval}" = 0 ]; then
              echo "=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"
              echo "OK, record ID ${record_id} has been deleted successfully." 2>&1 | tee -a "${REPORT_FILE}"
              # Do next deletion
              ((success++))
            else
              echo "Error [${retval}], delete failed for record ID ${record_id}" 2>&1 | tee -a "${REPORT_FILE}"
              # Do next deletion
            fi
          done
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          if [ "${success}" == "${record_ids_count}" ]; then
            echo "OK, ${success} out of ${record_ids_count} record(s) has been successfully deleted" 2>&1 | tee -a "${REPORT_FILE}"

          elif [[ "${success}" -eq 1 && "${success}" -lt "${record_ids_count}" ]]; then
            echo "Warning, only ${success} out of ${record_ids_count} record(s) has been successfully deleted" 2>&1 | tee -a "${REPORT_FILE}"
          else
            echo "Warning, no record has been deleted" 2>&1 | tee -a "${REPORT_FILE}"
          fi
          echo "=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
        else
          # Useful variable for future reference
          record_ids_count=0
          echo "[${SCRIPT_NAME}]: Warning, no record ID with record name ${name} and type ${type} is found for domain ${domain}" 2>&1 | tee -a "${REPORT_FILE}"
          # Don't exit
          return 1
        fi

        return 0
      else
        echo "[${SCRIPT_NAME}]: Warning, no domain ID found for domain ${domain}" 2>&1 | tee -a "${REPORT_FILE}"
        return 1
      fi
      return 0
    else
      echo "[${SCRIPT_NAME}]: Error, usage: linode_api_admin ${action} <domain_name> <record_name> <record_type>" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 2
    fi

  # In linode for record, only 3 things can be updated: name, value and TTL.
  # maxidns --linode "update-dns-record" <domain_name> <record_type> <record_name> <record_value> <record_ttl>
  elif [[ "${action}" == "update-dns-record" ]]; then
    shift
    #echo "add-dns-record"
    local domain type name value dis_args record_id record_ids record_ids_count
    domain="$1"
    # Record name
    type="$2"
    name="$3"
    value="$4"
    ttl="$5"
    dis_args="${*:6}"

    if [[ -n "${dis_args}" ]]; then
      echo "[${SCRIPT_NAME}]: Warning, extra arguments discarded: ${dis_args}" 2>&1 | tee -a "${REPORT_FILE}"
    fi

    if [ $# -ge 5 ]; then
      echo "[${SCRIPT_NAME}]: Checking record for domain ${domain} with record name ${name} and type ${type} ..." 2>&1 | tee -a "${REPORT_FILE}"
      #domain_id=$(${LINODE_CLI_BIN} --pretty --json domains list --domain "${domain}" | grep -F '"id":' | sed -r 's/[^0-9]//g')
      domain_id=$(${LINODE_CLI_BIN} --json --pretty domains list | ${JQ_BIN} ".[] | select(.domain == \"${domain}\") | .id")
      if [ -n "${domain_id}" ]; then
        count=1
        while [[ ${count} -le ${linode_max_page} ]]; do
          record_ids=$(${LINODE_CLI_BIN} --pretty --json domains records-list --page ${count} "${domain_id}" | ${JQ_BIN} ".[] | select((.name == \"${name}\") and (.type==\"${type}\")) | .id")
          # Break if found result for that page
          if [[ -n ${record_ids} ]]; then
            break
          fi
          ((count++))
        done
        # Without -n condition, the record will be counted as 1 even it's empty line
        if [[ -n "${record_ids}" ]]; then
          record_ids_count=$(echo "${record_ids}" | wc -l)
          #echo "${record_ids}"
          echo "[${SCRIPT_NAME}]: Total record ID found for the record name ${name} is ${record_ids_count}" 2>&1 | tee -a "${REPORT_FILE}"
          echo "[${SCRIPT_NAME}]: Updating ${record_ids_count} record(s):" 2>&1 | tee -a "${REPORT_FILE}"
          success=0
          for record_id in ${record_ids}; do
            #Debug:
            echo "[${SCRIPT_NAME}]: Updating record ID ${record_id} ..." 2>&1 | tee -a "${REPORT_FILE}"
            ${LINODE_CLI_BIN} --json --pretty domains records-update "${domain_id}" "${record_id}" --name "${name}" --target "${value}" --ttl_sec "${ttl}"
            retval=$?
            if [ "${retval}" = 0 ]; then
              echo "=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"
              echo "OK, record ID ${record_id} has been updated successfully updated." 2>&1 | tee -a "${REPORT_FILE}"
              # Do next update
              ((success++))
            else
              echo "Error [${retval}], update failed for record ID ${record_id}" 2>&1 | tee -a "${REPORT_FILE}"
              # Do next update
            fi
          done
          echo ""
          if [ "${success}" == "${record_ids_count}" ]; then
            echo "OK, ${success} out of ${record_ids_count} record(s) has been successfully updated" 2>&1 | tee -a "${REPORT_FILE}"

          elif [[ "${success}" -eq 1 && "${success}" -lt "${record_ids_count}" ]]; then
            echo "Warning, only ${success} out of ${record_ids_count} record(s) has been successfully updated" 2>&1 | tee -a "${REPORT_FILE}"
          else
            echo "Warning, no record has been updated" 2>&1 | tee -a "${REPORT_FILE}"
          fi
          echo "=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"
        else
          # Useful variable for future reference
          record_ids_count=0
          echo "[${SCRIPT_NAME}]: Error, no record ID with record name ${name} and type ${type} is found for domain ${domain}" 2>&1 | tee -a "${REPORT_FILE}"
          return 1
        fi
      else
        echo "[${SCRIPT_NAME}]: Error, no domain ID found for domain ${domain}" 2>&1 | tee -a "${REPORT_FILE}"
        return 1
      fi
      return 0
    else
      echo "[${SCRIPT_NAME}]: Error, usage: linode_api_admin ${action} <domain_name> <record_type> <record_name> <record_value> <record_ttl>" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 2
    fi

  else
    if [ -z "${action}" ]; then
      echo "[${SCRIPT_NAME}]: Error, the given action argument is empty: " 2>&1 | tee -a "${REPORT_FILE}"
      echo "[${SCRIPT_NAME}]: Usage: linode_api_admin ${action} <domain_name> <record_name>" 2>&1 | tee -a "${REPORT_FILE}"
    else
      echo "[${SCRIPT_NAME}]: Error, the given action argument '${action}' does not exist" 2>&1 | tee -a "${REPORT_FILE}"
    fi
    _exit 1
  fi

}

function digitalocean_api_admin() {
  :
}
# da_api_admin <action> <action-option-arguments>
# da_api_admin "create" "admin2" "admin2@sofibox.com" "x12321aa"
# da_api_admin add-ip 12.12.12.12 255.255.255.0
function da_api_admin() {
  # By default, da_api_admin will use owner authentication if I don't supply this: da_api_admin "end+owner"
  #echo "Continuing in 2 seconds ..."
  #sleep 2
  local api_username api_password
  local command data method filter_cmd is_start retval result #decoded_status
  local action username email password
  local owner_main_auth owner_new_list admin_new_list admin_list reseller_new_list admin_ori_list admin_main_auth
  local reseller_main_auth user_main_auth user_new_list
  local ip netmask ssl
  local domain ip_type
  local package_name
  local role_user
  admin_list="/usr/local/directadmin/data/admin/admin.list"
  admin_new_list=$(grep -w "${DA_ADMIN_USERNAME1}" "${admin_list}")
  owner_new_list=$(grep -w "${DA_OWNER_USERNAME1}" "${admin_list}")
  reseller_new_list=$(grep -w "${DA_RESELLER_USERNAME1}" "/usr/local/directadmin/data/admin/reseller.list")
  user_new_list=$(find /usr/local/directadmin/data/users/ -name "${DA_USER_USERNAME1}" -type d)
  admin_ori_list="/usr/local/directadmin/scripts/setup.txt"
  owner_main_auth="${TEMP_PATH}/api/${DA_OWNER_USERNAME1}_owner_main_auth_api"
  admin_main_auth="${TEMP_PATH}/api/${DA_ADMIN_USERNAME1}_admin_main_auth_api"
  reseller_main_auth="${TEMP_PATH}/api/${DA_RESELLER_USERNAME1}_reseller_main_auth_api"
  user_main_auth="${TEMP_PATH}/api/${DA_USER_USERNAME1}_user_main_auth_api"
  user_extra_auth="${TEMP_PATH}/api/extra_user_main_auth_api"
  action="$1"

  mkdir -p "${TEMP_PATH}/api"
  if [[ "${SETUP_DA_HOST_SSL}" == "yes" && -f "${CONF_PATH}/configure_da_ssl_executed" ]]; then
    ssl="https"
  else
    ssl="http"
  fi
  is_start=$(echo "${action}" | awk -F'+' '{ print $1 }')
  # This can be either username or role name
  role_user=$(echo "${action}" | awk -F'+' '{ print $2 }')
  role_password=$(echo "${action}" | awk -F'+' '{ print $3 }')
  #da_api_admin "signas+${da_user_uname}${role_password}"
  if [ "${is_start}" == "signas" ]; then
    user_extra_list=$(find /usr/local/directadmin/data/users/ -name "${role_user}" -type d)
    if [ -n "${user_extra_list}" ]; then
      rm -f "${TEMP_PATH}"/api/*
      echo "Authenticating DA API with signas+${role_user} ..."
      touch "${user_extra_auth}"
      {
        echo "DA_USER_EXTRA_USERNAME=\"${role_user}"\"
        echo "DA_USER_EXTRA_USERPASS=\"${role_password}"\"
      } >"${user_extra_auth}"
    elif [ "${action}" == "signas+owner" ]; then
      rm -f "${TEMP_PATH}"/api/*
      echo "Authenticating DA API with signas+owner"
      if [ -n "${owner_new_list}" ]; then
        #echo "[${SCRIPT_NAME}]: Found main owner account ${owner_new_list} matched in config file. Creating API session file authentication for ${owner_new_list} ..." 2>&1 | tee -a "${REPORT_FILE}"
        touch "${owner_main_auth}"
        {
          echo "DA_OWNER_USERNAME1=\"${DA_OWNER_USERNAME1}"\"
          echo "DA_OWNER_USERPASS1=\"${DA_OWNER_USERPASS1}"\"
        } >"${owner_main_auth}"
      else
        echo "[${SCRIPT_NAME}]: Error, no main owner account matched in config file. Please create owner first!" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi
    elif [ "${action}" == "signas+admin" ]; then
      rm -f "${TEMP_PATH}"/api/*
      echo "Authenticating DA API with signas+admin"
      if [ -n "${admin_new_list}" ]; then
        #echo "[${SCRIPT_NAME}]: Found main admin account ${admin_new_list} matched in config file. Creating API session file authentication for ${admin_new_list} ..." 2>&1 | tee -a "${REPORT_FILE}"
        touch "${admin_main_auth}"
        {
          echo "DA_ADMIN_USERNAME1=\"${DA_ADMIN_USERNAME1}"\"
          # Admin username cannot contain character '+' it will trigger invalid password (DA bug?)
          echo "DA_ADMIN_USERPASS1=\"${DA_ADMIN_USERPASS1}"\"
        } >"${admin_main_auth}"
      else
        echo "[${SCRIPT_NAME}]: Error, no main admin account matched in config file. Please create admin first!" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi
    elif [ "${action}" == "signas+reseller" ]; then
      rm -f "${TEMP_PATH}"/api/*
      echo "Authenticating DA API with signas+reseller"
      if [ -n "${reseller_new_list}" ]; then
        #echo "[${SCRIPT_NAME}]: Found main reseller account ${reseller_new_list} matched in config file. Creating API session file authentication for ${reseller_new_list} ..." 2>&1 | tee -a "${REPORT_FILE}"
        touch "${reseller_main_auth}"
        {
          echo "DA_RESELLER_USERNAME1=\"${DA_RESELLER_USERNAME1}"\"
          echo "DA_RESELLER_USERPASS1=\"${DA_RESELLER_USERPASS1}"\"
        } >"${reseller_main_auth}"
      else
        echo "[${SCRIPT_NAME}]: Error, no main reseller account matched in config file. Please create reseller first!" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi
    elif [ "${action}" == "signas+user" ]; then
      rm -f "${TEMP_PATH}"/api/*
      echo "Authenticating DA API with signas+user"
      if [ -n "${user_new_list}" ]; then
        #echo "[${SCRIPT_NAME}]: Found main user account ${user_new_list} matched in config file. Creating API session file authentication for ${user_new_list}..." 2>&1 | tee -a "${REPORT_FILE}"
        touch "${user_main_auth}"
        {
          echo "DA_USER_USERNAME1=\"${DA_USER_USERNAME1}"\"
          echo "DA_USER_USERPASS1=\"${DA_USER_USERPASS1}"\"
        } >"${user_main_auth}"
      else
        echo "[${SCRIPT_NAME}]: Error, no main user account matched in config file. Please create user first!" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi
    fi
  elif [ "${is_start}" == "end" ]; then
    if [ "${action}" == "end+owner" ]; then
      rm -f "${owner_main_auth}"
    elif [ "${action}" == "end+admin" ]; then
      rm -f "${admin_main_auth}"
    elif [ "${action}" == "end+reseller" ]; then
      rm -f "${reseller_main_auth}"
    elif [ "${action}" == "end+user" ]; then
      rm -f "${user_main_auth}"
    elif [ "${action}" == "end" ]; then
      rm -f "${TEMP_PATH}"/api/*
    fi
  fi

  # End check

  # If the admin.list file has a new admin username, we use that authentication
  # This is the default authentication for DA owner
  if [ -s "${user_extra_auth}" ]; then
    #echo "[${SCRIPT_NAME}]: Found auth file for ${role_user}. Using authentication for this user ..." 2>&1 | tee -a "${REPORT_FILE}"
    #_pause 2
    api_username=$(sed -n 's/^DA_USER_EXTRA_USERNAME=//p' "${user_extra_auth}" | sed -e 's/^"//' -e 's/"$//')
    api_password=$(sed -n 's/^DA_USER_EXTRA_USERPASS=//p' "${user_extra_auth}" | sed -e 's/^"//' -e 's/"$//')
  elif [ -s "${owner_main_auth}" ]; then
    #echo "[${SCRIPT_NAME}]: Found auth file for ${DA_OWNER_USERNAME1}. Using authentication for this user ..." 2>&1 | tee -a "${REPORT_FILE}"
    #_pause 2
    api_username=$(sed -n 's/^DA_OWNER_USERNAME1=//p' "${owner_main_auth}" | sed -e 's/^"//' -e 's/"$//')
    api_password=$(sed -n 's/^DA_OWNER_USERPASS1=//p' "${owner_main_auth}" | sed -e 's/^"//' -e 's/"$//')
    #echo "api_username is: ${api_username}"
    #echo "api_userpassword is: ${api_password}"
    #exit 1
  elif [ -s "${admin_main_auth}" ]; then
    #echo "[${SCRIPT_NAME}]: Found auth file for ${DA_ADMIN_USERNAME1}. Using authentication for this user ..." 2>&1 | tee -a "${REPORT_FILE}"
    #_pause 2
    api_username=$(sed -n 's/^DA_ADMIN_USERNAME1=//p' "${admin_main_auth}" | sed -e 's/^"//' -e 's/"$//')
    api_password=$(sed -n 's/^DA_ADMIN_USERPASS1=//p' "${admin_main_auth}" | sed -e 's/^"//' -e 's/"$//')
  elif [ -s "${reseller_main_auth}" ]; then
    #echo "[${SCRIPT_NAME}]: Found auth file for ${DA_RESELLER_USERNAME1}. Using authentication for this user ..." 2>&1 | tee -a "${REPORT_FILE}"
    #_pause 2
    api_username=$(sed -n 's/^DA_RESELLER_USERNAME1=//p' "${reseller_main_auth}" | sed -e 's/^"//' -e 's/"$//')
    api_password=$(sed -n 's/^DA_RESELLER_USERPASS1=//p' "${reseller_main_auth}" | sed -e 's/^"//' -e 's/"$//')
  elif [ -s "${user_main_auth}" ]; then
    #echo "[${SCRIPT_NAME}]: Found auth file for ${DA_USER_USERNAME1}. Using authentication for this user ..." 2>&1 | tee -a "${REPORT_FILE}"
    #_pause 2
    api_username=$(sed -n 's/^DA_USER_USERNAME1=//p' "${user_main_auth}" | sed -e 's/^"//' -e 's/"$//')
    api_password=$(sed -n 's/^DA_USER_USERPASS1=//p' "${user_main_auth}" | sed -e 's/^"//' -e 's/"$//')
  # At this stage, if user don't use signas+<user> before calling API then it will use below with the condition the auth exist:
  elif [ -n "${owner_new_list}" ]; then
    #echo "[${SCRIPT_NAME}]: Found auth file for ${DA_OWNER_USERNAME1}. Using authentication for this user ..." 2>&1 | tee -a "${REPORT_FILE}"
    #_pause 2
    api_username=${DA_OWNER_USERNAME1}
    api_password=${DA_OWNER_USERPASS1}
  elif [ -s "${admin_ori_list}" ]; then
    #echo "[${SCRIPT_NAME}]: No other authentication file found. Using DA API authentication from DA setup.txt file ..." 2>&1 | tee -a "${REPORT_FILE}"
    #_pause 2
    # else we use the original authentication generated by DA during installation if all above not valid
    api_username=$(sed -n 's/^adminname=//p' ${admin_ori_list})
    api_password=$(sed -n 's/^adminpass=//p' ${admin_ori_list})
  else
    echo "[${SCRIPT_NAME}]: Warning, no valid authentication is available to use Directadmin API!" 2>&1 | tee -a "${REPORT_FILE}"
    _exit 1
  fi
  # Only run this if number of argument is more than 1 or at least 2
  if [ "$#" -gt 1 ]; then
    if [ "${action}" == "create-admin-account" ]; then
      # da_api_admin "create-admin-account" "admin2" "admin2@sofibox.com" "12321"
      shift
      username="$1"
      email="$2"
      password="$3"
      command="CMD_API_ACCOUNT_ADMIN"
      method="POST"
      #echo "SSL: ${ssl} | Action: ${action} | username: ${username} | email: ${email} | password: ${password}"
      #exit 1
      data="action=create&add=submit&username=${username}&email=${email}&passwd=${password}&passwd2=${password}&notify=yes&json=yes"
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${action}" == "create-reseller-account" ]; then
      # da_api_admin "create-reseller-account" "reseller1" "reseller1@sofibox.com" "x1231aax" "sofibox.com" "RESELLER_UNLIMITED" "shared"
      shift
      username="$1"
      email="$2"
      password="$3"
      domain="$4"
      package_name="$5"
      ip_type="$6"
      command="CMD_ACCOUNT_RESELLER"
      data="username=${username}&email=${email}&passwd=${password}&passwd2=${password}&domain=${domain}&package=${package_name}&notify=yes&ip=${ip_type}&action=create&add=yes&json=yes"
      method="POST"
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${action}" == "create-user-account" ]; then
      # da_api_admin "create-reseller-account" "user1" "user1@maxibi.com" "x1231aax" "maxibi.com" "USER_UNLIMITED"
      shift
      username="$1"
      email="$2"
      password="$3"
      domain="$4"
      package_name="$5"
      # Normally IPv4 that has been set up in DA
      command="CMD_API_ACCOUNT_USER"
      data="username=${username}&email=${email}&passwd=${password}&passwd2=${password}&domain=${domain}&package=${package_name}&ip=${IPV4_ADD0}&notify=yes&add=yes&action=create&json=yes"
      method="POST"
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${action}" == "delete-users" ]; then
      # da_api_admin "delete-users" "admin2"
      shift
      username="$1"
      command="CMD_API_SELECT_USERS"
      data="confirmed=Confirm&delete=yes&select0=${username}"
      method="POST"
      #echo "SSL: ${ssl} | Action: ${action} | username: ${username}"
      #exit 1
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${action}" == "add-ip" ]; then
      # da_api_admin "add-ip" "2400:1234:0000:0000:123c:1234:fe05:6cb1" "/64"
      # da_api_admin "add-ip" "12.12.12.12" "255.255.255.0"
      shift
      ip="$1"
      netmask="$2"
      command="CMD_API_IP_MANAGER"
      data="action=add&ip=${ip}&netmask=${netmask}&device=yes&add_to_device_aware=yes&json=yes"
      method="POST"
      echo "SSL: ${ssl} | Action: ${action} | IP: ${ip} | netmask: ${netmask}"
      #exit 1
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
      #CMD_API_MANAGE_RESELLER_PACKAGES
    elif [ "${action}" == "create-reseller-package" ]; then
      # da_api_admin"create-reseller-package" "RESELLER_UNLIMITED"
      shift
      package_name="$1"
      command="CMD_API_MANAGE_RESELLER_PACKAGES"
      # This is unlimited RESELLER package:
      data="bandwidth=5000&ubandwidth=yes&quota=1000&uquota=yes&inode=&uinode=yes&vdomains=10&uvdomains=yes&nsubdomains=10&unsubdomains=yes&nemails=100&unemails=yes&nemailf=100&unemailf=yes&nemailml=10&unemailml=yes&nemailr=100&unemailr=yes&mysql=0&umysql=yes&domainptr=0&udomainptr=yes&ftp=10&uftp=yes&cgi=ON&php=ON&spam=ON&catchall=ON&ssl=ON&oversell=ON&cron=ON&sysinfo=ON&login_keys=ON&dnscontrol=ON&dns=OFF&serverip=ON&packagename=${package_name}&nusers=&unusers=yes&add=save&ips=0&json=yes"
      method="POST"
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${action}" == "create-user-package" ]; then
      shift
      package_name="$1"
      # This is unlimited USER package:
      command="CMD_API_MANAGE_USER_PACKAGES"
      data="bandwidth=1000&ubandwidth=yes&quota=100&uquota=yes&inode=&uinode=yes&vdomains=1&uvdomains=yes&nsubdomains=10&unsubdomains=yes&nemails=10&unemails=yes&unemailf=yes&nemailml=0&unemailml=yes&nemailr=10&unemailr=yes&mysql=5&umysql=yes&domainptr=0&udomainptr=yes&ftp=1&uftp=yes&php=ON&spam=ON&catchall=ON&ssl=ON&cron=ON&sysinfo=ON&login_keys=ON&dnscontrol=ON&suspend_at_limit=ON&language=en&skin=evolution&packagename=${package_name}&add=save&json=yes"
      method="POST"
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${action}" == "create-user-domain" ]; then
      shift
      domain="$1"
      command="CMD_API_DOMAIN"
      data="domain=${domain}&uquota=unlimited&ssl=ON&php=ON&action=create&ubandwidth=unlimited&json=yes"
      method="POST"
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${action}" == "enable-email-dkim" ]; then
      shift
      domain="$1"
      command="CMD_API_EMAIL_POP"
      data="action=set_dkim&domain=${domain}&enable=yes&json=yes"
      method="POST"
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
    #da_api_admin "get-dns-zone" "maxibi.com" "_domainkey+TXT+o=+.value"
    elif [ "${action}" == "get-dns-zone" ]; then
      local record_name record_type record_contains_val record_out_display
      shift
      domain="$1"
      filter_cmd="$2"
      command="CMD_API_DNS_CONTROL"
      # Dont need json format now because we want to easily filter the data
      data="domain=${domain}&json=yes"
      method="POST"
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
      # Executing API via curl based on command above
      record_name=$(echo "${filter_cmd}" | awk -F'+' '{ print $1 }')
      record_type=$(echo "${filter_cmd}" | awk -F'+' '{ print $2 }')
      record_contains_val=$(echo "${filter_cmd}" | awk -F'+' '{ print $3 }')
      record_out_display=$(echo "${filter_cmd}" | awk -F'+' '{ print $4 }')
      echo "Value of filter_cmd is: ${filter_cmd}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "Value of record_name is: ${record_name}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "Value of record_type is: ${record_type}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "Value of record_contains_val is: ${record_contains_val}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "Value of record_out_display is: ${record_out_display}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "===" 2>&1 | tee -a "${REPORT_FILE}"
      #curl --request "${method}" --user "${api_username}":"${api_password}" --data "${data}" "${ssl}://${BOX_HOSTNAME_FQDN}:${DA_PORT}/${command}" | grep 'v=DKIM1' | awk '{for(i=6;i<=NF;++i)printf $i""FS ; print ""}' | sed -e 's/^"//' -e 's/"$//'
      result=$(curl --silent --request "${method}" --user "${api_username}":"${api_password}" --data "${data}" "${ssl}://${BOX_HOSTNAME_FQDN}:${DA_PORT}/${command}" | jq -r ".records[] | select((.name==\"${record_name}\") and (.type==\"${record_type}\") and (.value | contains(\"${record_contains_val}\"))) | ${record_out_display}" | sed -e 's/^"//' -e 's/"$//')
      retval=$?
      if [ -n "${result}" ]; then
        # get out based on return value (prevent next statement from running)
        echo "${result}"
        return ${retval}
      else
        echo "Warning, the TXT record doesn't exist, it should exist"
        exit 1
      fi
      # da_api_admin "create-dns-record" "maxibi.com" "TXT" "_domainkey" "o%3D%7E%3B+r%3Dwebmaster%40sofibox.com"
      # The last one equal to: o=~; r=webmaster@sofibox.com (use https://www.url-encode-decode.com/ to decode)
    elif [ "${action}" == "create-dns-record" ]; then
      local domain name ttl type value domain_id dis_args retval add_dns_record
      shift
      domain="$1"
      type="$2"
      name="$3"
      value="$4" #value=o%3D%7E%3B+r%3Dwebmaster%40
      data="domain=${domain}&type=${type}&name=${name}&value=${value}&ttl=3600&affect_pointers=yes&json=yes&action=add"
      command="CMD_API_DNS_CONTROL"
      method="POST"
      # da_api_admin "create-user-email" "maxibi.com" "webmaster" "1232123" "0" "200"
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${action}" == "create-user-email" ]; then
      local mail_domain mail_user mail_pass mail_quota mail_limit
      shift
      mail_domain="$1"
      mail_user="$2"
      mail_pass="$3"
      mail_quota="$4"
      mail_limit="$5"
      command="CMD_API_EMAIL_POP"
      #https://www.directadmin.com/features.php?id=2587 not sure if this useful
      data="user=${mail_user}&passwd=${mail_pass}&passwd2=${mail_pass}&quota=${mail_quota}&limit=${mail_limit}&domain=${mail_domain}&json=yes&action=create"
      method="POST"
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
    # da_api_admin "create-user-subdomain" "maxibi.com" "sales"
    elif [ "${action}" == "create-user-subdomain" ]; then
      local root_domain sub_domain
      shift
      root_domain="$1"
      sub_domain="$2"
      # CMD_API_SUBDOMAIN AND CMD_API_SUBDOMAINS are the same thing: https://www.directadmin.com/features.php?id=1589
      command="CMD_API_SUBDOMAIN"
      data="domain=${root_domain}&subdomain=${sub_domain}&json=yes&action=create"
      method="POST"
      # da_api_admin "request-domain-ssl" <provider> <root_domain> <keysize> <encryption> <ssl_sub_domains_query>
      # da_api_admin "request-domain-ssl" letsencrypt codegix.com secp521r1 sha256 "le_select0=codegix.com&le_select1=www.codegix.com&le_select2=ftp.codegix.com \
      # &le_select3=mail.codegix.com&le_select4=pop.codegix.com&le_select5=smtp.codegix.com&le_select6=dashboard.codegix.com&le_select7=secure.codegix.com"
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${action}" == "request-domain-ssl" ]; then
      local ssl_root_domain ssl_key_size ssl_encryption
      shift
      ssl_provider="$1"
      ssl_root_domain="$2"
      ssl_key_size="$3"
      ssl_encryption="$4"
      ssl_sub_domains_query="$5"
      # CMD_API_SUBDOMAIN AND CMD_API_SUBDOMAINS are the same thing: https://www.directadmin.com/features.php?id=1589
      command="CMD_API_SSL"
      if [ "${ssl_provider}" == "letsencrypt" ]; then
        data="type=create&request=letsencrypt&name=${ssl_root_domain}&keysize=${ssl_key_size}&encryption=${ssl_encryption} \
      &wildcard=no&domain=${ssl_root_domain}&json=yes&action=save&background=auto&${ssl_sub_domains_query}"
      else
        # Give error because we focus on letsencrypt first
        echo "[${SCRIPT_NAME}]: Error, this provider ${ssl_provider} has no API yet" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi
      method="POST"
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
    # da_api_admin "set-da-logo" <skin_name> <logo_mode> <path_to_logo.png>
    # skin_name: evolution, enhanced | logo_mode: dark-logo, default-logo
    # eg: da_api_admin "set-da-logo" evolution dark-logo /home/tmp/logo_dark.png
    elif [ "${action}" == "set-da-logo" ]; then
      local skin_name logo_mode logo_path
      shift
      skin_name="$1"
      logo_mode="$2"
      logo_path="$3"
      if [ "${logo_mode}" == "default-logo" ]; then
        logo_mode="1"
      else
        logo_mode="2"
      fi
      command="CMD_SKINS"
      data="action=upload_logo&file=${logo_path}&json=yes&name=${skin_name}&which=${logo_mode}"
      method="POST"
      # da_api_admin "set-da-options" evolution
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${action}" == "set-da-options" ]; then
      # Customize
      shift
      local skin_name
      skin_name="$1"
      command="CMD_SKINS"
      #config will be stored in: username/skin_customizations/evolution/config.json
      db_route=$(echo "${PHPMYADMIN_LOGIN_ROUTE}" | sed 's/^\///')
      rc_route=$(echo "${ROUNDCUBE_LOGIN_ROUTE}" | sed 's/^\///')
      # Set the grid layout
      default_layout="defaultLayout%22%3A%22grid%22%2C%22"
      data="json=yes&name=evolution&action=save_config_json&config.json=%7B%22menu%22%3A%7B%22user%22%3A%5B%7B%22name%22%3A%22Account+Manager%22%2C%22icon%22%3A%22account-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fuser%2Fdomains%22%2C%22name%22%3A%22Domain+Setup%22%2C%22icon%22%3A%22domain-setup%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fsubdomains%22%2C%22name%22%3A%22Subdomain+Management%22%2C%22icon%22%3A%22subdomain-management%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fdns%22%2C%22name%22%3A%22DNS+Management%22%2C%22icon%22%3A%22dns-management%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fssl%22%2C%22name%22%3A%22SSL+Certificates%22%2C%22icon%22%3A%22ssl%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fftp-accounts%22%2C%22name%22%3A%22FTP+Management%22%2C%22icon%22%3A%22ftp-management%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fdatabase%22%2C%22name%22%3A%22MySQL+Management%22%2C%22icon%22%3A%22mysql-management%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fdomain-pointers%22%2C%22name%22%3A%22Domain+Pointers%22%2C%22icon%22%3A%22domain-pointers%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fredirects%22%2C%22name%22%3A%22Site+Redirection%22%2C%22icon%22%3A%22site-redirection%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fhotlinks%22%2C%22name%22%3A%22Hotlinks+Protection%22%2C%22icon%22%3A%22hotlinks%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fphp-settings%22%2C%22name%22%3A%22PHP+Settings%22%2C%22icon%22%3A%22php-configuration%22%2C%22enabled%22%3Atrue%7D%5D%7D%2C%7B%22name%22%3A%22E-mail+Manager%22%2C%22icon%22%3A%22email-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fuser%2Femail%2Faccounts%22%2C%22name%22%3A%22E-mail+Accounts%22%2C%22icon%22%3A%22email-accounts%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Fforwarders%22%2C%22name%22%3A%22Forwarders%22%2C%22icon%22%3A%22forwarders%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Fautoresponders%22%2C%22name%22%3A%22Autoresponders%22%2C%22icon%22%3A%22autoresponders%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Fvacations%22%2C%22name%22%3A%22Vacation+Messages%22%2C%22icon%22%3A%22vacation-messages%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Fspamassassin%22%2C%22name%22%3A%22Spamassassin+Setup%22%2C%22icon%22%3A%22spamassassin%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Ffilters%22%2C%22name%22%3A%22SPAM+Filters%22%2C%22icon%22%3A%22spam-filters%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Flists%22%2C%22name%22%3A%22Mailing+Lists%22%2C%22icon%22%3A%22mailing-lists%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fdns%2Fmx-records%22%2C%22name%22%3A%22MX+Records%22%2C%22icon%22%3A%22mx-records%22%2C%22enabled%22%3Atrue%7D%5D%7D%2C%7B%22icon%22%3A%22advanced-features%22%2C%22name%22%3A%22Advanced+Features%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fuser%2Fhandlers%22%2C%22name%22%3A%22Apache+Handlers%22%2C%22icon%22%3A%22apache-handlers%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Fcatch-all%22%2C%22name%22%3A%22Catch-All+E-mail%22%2C%22icon%22%3A%22catch-all-email%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fbackup%22%2C%22name%22%3A%22Create%2FRestore+Backups%22%2C%22icon%22%3A%22create-restore-backup%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fcronjobs%22%2C%22name%22%3A%22Cron+Jobs%22%2C%22icon%22%3A%22cron-jobs%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Ferror-pages%22%2C%22name%22%3A%22Custom+Error+Pages%22%2C%22icon%22%3A%22custom-error-pages%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fmimetypes%22%2C%22name%22%3A%22Mime+Types%22%2C%22icon%22%3A%22mime-types%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fsecurity-questions%22%2C%22name%22%3A%22Security+Questions%22%2C%22icon%22%3A%22security-questions%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Ftwo-step-auth%22%2C%22name%22%3A%22Two-Step+Authentication%22%2C%22icon%22%3A%22two-step-auth%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fprotected-directories%22%2C%22name%22%3A%22Password+Protected+Directories%22%2C%22icon%22%3A%22password-protected-directories%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fssh-keys%22%2C%22name%22%3A%22SSH+Keys%22%2C%22icon%22%3A%22ssh-keys%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fmodsecurity%22%2C%22name%22%3A%22ModSecurity%22%2C%22icon%22%3A%22mod-security%22%2C%22enabled%22%3Atrue%7D%5D%7D%2C%7B%22icon%22%3A%22system-information%22%2C%22name%22%3A%22System+Info+%26+Files%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%2FCMD_FILE_MANAGER%22%2C%22newTab%22%3Atrue%2C%22name%22%3A%22File+Manager%22%2C%22icon%22%3A%22file-manager%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fperl-modules%22%2C%22name%22%3A%22Installed+Perl+Modules%22%2C%22icon%22%3A%22installed-perl-modules%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fsystem-info%22%2C%22name%22%3A%22System+Information%22%2C%22icon%22%3A%22server-information%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fstats%22%2C%22name%22%3A%22Site+Summary+%2F+Statistics+%2F+Logs%22%2C%22icon%22%3A%22site-summary%22%2C%22enabled%22%3Atrue%7D%5D%7D%2C%7B%22icon%22%3A%22extra-features%22%2C%22name%22%3A%22Extra+Features%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2Fsquirrelmail%22%2C%22name%22%3A%22Webmail%3A+Squirrelmail%22%2C%22enabled%22%3Afalse%2C%22newTab%22%3Atrue%2C%22slug%22%3A%22squirrelmail%22%2C%22icon%22%3A%22squirellmail%22%7D%2C%7B%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${rc_route}%22%2C%22name%22%3A%22Mail%3A+${ROUNDCUBE_CUSTOM_NAME}%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22slug%22%3A%22roundcube%22%2C%22icon%22%3A%22roundcube%22%7D%2C%7B%22route%22%3A%22phpmyadmin%22%2C%22name%22%3A%22phpMyAdmin%22%2C%22enabled%22%3Afalse%2C%22icon%22%3A%22phpmyadmin%22%7D%2C%7B%22route%22%3A%22plugins%22%2C%22name%22%3A%22Plugins+will+be+inserted+after+this+entry%22%2C%22enabled%22%3Afalse%2C%22icon%22%3A%22%22%7D%2C%7B%22name%22%3A%22DB%3A++${PHPMYADMIN_CUSTOM_NAME}%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${db_route}%22%2C%22newTab%22%3Atrue%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22phpmyadmin%22%7D%5D%7D%2C%7B%22icon%22%3A%22support-help%22%2C%22name%22%3A%22Support+%26+Help%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%7B%7Bhelp%7D%7D%22%2C%22name%22%3A%22Help%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22help%22%7D%2C%7B%22route%22%3A%22%2Fuser%2Fcreate-ticket%22%2C%22name%22%3A%22Create+Ticket%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22create-ticket%22%7D%2C%7B%22route%22%3A%22%2Fuser%2Fmessages%22%2C%22name%22%3A%22Support+Center%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22support-center%22%7D%5D%7D%5D%2C%22reseller%22%3A%5B%7B%22name%22%3A%22Account+Manager%22%2C%22icon%22%3A%22account-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A3%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Freseller%2Fcreate-user%22%2C%22name%22%3A%22Add+New+User%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22add-new-user%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fusers%22%2C%22name%22%3A%22List+Users%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22list-users%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fuser-packages%22%2C%22name%22%3A%22Manage+User+Packages%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-user-packages%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fpasswords%22%2C%22name%22%3A%22Change+Passwords%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22change-passwords%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fedit-user-message%22%2C%22name%22%3A%22Edit+User+Message%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22edit-user-message%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fsuspension-message%22%2C%22name%22%3A%22Suspension+Message%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22edit-user-message%22%7D%5D%7D%2C%7B%22name%22%3A%22Server+Manager%22%2C%22icon%22%3A%22server-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Freseller%2Fip-config%22%2C%22name%22%3A%22IP+Management%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22ip-management%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fnameservers%22%2C%22name%22%3A%22Name+Servers%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22name-servers%22%7D%2C%7B%22route%22%3A%22%2Fuser%2Fssh-keys%22%2C%22name%22%3A%22SSH+Keys%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22ssh-keys%22%7D%5D%7D%2C%7B%22name%22%3A%22Reseller+Tools%22%2C%22icon%22%3A%22reseller-tools%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Freseller%2Fbackups%22%2C%22name%22%3A%22Manage+User+Backups%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-user-backups%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fmessage-users%22%2C%22name%22%3A%22Message+All+Users%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22message-all-users%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fskins%22%2C%22name%22%3A%22Skin+Manager%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22skin-manager%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fcustomize-skin%22%2C%22name%22%3A%22Customize+Evolution+Skin%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22customize-evolution-skin%22%7D%5D%7D%2C%7B%22name%22%3A%22System+Info+%26+Files%22%2C%22icon%22%3A%22system-information%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%2FCMD_FILE_MANAGER%22%2C%22newTab%22%3Atrue%2C%22name%22%3A%22File+Manager%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22file-manager%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fsystem-info%22%2C%22name%22%3A%22System+Information%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22system-info%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fstats%22%2C%22name%22%3A%22Reseller+Statistics%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22reseller-statistics%22%7D%5D%7D%2C%7B%22name%22%3A%22Extra+Features%22%2C%22icon%22%3A%22extra-features%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2Fsquirrelmail%22%2C%22name%22%3A%22Webmail%3A+Squirrelmail%22%2C%22enabled%22%3Afalse%2C%22newTab%22%3Atrue%2C%22slug%22%3A%22squirrelmail%22%2C%22icon%22%3A%22squirellmail%22%7D%2C%7B%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2Fwebmail%22%2C%22name%22%3A%22Webmail%3A+UebiMiau%22%2C%22enabled%22%3Afalse%2C%22newTab%22%3Atrue%2C%22slug%22%3A%22uebimiau%22%2C%22icon%22%3A%22uebimiau%22%7D%2C%7B%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${rc_route}%22%2C%22name%22%3A%22Mail%3A+${ROUNDCUBE_CUSTOM_NAME}%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22slug%22%3A%22roundcube%22%2C%22icon%22%3A%22roundcube%22%7D%2C%7B%22route%22%3A%22phpmyadmin%22%2C%22name%22%3A%22phpMyAdmin%22%2C%22enabled%22%3Afalse%2C%22icon%22%3A%22phpmyadmin%22%7D%2C%7B%22route%22%3A%22plugins%22%2C%22name%22%3A%22Plugins+will+be+inserted+after+this+entry%22%2C%22enabled%22%3Afalse%2C%22icon%22%3A%22%22%7D%2C%7B%22name%22%3A%22DB%3A+${PHPMYADMIN_CUSTOM_NAME}%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${db_route}%22%2C%22newTab%22%3Atrue%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22phpmyadmin%22%7D%5D%7D%2C%7B%22name%22%3A%22Support+%26+Help%22%2C%22icon%22%3A%22support-help%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%7B%7Bhelp%7D%7D%22%2C%22name%22%3A%22Help%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22help%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Ftickets%22%2C%22name%22%3A%22Manage+Tickets%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-tickets%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Ftickets%2Fcreate%22%2C%22name%22%3A%22Create+Ticket%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22create-ticket%22%7D%5D%7D%5D%2C%22admin%22%3A%5B%7B%22name%22%3A%22Account+Manager%22%2C%22icon%22%3A%22account-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A4%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fadmin%2Fusers%2Fadmins%2Fcreate%22%2C%22name%22%3A%22Create+Administrator%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22create-administrator%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%2Fadmins%22%2C%22name%22%3A%22List+Administrators%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22list-administrators%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fpasswords%22%2C%22name%22%3A%22Change+Passwords%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22change-passwords%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%2Fresellers%2Fcreate%22%2C%22name%22%3A%22Create+Reseller%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22create-reseller%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%2Fresellers%22%2C%22name%22%3A%22List+Resellers%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22list-resellers%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Freseller-packages%22%2C%22name%22%3A%22Manage+Reseller+Packages%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-reseller-packages%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%22%2C%22name%22%3A%22Show+All+Users%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22show-all-users%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%2Fmove%22%2C%22name%22%3A%22Move+Users+between+Resellers%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22move-users-between-resellers%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fsuspension-message%22%2C%22name%22%3A%22Suspension+Message%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22edit-user-message%22%7D%5D%7D%2C%7B%22name%22%3A%22Server+Manager%22%2C%22icon%22%3A%22server-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A3%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fadmin%2Fsettings%22%2C%22name%22%3A%22Administrator+Settings%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22administrator-settings%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fcustom-httpd%22%2C%22name%22%3A%22Custom+HTTPD+Configurations%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22custom-httpd-configuration%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fdns%22%2C%22name%22%3A%22DNS+Administration%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22dns-administration%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fip-manager%22%2C%22name%22%3A%22IP+Management%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22ip-management%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fmulti-server%22%2C%22name%22%3A%22Multi+Server+Setup%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22multi-server-setup%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fphp-safe-mode%22%2C%22name%22%3A%22PHP+Configuration%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22php-configuration%22%7D%2C%7B%22route%22%3A%22%2Fuser%2Fssh-keys%22%2C%22name%22%3A%22SSH+Keys%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22ssh-keys%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fmodsecurity%22%2C%22name%22%3A%22ModSecurity%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22%22%7D%5D%7D%2C%7B%22name%22%3A%22Admin+Tools%22%2C%22icon%22%3A%22admin-tools%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A3%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fadmin%2Fbackups%22%2C%22name%22%3A%22Admin+Backup%2FTransfer%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22admin-backup-transfer%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fbrute-force-monitor%22%2C%22name%22%3A%22Brute+Force+Monitor%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22brute-force-monitor%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fprocess-monitor%22%2C%22name%22%3A%22Process+Monitor%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22process-monitor%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fmail-queue%22%2C%22name%22%3A%22Mail+Queue+Administration%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22mail-queue-administration%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fservices%22%2C%22name%22%3A%22Service+Monitor%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22service-monitor%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fsystem-backup%22%2C%22name%22%3A%22System+Backup%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22system-backup%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fcustomize-skin%22%2C%22name%22%3A%22Customize+Evolution+Skin%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22customize-evolution-skin%22%7D%2C%7B%22slug%22%3A%22rspamd%22%2C%22href%22%3A%22%2FCMD_RSPAMD_SOCK%2F%22%2C%22name%22%3A%22Rspamd+spam+filtering+system%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22spam-metrics%22%2C%22newTab%22%3Atrue%7D%2C%7B%22slug%22%3A%22netdata%22%2C%22href%22%3A%22%2FCMD_NETDATA_SOCK%22%2C%22name%22%3A%22Netdata+server+metrics%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22netdata%22%2C%22newTab%22%3Atrue%7D%5D%7D%2C%7B%22name%22%3A%22System+Info+%26+Files%22%2C%22icon%22%3A%22system-information%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A3%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fadmin%2Fcron-jobs%22%2C%22name%22%3A%22All+User+Cron+Jobs%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22all-user-cron-jobs%22%7D%2C%7B%22href%22%3A%22%2FCMD_FILE_MANAGER%22%2C%22newTab%22%3Atrue%2C%22name%22%3A%22File+Manager%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22file-manager%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Ffile-editor%22%2C%22name%22%3A%22File+Editor%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22file-editor%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fsystem-info%22%2C%22name%22%3A%22System+Information%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22system-information%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Flog-viewer%22%2C%22name%22%3A%22Log+Viewer%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22log-viewer%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fstats%22%2C%22name%22%3A%22Complete+Usage+Statistics%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22complete-usage-statistics%22%7D%5D%7D%2C%7B%22name%22%3A%22Extra+Features%22%2C%22icon%22%3A%22extra-features%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22slug%22%3A%22squirrelmail%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2Fsquirrelmail%22%2C%22name%22%3A%22Webmail%3A+Squirrelmail%22%2C%22enabled%22%3Afalse%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22squirellmail%22%7D%2C%7B%22slug%22%3A%22uebimiau%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2Fwebmail%22%2C%22name%22%3A%22Webmail%3A+UebiMiau%22%2C%22enabled%22%3Afalse%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22uebimiau%22%7D%2C%7B%22slug%22%3A%22roundcube%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${rc_route}%22%2C%22name%22%3A%22Mail%3A+${ROUNDCUBE_CUSTOM_NAME}%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22roundcube%22%7D%2C%7B%22name%22%3A%22DB%3A+${PHPMYADMIN_CUSTOM_NAME}%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${db_route}%22%2C%22newTab%22%3Atrue%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22phpmyadmin%22%7D%2C%7B%22route%22%3A%22phpmyadmin%22%2C%22name%22%3A%22phpMyAdmin%22%2C%22enabled%22%3Afalse%2C%22icon%22%3A%22phpmyadmin%22%7D%2C%7B%22route%22%3A%22plugins%22%2C%22name%22%3A%22Plugins+will+be+inserted+after+this+entry%22%2C%22enabled%22%3Afalse%2C%22icon%22%3A%22%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fplugin-manager%22%2C%22name%22%3A%22Plugin+Manager%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22plugin-manager%22%7D%5D%7D%2C%7B%22name%22%3A%22Support+%26+Help%22%2C%22icon%22%3A%22support-help%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%7B%7Bhelp%7D%7D%22%2C%22name%22%3A%22Help%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22help%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Ftickets%22%2C%22name%22%3A%22Manage+Tickets%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-tickets%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Flicense%22%2C%22name%22%3A%22Licensing+%2F+Updates%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22licensing-updates%22%7D%5D%7D%5D%7D%2C%22colors%22%3A%7B%22primary-dark%22%3A%7B%22hue%22%3A196%2C%22saturation%22%3A100%2C%22lightness%22%3A32.34%2C%22alpha%22%3A100%7D%2C%22safe%22%3A%7B%22hue%22%3A140%2C%22saturation%22%3A41%2C%22lightness%22%3A56%7D%2C%22danger%22%3A%7B%22hue%22%3A20%2C%22saturation%22%3A76%2C%22lightness%22%3A47%7D%2C%22neutral%22%3A%7B%22hue%22%3A180%2C%22saturation%22%3A0.448430493273541%2C%22lightness%22%3A43.72549019607843%7D%7D%2C%22${default_layout}dateFormats%22%3A%7B%22datetime%22%3A%22d%2FM%2Fyyyy+HH%3Amm%3Ass++a%22%2C%22date%22%3A%22d+MMM%2C+yyy%22%2C%22weekStart%22%3A%22monday%22%7D%2C%22theme%22%3A%22%22%2C%22forcedMode%22%3A%22dark%22%7D"
      method="POST"
      # da_api_admin "modify-user" da_user1 name "Arafat Ali"
      # da_api_admin "modify-user" da_user2 nameserver "ns1.sofibox.com" "ns2.sofibox.com"
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${action}" == "modify-user" ]; then
      shift
      local setting da_user value1 value2
      da_user="$1"
      setting="$2"
      value1="$3"
      value2="$4"
      command="CMD_API_MODIFY_USER"
      if [ "${setting}" == "email" ]; then
        data="user=${da_user}&evalue=${value1}&json=yes&action=single&email=yes"
      elif [ "${setting}" == "name" ]; then
        data="user=${da_user}&nvalue=${value1}&json=yes&action=single&name=yes"
      elif [ "${setting}" == "nameserver" ]; then
        if [[ -n "${value2}" ]]; then
          data="user=${da_user}&ns1=${value1}&ns2=${value2}&json=yes&action=single&ns=yes"
        else
          echo "[${SCRIPT_NAME}]: Missing value2 argument for setting up ${setting}" 2>&1 | tee -a "${REPORT_FILE}"
          _exit 1
        fi
      elif [ "${setting}" == "skin" ]; then
        data="user=${da_user}&skinvalue=${value1}&json=yes&action=single&skin=yes"
      else
        echo "[${SCRIPT_NAME}]: The setting '${setting}' does not exist!" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi
      method="POST"
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"
      # da_admin_api "set-security-qna" "Sekolah menengah dulu aliran apa ?" "sains"
    elif [ "${action}" == "set-security-qna" ]; then
      shift
      local custom_question answer
      custom_question="$1"
      answer="$2"
      command="CMD_SECURITY_QUESTIONS"
      data="type=custom&value=${answer}&json=yes&action=add&custom_question=${custom_question}"
      method="POST"
      # da_admin_api "set-admin-settings"
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"

    elif [ "${action}" == "set-admin-settings" ]; then
      shift
      command="CMD_API_ADMIN_SETTINGS"
      data="auto_update=yes&backup_threshold=90&demo_admin=no&demo_reseller=no&demo_user=no&oversell=yes&service_email_active=yes&suspend=yes&user_backup=yes&json=yes&action=save"
      method="POST"
      # da_admin_api "set-server-settings"
      # This API includes security settings and email settings (DA combined this)
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"

    elif [ "${action}" == "set-server-settings" ]; then
      command="CMD_API_ADMIN_SETTINGS"
      data="brute_force_log_scanner=yes&brute_force_scan_apache_logs=2&brute_force_time_limit=1200&brutecount=20&brute_dos_count=100&bruteforce=yes&check_partitions=2&check_subdomain_owner=yes&clear_blacklist_ip_time=86400&clear_brute_log_entry_time=4&clear_brute_log_time=24&demodocsroot=.%2Fdata%2Fskins%2Fevolution&enforce_difficult_passwords=yes&exempt_local_block=no&ip_brutecount=100&logs_to_keep=3&lost_password=no&max_per_email_send_limit=-1&maxfilesize=5368709120&ns1=${BOX_NS1}&ns2=${BOX_NS1}&partition_usage_threshold=95&per_email_limit=200&purge_spam_days=0&rbl_enabled=yes&servername=${BOX_HOSTNAME_FQDN}&session_minutes=35791&timeout=35791&user_brutecount=100&user_can_set_email_limit=yes&virtual_limit=1000&unblock_brute_ip_time=86400&timezone=${BOX_TIMEZONE}&max_username_length=${DA_MAX_UNAME_LENGTH}&json=yes&action=config"
      method="POST"
      # da_admin_api "create-database" <db_name> <db_username> <db_password> <domain>
      # This will create new database with new user
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"

    elif [ "${action}" == "create-database" ]; then
      shift
      local db_name db_username db_password db_domain
      db_name="$1"
      db_username="$2"
      db_password="$3"
      db_domain="$4"
      # CMD_API_DB not working but CMD_DB is working
      command="CMD_DB"
      data="name=${db_name}&user=${db_username}&passwd=${db_password}&passwd2=${db_password}&domain=${db_domain}&userlist=...&action=create&json=yes"
      method="POST"
      # da_admin_api "create-user-database" <db_name> <db_username> <domain>
      # This will select existing user to create database
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"

    elif [ "${action}" == "create-user-database" ]; then
      shift
      local db_name db_username db_password db_domain
      db_name="$1"
      db_username="$2"
      db_domain="$3"
      command="CMD_DB"
      data="name=${db_name}&user=${db_username}&domain=${db_domain}&userlist=${db_username}&action=create&json=yes"
      method="POST"
      echo "Now, executing API with action name: ${action}" 2>&1 | tee -a "${REPORT_FILE}"

    else
      echo "[${SCRIPT_NAME}]: The API action '${action}' does not exist!" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    #_pause 2
    echo "[${SCRIPT_NAME}]: API status: " 2>&1 | tee -a "${REPORT_FILE}"
    echo "----------------------------" 2>&1 | tee -a "${REPORT_FILE}"
    echo "" 2>&1 | tee -a "${REPORT_FILE}"
    #Don't use --max-time or decrease time out because letsencrypt API will need more time to request cert
    #Don't use --silent here (it won't show result)
    curl --request "${method}" --user "${api_username}":"${api_password}" --data "${data}" "${ssl}://${BOX_HOSTNAME_FQDN}:${DA_PORT}/${command}"
    echo "----------------------------" 2>&1 | tee -a "${REPORT_FILE}"
    echo "" 2>&1 | tee -a "${REPORT_FILE}"

  else
    echo "da_api_admin first argument given was: $1" 2>&1 | tee -a "${REPORT_FILE}"
  fi
}

# This will check if system needs to reboot based on /var/run/reboot-required file
# This function also will make sure if a caller function has finished executed, then we won't run that function again.
function check_finish_reboot() {
  local FUNC_NAME="$1"
  cat /dev/null >"${CONF_PATH}/${FUNC_NAME}_executed"
  if [ -f /var/run/reboot-required ]; then
    if [ "${ENABLE_SETUP_REBOOT}" == "auto" ]; then
      echo "[${SCRIPT_NAME}]: [Notice]: *** System reboot required. Rebooting in 30 seconds (ctrl+c to cancel) ..." 2>&1 | tee -a "${REPORT_FILE}"
      sleep 30
      _reboot
    elif [ "${ENABLE_SETUP_REBOOT}" == "interactive" ]; then
      read -r -s -n 1 -p "[${SCRIPT_NAME}]: [Notice]: *** System reboot required. Press any key to reboot (ctrl+c to cancel) ..." 2>&1 | tee -a "${REPORT_FILE}"
      _reboot
    elif [ "${ENABLE_SETUP_REBOOT}" == "disabled" ]; then
      read -r -s -n 1 -p "[${SCRIPT_NAME}]: [Notice]: *** Warning, system reboot required, but ENABLE_SETUP_REBOOT setting is disabled!" 2>&1 | tee -a "${REPORT_FILE}"
    fi
    echo ""
  else
    echo "[${SCRIPT_NAME}]: [OK]: ${FUNC_NAME} has been executed" 2>&1 | tee -a "${REPORT_FILE}"
    # This sleep is for debugging, when finish developing this script, I should remove this sleep to speed up the script
    #sleep 1
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  return 0
}

# This function will check service error and try to repair it using common solutions like log error information
# check_fix_service <service_name>
function check_fix_service() {
  local service_name="$1"
  local gc retval lfd_service csf_service
  echo "[${SCRIPT_NAME}]: Checking ${service_name} status ..." 2>&1 | tee -a "${REPORT_FILE}"
  sleep 2
  if [ "${service_name}" == "csf" ]; then
    # Fix that here
    csf_service=$(systemctl is-active csf)
    if [ "${csf_service}" == "active" ]; then
      echo "[${SCRIPT_NAME}]: OK, CSF service is running with status 0" 2>&1 | tee -a "${REPORT_FILE}"
    else
      # CSF fix 1 - restarting
      echo "[${SCRIPT_NAME}]: Warning, unable to start CSF service properly. Restarting CSF ..." 2>&1 | tee -a "${REPORT_FILE}"
      systemctl restart csf
      sleep 3
      csf_service=$(systemctl is-active csf)
      if [ "${csf_service}" == "active" ]; then
        echo "[${SCRIPT_NAME}]: Warning, unable to start CSF service properly. Please check the log file for more hints" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      else
        echo "[${SCRIPT_NAME}]: OK, CSF service is running with status 0" 2>&1 | tee -a "${REPORT_FILE}"
      fi
      # CSF fix 2 - pending if any
    fi
  fi

  if [ "${service_name}" == "lfd" ]; then
    lfd_service=$(systemctl is-active lfd)
    if [ "${lfd_service}" == "active" ]; then
      echo "[${SCRIPT_NAME}]: OK, lfd has started with status 0" 2>&1 | tee -a "${REPORT_FILE}"
    else
      echo "[${SCRIPT_NAME}]: Warning, unable to start LFD service properly. Trying to solve this based on common problems ..." 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      # Start lfd to generate log file because first it had no log
      echo "[${SCRIPT_NAME}]: Starting lfd to generate lfd log file ..." 2>&1 | tee -a "${REPORT_FILE}"
      systemctl start lfd
      # Waiting 10 seconds (so that the log file is generated properly within this time)
      sleep 5
      # lfd known fix 1
      if [ -f /var/log/lfd.log ]; then
        gc=$(grep -ic 'you may need to install the IO::Socket::INET6 module' /var/log/lfd.log)
        if [ "${gc}" -ne 0 ]; then
          echo "[${SCRIPT_NAME}]: Found missing perl IO::Socket::INET6 module. Installing libio-socket-inet6-perl for Debian" 2>&1 | tee -a "${REPORT_FILE}"
          sleep 1
          apt-get -y install libio-socket-inet6-perl 2>&1 | tee -a "${REPORT_FILE}"
          echo "[${SCRIPT_NAME}]: Clearing lfd log entry ..." 2>&1 | tee -a "${REPORT_FILE}"
          sleep 1
          cat /dev/null >/var/log/lfd.log
          echo "[${SCRIPT_NAME}]: Restarting lfd ..." 2>&1 | tee -a "${REPORT_FILE}"
          systemctl restart lfd
          # Waiting 10 seconds (so that the log file is generated properly within this time)
          sleep 5
          check_fix_service "lfd"
        else
          echo "[${SCRIPT_NAME}]: Error, unable to understand why lfd cannot be started. Check /var/log/lfd.log for more hints" 2>&1 | tee -a "${REPORT_FILE}"
          _exit 1
        fi
      else
        # This is just in case if log file not appear
        echo "[${SCRIPT_NAME}]: Warning, lfd log file not generated" 2>&1 | tee -a "${REPORT_FILE}"
        echo "[${SCRIPT_NAME}]: Rechecking lfd status in 5 seconds ..." 2>&1 | tee -a "${REPORT_FILE}"
        sleep 5
        check_fix_service "lfd"
      fi

      # lfd known fix 2
      # ----

    fi
  fi
}

function restart_da_web_server() {
  if [ "${CB_WEB_SERVER_SOFTWARE}" == "nginx_apache" ]; then
    echo "[${SCRIPT_NAME}]: Restarting httpd for new httpd config ..." 2>&1 | tee -a "${REPORT_FILE}"
    systemctl restart httpd
    echo "[${SCRIPT_NAME}]: Restarting nginx ..." 2>&1 | tee -a "${REPORT_FILE}"
    systemctl restart nginx
  elif [ "${CB_WEB_SERVER_SOFTWARE}" == "nginx" ]; then
    echo "[${SCRIPT_NAME}]: Restarting nginx ..." 2>&1 | tee -a "${REPORT_FILE}"
    systemctl restart nginx
  elif [ "${CB_WEB_SERVER_SOFTWARE}" == "apache" ]; then
    echo "[${SCRIPT_NAME}]: Restarting httpd for new httpd config ..." 2>&1 | tee -a "${REPORT_FILE}"
    systemctl restart httpd
  else
    :
  fi
}

function pre_setup() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    if [ "${DISTRO_ID}" == "centos" ]; then
      echo "[${SCRIPT_NAME}]: Current OS distro ID is centos. Disabling SELinux policy ..." 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      setenforce 0
      if [ -e /etc/selinux/config ]; then
        sed -i s/^SELINUX=.*$/SELINUX=disabled/ /etc/selinux/config
      fi
      if [ -e /usr/sbin/setenforce ]; then
        /usr/sbin/setenforce 0
      fi
      check_finish_reboot "${FUNCNAME[0]}"
    elif [ "${DISTRO_ID}" == "debian" ]; then
      # psmisc = pstree utils (needed by maxigpg script from maxicode)

      # Known usability bug from Debian installer with old grub-pc
      # Fixed grub-pc appear interactive GUI when running dist-upgrade https://github.com/hashicorp/vagrant/issues/289
      # This is the Debian usability bug for grub as explained in here:
      # https://askubuntu.com/questions/23418/what-do-i-select-for-grub-install-devices-after-an-update#comment837055_23418
      # This only show when you have kernel set to GRUB 2

      apt-get -y update
      apt-get -y upgrade

      # By default sudo is not installed. It's needed for new OS
      apt-get -y install sudo screen nmap psmisc gpg unzip zip 2>&1 | tee -a "${REPORT_FILE}"
    else
      echo "[${SCRIPT_NAME}]: Error, unknown value for distribution ID ${DISTRO_ID}" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi

  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}
# Get the latest scripts from private repo (need to have private token defined in config)
# This private repo contains lots of security scripts for Linux (c) by Arafat Ali (aka MaXi32)
# can re-run this to re-clone (update latest codes)
get_latest_maxisetup() {
  #if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
  echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
  local GIT_ASKPASS
  if ! command -v git &>/dev/null; then
    if [ "${DISTRO_ID}" == "centos" ]; then
      echo "[${SCRIPT_NAME}]: Downloading git for centos ..." 2>&1 | tee -a "${REPORT_FILE}"
      dnf -y install git 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${DISTRO_ID}" == "debian" ]; then
      echo "[${SCRIPT_NAME}]: Downloading git for debian ..." 2>&1 | tee -a "${REPORT_FILE}"
      apt-get -y install git 2>&1 | tee -a "${REPORT_FILE}"
    else
      echo "[${SCRIPT_NAME}]: Error, unknown value for distribution ID ${DISTRO_ID}" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
  fi
  # This one work for both CentOS and Debian
  echo "[${SCRIPT_NAME}]: Setting up temporary git authentication for private repository ..." 2>&1 | tee -a "${REPORT_FILE}"
  cat /dev/null >"${HOME}/.git-askpass"
  echo "#!/bin/bash" >>"${HOME}/.git-askpass"
  echo "echo ${GIT_TOKEN}" >>"${HOME}/.git-askpass"
  chmod +x "${HOME}/.git-askpass"
  export GIT_ASKPASS="${HOME}/.git-askpass"
  cd_to_path "${DATA_PATH}"
  echo "[${SCRIPT_NAME}]: Removing existing maxisetup repository ..." 2>&1 | tee -a "${REPORT_FILE}"
  # remove existing setup
  rm -rf "${DATA_PATH}/maxisetup"
  echo "[${SCRIPT_NAME}]: Cloning new maxisetup repository ..." 2>&1 | tee -a "${REPORT_FILE}"
  echo "=~=~=~=~=~=~=~"
  git clone "${SETUP_GIT_URL}" 2>&1 | tee -a "${REPORT_FILE}"
  echo "=~=~=~=~=~=~=~"
  # Now we have setup folder.
  # Delete these files for security
  echo "[${SCRIPT_NAME}]: Removing git authentication and destroying its environment variable ..." 2>&1 | tee -a "${REPORT_FILE}"
  rm -f "${HOME}/.git-askpass"
  unset GIT_ASKPASS
  check_finish_reboot "${FUNCNAME[0]}"
  #else
  #  echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
  # echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  #fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# Basic security hardening for Linux
function secure_box() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local find_au rsa_public_key
    rsa_public_key="/root/user_${SSH_USERNAME}_${BOX_HOSTNAME_FQDN}.id_rsa.pub"
    if [ ! -f "${rsa_public_key}" ]; then
      echo "The RSA public key file ${rsa_public_key} not found!"
      _exit 1
    else
      echo "Using RSA public key from ${rsa_public_key} for ${SSH_USERNAME} SSH login ..."
      # Reassign SSH_PUBLIC_KEY to the latest SSH key
      SSH_PUBLIC_KEY=$(cat "${rsa_public_key}")
    fi
    echo "[${SCRIPT_NAME}]: Securing ${BOX_HOSTNAME_FQDN} ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    echo "[${SCRIPT_NAME}]: Changing root password ..." 2>&1 | tee -a "${REPORT_FILE}"

    if [ "${DISTRO_ID}" == "centos" ]; then
      echo "${ROOT_USERPASS}" | passwd --stdin "${ROOT_USERNAME}" 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${DISTRO_ID}" == "debian" ]; then
      echo "${ROOT_USERNAME}:${ROOT_USERPASS}" | chpasswd
    else
      echo "[${SCRIPT_NAME}]: Error, unknown value for distribution ID ${DISTRO_ID}" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    echo "[${SCRIPT_NAME}]: Setting hostname to ${BOX_HOSTNAME_FQDN} ..." 2>&1 | tee -a "${REPORT_FILE}"
    hostnamectl set-hostname "${BOX_HOSTNAME_FQDN}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: [Testing]: hostname is $(hostname)" 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Setting timezone to ${BOX_TIMEZONE} ..." 2>&1 | tee -a "${REPORT_FILE}"
    timedatectl set-timezone "${BOX_TIMEZONE}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: [Testing]: Current date is $(date)" 2>&1 | tee -a "${REPORT_FILE}"

    if [ "${DISTRO_ID}" == "centos" ]; then
      echo "[${SCRIPT_NAME}]: Creating a username ${SSH_USERNAME} ..." 2>&1 | tee -a "${REPORT_FILE}"
      adduser "${SSH_USERNAME}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "[${SCRIPT_NAME}]: Setting password for ${SSH_USERNAME} ..." 2>&1 | tee -a "${REPORT_FILE}"
      echo "${SSH_USERPASS}" | passwd --stdin "${SSH_USERNAME}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "[${SCRIPT_NAME}]: Adding user ${SSH_USERNAME} to the highest privilege group ..." 2>&1 | tee -a "${REPORT_FILE}"
      gpasswd -a "${SSH_USERNAME}" wheel 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${DISTRO_ID}" == "debian" ]; then
      echo "[${SCRIPT_NAME}]: Creating a username ${SSH_USERNAME} ..." 2>&1 | tee -a "${REPORT_FILE}"
      useradd "${SSH_USERNAME}" -s /bin/bash -m 2>&1 | tee -a "${REPORT_FILE}"
      echo "[${SCRIPT_NAME}]: Setting password for ${SSH_USERNAME} ..." 2>&1 | tee -a "${REPORT_FILE}"
      echo "${SSH_USERNAME}:${SSH_USERPASS}" | chpasswd
      echo "[${SCRIPT_NAME}]: Adding user ${SSH_USERNAME} to the highest privilege group ..." 2>&1 | tee -a "${REPORT_FILE}"
      usermod -aG sudo "${SSH_USERNAME}" 2>&1 | tee -a "${REPORT_FILE}"
    else
      echo "[${SCRIPT_NAME}]: Error, unknown value for distribution ID ${DISTRO_ID}" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    echo "[${SCRIPT_NAME}]: Testing ${SSH_USERNAME} log in ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: =~=~=~=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"
    sudo -H -u "${SSH_USERNAME}" bash -c 'echo "[Testing]: Hello, I am ${USER}, with uid ${UID}"' 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: =~=~=~=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"
    # TIP: To remove this user we can do this:
    # userdel -r "${SSH_USERNAME}" , where -r will also delete home directory

    echo "[${SCRIPT_NAME}]: Creating SSH private key using the name of ${SSH_USERNAME} ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Creating a directory of .ssh in ${SSH_USERNAME}'s home directory ..." 2>&1 | tee -a "${REPORT_FILE}"
    sudo -H -u "${SSH_USERNAME}" bash -c "mkdir -p ~/.ssh"
    echo "[${SCRIPT_NAME}]: Creating a file .ssh/authorized_keys in ${SSH_USERNAME}'s home directory ..." 2>&1 | tee -a "${REPORT_FILE}"
    sudo -H -u "${SSH_USERNAME}" bash -c "touch ~/.ssh/authorized_keys"

    echo "[${SCRIPT_NAME}]: Copying the public key into ~/.ssh/authorized_keys ..."
    sudo -H -u "${SSH_USERNAME}" bash -c "echo ${SSH_PUBLIC_KEY} >~/.ssh/authorized_keys"
    echo "[${SCRIPT_NAME}]: Changing .ssh/authorized_keys permission to chmod 700 ..." 2>&1 | tee -a "${REPORT_FILE}"
    sudo -H -u "${SSH_USERNAME}" bash -c "chmod 700 ~/.ssh/authorized_keys"

    #sed -i "/AllowUsers/c\AllowUsers ${SSH_USERNAME}" /etc/ssh/sshd_config
    find_au=$(grep -w "AllowUsers ${SSH_USERNAME}" /etc/ssh/sshd_config)
    if [[ -z "${find_au}" ]]; then
      # Put at the bottom
      echo "[${SCRIPT_NAME}]: Adding user ${SSH_USERNAME} to AllowUsers list in sshd_config ..." 2>&1 | tee -a "${REPORT_FILE}"
      echo "AllowUsers ${SSH_USERNAME}" >>/etc/ssh/sshd_config
    else
      echo "[${SCRIPT_NAME}]: [Skipped] user ${SSH_USERNAME} is already set as AllowUsers list in sshd_config ..." 2>&1 | tee -a "${REPORT_FILE}"
    fi
    # Don't permit root login
    echo "[${SCRIPT_NAME}]: Disabling root login via sshd_config ..." 2>&1 | tee -a "${REPORT_FILE}"
    sed -i '/^PermitRootLogin/s/yes/no/' /etc/ssh/sshd_config
    echo "[${SCRIPT_NAME}]: Disabling Password authentication via sshd_config ..." 2>&1 | tee -a "${REPORT_FILE}"
    sed -i "s/^#PasswordAuthentication.*/PasswordAuthentication no/" /etc/ssh/sshd_config
    echo "[${SCRIPT_NAME}]: Disabling empty password login via sshd_config ..." 2>&1 | tee -a "${REPORT_FILE}"
    sed -i "s/^#PermitEmptyPasswords.*/PermitEmptyPasswords no/" /etc/ssh/sshd_config

    echo "[${SCRIPT_NAME}]: Changing SSH default port from 22 to ${SSH_PORT} so CSF will automatically add this PORT during installation ..." 2>&1 | tee -a "${REPORT_FILE}"
    sed -i "s/#Port 22/Port ${SSH_PORT}/" /etc/ssh/sshd_config
    echo "[${SCRIPT_NAME}]: Changing SSH to listen only to IPv4 (disable IPv6 SSH login) ..." 2>&1 | tee -a "${REPORT_FILE}"
    sed -i "s/^#AddressFamily.*/AddressFamily inet/" /etc/ssh/sshd_config
    # Adding login banner
    echo "[${SCRIPT_NAME}]: Setting login banner for issue and issue.net ..." 2>&1 | tee -a "${REPORT_FILE}"

    {
      echo "Legal Authentication Banner:"
      echo "---------------------------"
      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~00000~=~=~=~=~=~=~=~=~+~=~=~=~=~+~="
      echo "Welcome to Sofibox. This is the ${BOX_HOSTNAME^^} Server"
      echo "The ${BOX_HOSTNAME^^} consists of ENERGY where it has been created"
      echo "perfectly with a certain EQUATIONS from NOTHING. Human"
      echo "beings have changed the original EQUATIONS to their own"
      echo "EQUATIONS. The ENERGY consists of TIME where TIME is MONEY"
      echo "and MONEY is part of the RESOURCES. If you need SOMETHING,"
      echo "the most ethical way in the world of humanity is asking"
      echo "for SOMETHING instead of manipulating the RESOURCES."
      echo "Disconnect now if you are not one of the team at Sofibox"
      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~00000~=~=~=~=~=~=~=~=~+~=~=~=~=~+~="
      echo "Do not waste your RESOURCES for NOTHING - MaXi32, 2001"
      echo "=============== We turned on 1 LiGHT DaRK =============="
      echo ""
      echo "SECURE TAG: access, legal, law, connect, enforce, system"
    } >/etc/issue
    cp -p /etc/issue /etc/issue.net
    echo "[${SCRIPT_NAME}]: Enabling login banner in sshd_config ..." 2>&1 | tee -a "${REPORT_FILE}"
    sed -i "s/^#Banner none/Banner \/etc\/issue/" /etc/ssh/sshd_config

    if [ "${DISTRO_ID}" == "centos" ]; then
      echo "[${SCRIPT_NAME}]: Adding SSH port ${SSH_PORT}/tcp to firewalld ..." 2>&1 | tee -a "${REPORT_FILE}"
      sudo firewall-cmd --permanent --zone=public --add-port="${SSH_PORT}/tcp" 2>&1 | tee -a "${REPORT_FILE}"
      echo "[${SCRIPT_NAME}]: Adding an IP from ${TEMP_ALLOW_IP} in firewalld to prevent locked out during setup" 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      sudo firewall-cmd --permanent --add-source="${TEMP_ALLOW_IP}" >&1 | tee -a "${REPORT_FILE}"
      firewall-cmd --reload
    elif [ "${DISTRO_ID}" == "debian" ]; then
      echo "[${SCRIPT_NAME}]: [Notice]: The default debian installation doesn't include firewall. Installing ufw to protect protect server during setup ..." 2>&1 | tee -a "${REPORT_FILE}"
      apt install ufw 2>&1 | tee -a "${REPORT_FILE}"
      echo "[${SCRIPT_NAME}]: Adding SSH port ${SSH_PORT}/tcp to ufw ..." 2>&1 | tee -a "${REPORT_FILE}"
      sudo ufw allow "${SSH_PORT}/tcp" 2>&1 | tee -a "${REPORT_FILE}"
      echo "[${SCRIPT_NAME}]: Adding an IP from ${TEMP_ALLOW_IP} in ufw to prevent locked out during setup" 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      sudo ufw allow from "${TEMP_ALLOW_IP}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "[${SCRIPT_NAME}]: Enabling ufw firewall ..." 2>&1 | tee -a "${REPORT_FILE}"
      sudo ufw --force enable 2>&1 | tee -a "${REPORT_FILE}"
    else
      echo "[${SCRIPT_NAME}]: Error, unknown value for distribution ID ${DISTRO_ID}" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    # Another SSHD tweaks
    echo "[${SCRIPT_NAME}]: Hardening other settings for SSHD_CONFIG ..." 2>&1 | tee -a "${REPORT_FILE}"
    # Recommended by lynis
    echo "[${SCRIPT_NAME}]: Setting SSH LogLevel to VERBOSE ..." 2>&1 | tee -a "${REPORT_FILE}"
    sed -i "s/^#LogLevel.*/LogLevel VERBOSE/" /etc/ssh/sshd_config
    #sleep 1
    # Recommended by lynis
    echo "[${SCRIPT_NAME}]: Setting SSH MaxAuthTries to 5 ..." 2>&1 | tee -a "${REPORT_FILE}"
    sed -i "s/^#MaxAuthTries.*/MaxAuthTries 5/" /etc/ssh/sshd_config
    #sleep 1
    # Recommended by lynis
    echo "[${SCRIPT_NAME}]: Setting SSH MaxSessions to 10 ..." 2>&1 | tee -a "${REPORT_FILE}"
    sed -i "s/^#MaxSessions.*/MaxSessions 10/" /etc/ssh/sshd_config
    #sleep 1
    # This one recommended by CSF security page:
    echo "[${SCRIPT_NAME}]: Setting SSH UseDNS to no ..." 2>&1 | tee -a "${REPORT_FILE}"
    sed -i "s/^#UseDNS.*/UseDNS no/" /etc/ssh/sshd_config
    #sleep 1

    # Restart SSHD
    echo "[${SCRIPT_NAME}]: Restarting sshd service ..." 2>&1 | tee -a "${REPORT_FILE}"
    # This works with debian too
    systemctl reload sshd 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: [OK]: Now ${BOX_HOSTNAME_FQDN} is secured with SSH. You can login using new port: ${SSH_PORT}" 2>&1 | tee -a "${REPORT_FILE}"
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function init_local_maxicode() {
  #if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
  echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
  echo "[${SCRIPT_NAME}]: Copying maxicode scripts into /usr/local/maxicode ..." 2>&1 | tee -a "${REPORT_FILE}"
  sleep 1
  cp -r "${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/usr/local/maxicode" /usr/local/
  # TODO add maxicode folder to /usr/local/maxicode
  # Make sure maxisetup is binary executable (link that on startup)
  # run maxisetup --init-maxicode in order to get the latest version of binary from maxicode.
  # make sure IDE use this maxicode directly from that private repo, so box will be always up to date
  check_finish_reboot "${FUNCNAME[0]}"
  #else
  #  echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
  #   echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  # fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}
# This one configuration hostname, network etc.
function configure_net() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local current_lan grub_count
    # Download this from git better
    if [ -d "${DATA_PATH}/maxisetup" ]; then
      # This is bind or bind setting called named.conf. If we put this first in /etc, when install bind it will use this setting
      # Bind setting is the same config for centos, debian
      echo "[${SCRIPT_NAME}]: Copying modified named.conf from maxisetup to /etc/named.conf ..." 2>&1 | tee -a "${REPORT_FILE}"
      cp "${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/etc/named.conf" /etc/named.conf
    else
      # This is weird error and should exit
      echo "[${SCRIPT_NAME}]: Warning no file named.conf found in maxisetup folder. Check maxisetup clone folder." 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    echo "[${SCRIPT_NAME}]: Configuring DA system email ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "${ROOT_EMAIL}" >/root/.email.txt #Root email will use this one
    echo "${ADMIN_EMAIL}" >/root/.forward  #Forward all email to admin (webmaster)
    echo "[${SCRIPT_NAME}]: Configuring network interface ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 2
    # Warning, LAN can have one or more
    current_lan=$(ip link | awk -F: '$0 !~ "lo|vir|wl|^[^0-9]"{print $2}' | sed 's/ //g')
    if [ "${current_lan}" != "${NIC_INTERFACE_NAME}" ]; then
      echo "[${SCRIPT_NAME}]: [Warning]: Current LAN interface is emulated with ${current_lan} but it was set as: ${NIC_INTERFACE_NAME}" 2>&1 | tee -a "${REPORT_FILE}"
      if [ "${NIC_INTERFACE_NAME}" == "eth0" ]; then
        echo "[${SCRIPT_NAME}]: Modifying grub file to disable interface name convention ..." 2>&1 | tee -a "${REPORT_FILE}"
        #sed -i 's/rhgb quiet/net.ifnames=0 biosdevname=0/' /etc/default/grub
        # This will not run if values exist
        grub_count=$(grep -Ec 'GRUB_CMDLINE_LINUX=.*net.ifnames|GRUB_CMDLINE_LINUX_DEFAULT=.*net.ifnames' /etc/default/grub)
        if [ "${grub_count}" -eq 0 ]; then
          grub_count=$(grep -Ec 'GRUB_CMDLINE_LINUX=""' /etc/default/grub)
          if [ "${grub_count}" -eq 0 ]; then
            echo "[${SCRIPT_NAME}]: Appending net.ifnames=0 for GRUB_CMDLINE_LINUX in /etc/default/grub ..." 2>&1 | tee -a "${REPORT_FILE}"
            sed -i 's/GRUB_CMDLINE_LINUX="[^"]*/& net.ifnames=0/' /etc/default/grub
          else
            # Adding new value (not appending)
            echo "[${SCRIPT_NAME}]: Adding new value net.ifnames=0 for GRUB_CMDLINE_LINUX in /etc/default/grub ..." 2>&1 | tee -a "${REPORT_FILE}"
            sed -i 's/GRUB_CMDLINE_LINUX=""/GRUB_CMDLINE_LINUX="net.ifnames=0"/g' /etc/default/grub
          fi
        else
          echo "[${SCRIPT_NAME}]: [Skipped]: The value 'biosdevname' has already set for GRUB_CMDLINE_LINUX or GRUB_CMDLINE_LINUX_DEFAULT in /etc/default/grub ..." 2>&1 | tee -a "${REPORT_FILE}"
        fi
        grub_count=$(grep -Ec 'GRUB_CMDLINE_LINUX=.*biosdevname|GRUB_CMDLINE_LINUX_DEFAULT=.*biosdevname' /etc/default/grub)
        if [ "${grub_count}" -eq 0 ]; then
          grub_count=$(grep -Ec 'GRUB_CMDLINE_LINUX=""' /etc/default/grub)
          if [ "${grub_count}" -eq 0 ]; then
            echo "[${SCRIPT_NAME}]: Appending biosdevname=0 for GRUB_CMDLINE_LINUX in /etc/default/grub ..." 2>&1 | tee -a "${REPORT_FILE}"
            sed -i 's/GRUB_CMDLINE_LINUX="[^"]*/& biosdevname=0/' /etc/default/grub
          else
            # Adding new value (not appending)
            echo "[${SCRIPT_NAME}]: Adding new value biosdevname=0 for GRUB_CMDLINE_LINUX in /etc/default/grub ..." 2>&1 | tee -a "${REPORT_FILE}"
            sed -i 's/GRUB_CMDLINE_LINUX=""/GRUB_CMDLINE_LINUX="biosdevname=0"/g' /etc/default/grub
          fi
        else
          echo "[${SCRIPT_NAME}]: [Skipped]: The value 'biosdevname' has already set for GRUB_CMDLINE_LINUX or GRUB_CMDLINE_LINUX_DEFAULT in /etc/default/grub ..." 2>&1 | tee -a "${REPORT_FILE}"
        fi
        sleep 1

        # Enabling serial terminal
        grub_count=$(grep -Ec 'GRUB_CMDLINE_LINUX=.*console|GRUB_CMDLINE_LINUX_DEFAULT=.*console' /etc/default/grub)
        if [ "${grub_count}" -eq 0 ]; then
          grub_count=$(grep -Ec 'GRUB_CMDLINE_LINUX=""' /etc/default/grub)
          if [ "${grub_count}" -eq 0 ]; then
            echo "[${SCRIPT_NAME}]: Appending console=ttyS0,19200n8 for GRUB_CMDLINE_LINUX in /etc/default/grub ..." 2>&1 | tee -a "${REPORT_FILE}"
            sed -i 's/GRUB_CMDLINE_LINUX="[^"]*/& console=ttyS0,19200n8/' /etc/default/grub
          else
            # Adding new value (not appending)
            echo "[${SCRIPT_NAME}]: Adding new value console=ttyS0,19200n8 for GRUB_CMDLINE_LINUX in /etc/default/grub ..." 2>&1 | tee -a "${REPORT_FILE}"
            sed -i 's/GRUB_CMDLINE_LINUX=""/GRUB_CMDLINE_LINUX="console=ttyS0,19200n8"/g' /etc/default/grub
          fi
        else
          echo "[${SCRIPT_NAME}]: [Skipped]: The value 'console' has already set for GRUB_CMDLINE_LINUX or GRUB_CMDLINE_LINUX_DEFAULT in /etc/default/grub ..." 2>&1 | tee -a "${REPORT_FILE}"
        fi
        sleep 1

        # Enabling serial terminal 1
        grub_count=$(grep -Ec '^GRUB_SERIAL_COMMAND=' /etc/default/grub)
        if [ "${grub_count}" -eq 0 ]; then
          echo "[${SCRIPT_NAME}]: No variable GRUB_SERIAL_COMMAND found in /etc/default/grub. Creating empty variable GRUB_SERIAL_COMMAND= ..." 2>&1 | tee -a "${REPORT_FILE}"
          echo "GRUB_SERIAL_COMMAND=\"\"" >>/etc/default/grub
        fi
        grub_count=$(grep -Ec 'GRUB_SERIAL_COMMAND=.*serial' /etc/default/grub)
        if [ "${grub_count}" -eq 0 ]; then
          grub_count=$(grep -Ec 'GRUB_SERIAL_COMMAND=""' /etc/default/grub)
          if [ "${grub_count}" -eq 0 ]; then
            # In case if this option need appending
            echo "[${SCRIPT_NAME}]: Appending serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1 for GRUB_SERIAL_COMMAND in /etc/default/grub ..." 2>&1 | tee -a "${REPORT_FILE}"
            sed -i 's/GRUB_SERIAL_COMMAND="[^"]*/& serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1/' /etc/default/grub
          else
            # Adding new value (not appending)
            echo "[${SCRIPT_NAME}]: Adding new value serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1 for GRUB_SERIAL_COMMAND in /etc/default/grub ..." 2>&1 | tee -a "${REPORT_FILE}"
            sed -i 's/GRUB_SERIAL_COMMAND=""/GRUB_SERIAL_COMMAND="serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1"/g' /etc/default/grub
          fi
        else
          echo "[${SCRIPT_NAME}]: [Skipped]: The value 'serial' has already set for GRUB_SERIAL_COMMAND in /etc/default/grub ..." 2>&1 | tee -a "${REPORT_FILE}"
        fi

        sleep 1

        # Enabling serial terminal 2
        grub_count=$(grep -Ec '^GRUB_TERMINAL=' /etc/default/grub)
        if [ "${grub_count}" -eq 0 ]; then
          echo "[${SCRIPT_NAME}]: No variable GRUB_TERMINAL found in /etc/default/grub. Creating empty variable GRUB_TERMINAL= ..." 2>&1 | tee -a "${REPORT_FILE}"
          echo "GRUB_TERMINAL=" >>/etc/default/grub
        fi
        grub_count=$(grep -Ec 'GRUB_TERMINAL=serial' /etc/default/grub)
        if [ "${grub_count}" -eq 0 ]; then
          # Adding new value (not appending)
          echo "[${SCRIPT_NAME}]: Adding new value GRUB_TERMINAL=serial for GRUB_TERMINAL in /etc/default/grub ..." 2>&1 | tee -a "${REPORT_FILE}"
          sed -i 's/GRUB_TERMINAL=/GRUB_TERMINAL=serial/g' /etc/default/grub
        else
          echo "[${SCRIPT_NAME}]: [Skipped]: The value 'serial' has already set for GRUB_TERMINAL in /etc/default/grub ..." 2>&1 | tee -a "${REPORT_FILE}"
        fi
        sleep 1

        echo "[${SCRIPT_NAME}]: Recompiling grub boot loader ..." 2>&1 | tee -a "${REPORT_FILE}"
        if [ "${DISTRO_ID}" == "centos" ]; then
          # Recompile grub centos command
          grub2-mkconfig -o /boot/grub2/grub.cfg 2>&1 | tee -a "${REPORT_FILE}"
          # Need to reboot here
        elif [ "${DISTRO_ID}" == "debian" ]; then
          # Recompile grub debian command
          grub-mkconfig -o /boot/grub/grub.cfg 2>&1 | tee -a "${REPORT_FILE}"
        else
          echo "[${SCRIPT_NAME}]: Error, unknown value for distribution ID ${DISTRO_ID}" 2>&1 | tee -a "${REPORT_FILE}"
          _exit 1
        fi
      else
        # Rename other interfaces here
        echo "[${SCRIPT_NAME}]: The new LAN interface is set to ${NIC_INTERFACE_NAME}" 2>&1 | tee -a "${REPORT_FILE}"
        # Or recommend to use screen
        echo "[${SCRIPT_NAME}]: Turning off current LAN interface for renaming ${current_lan} ..." 2>&1 | tee -a "${REPORT_FILE}"
        echo "[${SCRIPT_NAME}]: Warning, the network needs to be turned off in order to be able to rename to new LAN interface" 2>&1 | tee -a "${REPORT_FILE}"
        echo "[${SCRIPT_NAME}]: ** Warning, If you are on SSH, you will be disconnected from SSH" 2>&1 | tee -a "${REPORT_FILE}"
        echo "[${SCRIPT_NAME}]: *** Warning, you will not see the following operations and system will reboot automatically. You can re-run this script again to continue setup" 2>&1 | tee -a "${REPORT_FILE}"
        # Because the script reboot, we need to re-run this function to check if interface is already set like in the config file
        # TODO fix this with background process
        _pause
        ip link set "${current_lan}" down
        echo "[${SCRIPT_NAME}]: Renaming ${current_lan} to ${NIC_INTERFACE_NAME} ..." 2>&1 | tee -a "${REPORT_FILE}"
        sleep 1
        ip link set "${current_lan}" name "${NIC_INTERFACE_NAME}"
        echo "[${SCRIPT_NAME}]: Turning on the new LAN interface ${NIC_INTERFACE_NAME} ..." 2>&1 | tee -a "${REPORT_FILE}"
        sleep 1
        ip link set "${NIC_INTERFACE_NAME}" up
        echo "[${SCRIPT_NAME}]: Renaming interface file ifcfg-${current_lan} to ifcfg-${NIC_INTERFACE_NAME} ..." 2>&1 | tee -a "${REPORT_FILE}"
        sleep 1
        mv /etc/sysconfig/network-scripts/ifcfg-{"${current_lan}","${NIC_INTERFACE_NAME}"}
        _reboot
      fi
      # Changing this would require restart. So let's restart
      # Before restart we need to configure network first:
      configure_net2
      echo "[${SCRIPT_NAME}]: Creating required reboot flag for network interface to revert back to eth0 automatically after reboot ..." 2>&1 | tee -a "${REPORT_FILE}"
      cat /dev/null >/var/run/reboot-required
      sleep 1
    else
      echo "[${SCRIPT_NAME}]: [Skipped]: OK, current LAN interface name is same with NIC_INTERFACE_NAME from config file" 2>&1 | tee -a "${REPORT_FILE}"
    fi
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~"
  fi

}

# This would change like static IP, resolv.conf etc ...
# I prefer to use eth0 than a strange name like epn${x} but now this script can rename whatever interface you want
function configure_net2() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local old_host lh_count
    # So, at this stage we know our LAN would be ${NIC_INTERFACE_NAME} then we can insert network information directly into ${NIC_INTERFACE_NAME}
    if [ "${DISTRO_ID}" == "centos" ]; then
      # Create network static IP configuration
      echo "[${SCRIPT_NAME}]: Inserting CentOS static IP information for ${NIC_INTERFACE_NAME} at /etc/sysconfig/network-scripts/ifcfg-${NIC_INTERFACE_NAME} ..." 2>&1 | tee -a "${REPORT_FILE}"
      {
        echo "# ==============================================="
        echo "# This configuration file was generated by ${SCRIPT_NAME}"
        echo "# Author: ${ADMIN_NAME} | Email: ${ADMIN_EMAIL} | Web: ${BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# GENERAL DEVICE CONFIGURATION "
        echo 'TYPE="Ethernet"'
        echo "DEVICE=\"${NIC_INTERFACE_NAME}"\"
        echo "NAME=\"${NIC_INTERFACE_NAME}"\"
        echo 'ONBOOT="yes"'
        echo 'BOOTPROTO="none"'
        echo 'PEERDNS="no"'
        # This will generate new UUID for "${NIC_INTERFACE_NAME}"
        echo "UUID=$(uuidgen "${NIC_INTERFACE_NAME}")"
        echo "DOMAIN=${BOX_DOMAIN}"
        echo ""
        echo "# IPv4 Configuration (Public)"
        echo 'IPV4_FAILURE_FATAL="no"'
        echo 'DEFROUTE="yes"'
        echo "IPADDR0=${IPV4_ADD0}"
        echo "GATEWAY0=${IPV4_DEF_GATEWAY0}"
        echo "PREFIX0=24"
        echo ""
        echo "# IPv4 Configuration (Private)"
        echo '# IPADDR2=""'
        echo "# PREFIX2=17"
        echo ""
        echo "# IPv6 Configuration (Public)"
        echo 'IPV6INIT="yes"'
        echo 'IPV6_AUTOCONF="yes"'
        echo 'IPV6_DEFROUTE="yes"'
        echo 'IPV6_FAILURE_FATAL="no"'
        echo 'IPV6_ADDR_GEN_MODE="stable-privacy"'
        echo '#IPV6_ADDR_GEN_MODE="eui64"'
        echo "IPV6ADDR=${IPV6_ADD0}/64"
        echo "IPV6_DEFAULTGW=${IPV6_DEF_GATEWAY0}"
        echo 'IPV6_PRIVACY="no"'
        echo ""
        echo "# resolvconf - doesn't recognize more than 3 nameservers. (IPv4 & IPv6)"
        echo "DNS1=${NAME_SERVER1}"
        echo "DNS2=${NAME_SERVER2}"
        echo "DNS3=${NAME_SERVER3}"
      } >"/etc/sysconfig/network-scripts/ifcfg-${NIC_INTERFACE_NAME}"
    elif [ "${DISTRO_ID}" == "debian" ]; then
      echo "[${SCRIPT_NAME}]: Inserting Debian static IP information for ${NIC_INTERFACE_NAME} at /etc/network/interfaces ..." 2>&1 | tee -a "${REPORT_FILE}"
      {
        echo "# ==============================================="
        echo "# This configuration file was generated by ${SCRIPT_NAME}"
        echo "# Author: ${ADMIN_NAME} | Email: ${ADMIN_EMAIL} | Web: ${BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# This file describes the network interfaces available on your system"
        echo "# and how to activate them. For more information, see interfaces(5)."
        echo ""
        echo "source /etc/network/interfaces.d/*"
        echo ""
        echo "# The loopback network interface"
        echo "auto lo"
        echo "iface lo inet loopback"
        echo ""
        echo "# auto ${NIC_INTERFACE_NAME} is needed to configure static IP for both IPv4 and IPv6"
        echo "auto ${NIC_INTERFACE_NAME}"
        echo "# IPv4 Configuration (Public)"
        echo "iface ${NIC_INTERFACE_NAME} inet static"
        echo "address ${IPV4_ADD0}/24"
        echo "gateway ${IPV4_DEF_GATEWAY0}"
        echo ""
        echo "# IPv6 Configuration (Public)"
        echo "iface ${NIC_INTERFACE_NAME} inet6 static"
        echo "address ${IPV6_ADD0}/64"
        echo "gateway ${IPV6_DEF_GATEWAY0}"
      } >/etc/network/interfaces
      # Disabling Ipv6 DAD: https://www.agwa.name/blog/post/beware_the_ipv6_dad_race_condition
      # Another way is to use this sysctl -w net.ipv6.conf.eth0.dad_transmits=0 or put in /etc/sysctl for permanent
      # Why disable? Because nginx sometimes cannot start with ipv6 unless system is restarted
      if [ -f "/proc/sys/net/ipv6/conf/${NIC_INTERFACE_NAME}/accept_dad" ]; then
        {
          echo "# Disable IPv6 Duplicate Address Detection"
          echo "pre-up echo 0 > /proc/sys/net/ipv6/conf/${NIC_INTERFACE_NAME}/accept_dad"
        } >>/etc/network/interfaces
      fi
    else
      echo "[${SCRIPT_NAME}]: Error, unknown value for distribution ID ${DISTRO_ID}" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi

    # This insertion works for both centos and debian so there is no need to put OS condition
    echo "[${SCRIPT_NAME}]: Inserting name server information in /etc/resolv.conf ..." 2>&1 | tee -a "${REPORT_FILE}"
    {
      echo "# ==============================================="
      echo "# This configuration file was generated by ${SCRIPT_NAME}"
      echo "# Author: ${ADMIN_NAME} | Email: ${ADMIN_EMAIL} | Web: ${BOX_DOMAIN}"
      echo "# ==============================================="
      echo "search ${BOX_DOMAIN}"
      echo "domains ${BOX_HOSTNAME_FQDN}"
      echo "options rotate"
      echo "nameserver ${NAME_SERVER1}"
      echo "nameserver ${NAME_SERVER2}"
      echo "nameserver ${NAME_SERVER3}"
    } >/etc/resolv.conf

    echo "[${SCRIPT_NAME}]: Configuring DNS IPs in /etc/hosts ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    old_host=$(hostname --fqdn)
    if [ "${old_host}" = "" ]; then
      old_host=old.host.com
      echo "[${SCRIPT_NAME}]: old hostname was blank. This is a placeholder value ${old_host}"
    fi
    #remove any previous hostnames.
    grep -Fv "${BOX_HOSTNAME}" /etc/hosts | grep -Fv ${old_host} | grep -v '#' >/etc/hosts.tmp

    #start the file over
    {
      echo "# ==============================================="
      echo "# This configuration file was generated by ${SCRIPT_NAME}"
      echo "# Author: ${ADMIN_NAME} | Email: ${ADMIN_EMAIL} | Web: ${BOX_DOMAIN}"
      echo "# ==============================================="
      echo "# Do not remove the following line, or various programs"
      echo "# that require network functionality will fail."
    } >/etc/hosts

    lh_count=$(grep -c localhost /etc/hosts.tmp)
    if [ "${lh_count}" -lt 1 ]; then
      echo -e "127.0.0.1\t\tlocalhost localhost.localdomain" >>/etc/hosts
    fi
    echo "[${SCRIPT_NAME}]: Adding IP (IPv4) and (IPv6) and entries in /etc/hosts ..." 2>&1 | tee -a "${REPORT_FILE}"
    {
      cat /etc/hosts.tmp
      echo ""
      echo "#IP information for ${BOX_HOSTNAME_FQDN}:"
      printf '%s\t%s\t%s\n' "${IPV4_ADD0}" "${BOX_HOSTNAME_FQDN}" "${BOX_HOSTNAME}"
      printf '%s\t%s\t%s\n' "${IPV6_ADD0}" "${BOX_HOSTNAME_FQDN}" "${BOX_HOSTNAME}"
    } >>/etc/hosts
    chmod 644 /etc/hosts
    # When using a VPS that use auto network manager, it will keep replacing this hosts file.
    # So, we don't want anyone to disturb this beautiful written host file by using chattr +i on this file
    # Note directadmin setup also trying to modify this /etc/hosts file during setup using its script called: /usr/local/directadmin/scripts/hostname.sh
    # It will get an error operation not permitted but do not worry because /etc/hosts is correctly configured now.
    echo "[${SCRIPT_NAME}]: Preventing /etc/hosts modification by setting chattr +i immutable" 2>&1 | tee -a "${REPORT_FILE}"
    chattr +i /etc/hosts
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_fstab() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then

    # Only do this if DISK_ENCRYPTION is set
    is_encrypted=$(lsblk | grep 'crypt')
    if [ -n "${is_encrypted}" ]; then
      echo "Found disk encryption is set: ${is_encrypted}"
      DISK_ENCRYPTION="yes"
    else
      echo "No disk encryption partition is found!"
      DISK_ENCRYPTION="no"
    fi
    if [ "${DISK_ENCRYPTION}" == "yes" ]; then
      local disk_uuid_boot
      echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
      # Boot must always be sda 1  (beginning of the drive)
      disk_uuid_boot=$(blkid -o value -s UUID "/dev/sda1")
      {
        echo "# ==============================================="
        echo "# This configuration file was generated by ${SCRIPT_NAME}"
        echo "# Author: ${ADMIN_NAME} | Email: ${ADMIN_EMAIL} | Web: ${BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# /etc/fstab: static file system information."
        echo "#"
        echo "# Use 'blkid' to print the universally unique identifier for a"
        echo "# device; this may be used with UUID= as a more robust way to name devices"
        echo "# that works even if disks are added and removed. See fstab(5)."
        echo "#"
        echo "# <file system> <mount point>   <type>  <options>       <dump>  <pass>"
        # Boot mount option
        printf "UUID=%s\t/boot\text4\tdefaults\t0\t2\n" "${disk_uuid_boot}"
        printf "/dev/mapper/%s-root\t/\text4\terrors=remount-ro,usrquota,grpquota,x-systemd.device-timeout=0\t0\t1\n" "${LVM_VOLUME_GROUP}"
        printf "/dev/mapper/%s-home\t/home\text4\tnosuid,x-systemd.device-timeout=0\t0\t2\n" "${LVM_VOLUME_GROUP}"
        printf "/dev/mapper/%s-tmp\t/tmp\text4\tnodev,nosuid,noexec,x-systemd.device-timeout=0\t0\t2\n" "${LVM_VOLUME_GROUP}"
        printf "/dev/mapper/%s-swap\tnone\tswap\tsw,x-systemd.device-timeout=0\t0\t0\n" "${LVM_VOLUME_GROUP}"
      } >/etc/fstab
      check_finish_reboot "${FUNCNAME[0]}"
    else
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning, disk encryption is not set in maxisetup.conf" 2>&1 | tee -a "${REPORT_FILE}"
      echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
    fi
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_grub() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    local gr grub_hash pfile
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    if [ "${SECURE_GRUB}" == "yes" ]; then
      echo "[${SCRIPT_NAME}]: SECURE_GRUB is set" 2>&1 | tee -a "${REPORT_FILE}"
      pfile="${TEMP_PATH}/pfile.$(get_rnd_alpha 10)"
      cat <<EOF >"${pfile}"
${GRUB_PASS}
${GRUB_PASS}
EOF
      grub_hash=$(cat "${pfile}" | grub-mkpasswd-pbkdf2 | awk '/grub.pbkdf/{print$NF}')
      shred -uvz "${pfile}"
      gr=$(grep -i "password_pbkdf2" /etc/grub.d/00_header)
      if [[ -z ${gr} ]]; then
        echo "[${SCRIPT_NAME}]: Writing grub username and password in /etc/grub.d/00_header ... " 2>&1 | tee -a "${REPORT_FILE}"
        {
          echo "cat << EOF"
          echo "set superusers=\"${GRUB_UNAME}\""
          echo "password_pbkdf2 ${GRUB_UNAME} ${grub_hash}"
          echo "EOF"
        } >>/etc/grub.d/00_header
        grub-mkconfig -o /boot/grub/grub.cfg
        #sudo update-grub
      else
        echo "[${SCRIPT_NAME}]: Warning, there is already a grub password set in /etc/grub.d/00_header. It shouldn't be there. Inspect why" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi
    else
      echo "[${SCRIPT_NAME}]: Warning, SECURE_GRUB is not set" 2>&1 | tee -a "${REPORT_FILE}"

    fi
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
}

# Tweaking swap for production
function configure_sysctl_swap() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Configuring disk swap information in sysctl ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    # Swap configuration
    {
      echo "vm.swappiness = 10"
      echo "vm.vfs_cache_pressure = 50"
    } >>/etc/sysctl.conf
    sysctl -p /etc/sysctl.conf
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_sysctl_kernel_fs() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Configuring kernel and file system information in sysctl ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    {
      # Disable core dumps
      # This code will ensure not to make any core dumps by setuid programs in future.
      echo "fs.suid_dumpable = 0"
      # Disable System Request debugging functionality
      echo "kernel.sysrq = 0"
      # Hide kernel pointers
      echo "kernel.kptr_restrict = 2"
    } >>/etc/sysctl.conf
    sysctl -p /etc/sysctl.conf
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_sysctl_ips() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Configuring ipv4 and ipv6 information in sysctl ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    {
      echo "# IPV4 & IPv6 configuration"
      echo "# IPV6"
      echo "net.ipv6.conf.all.disable_ipv6 = 0"
      echo "net.ipv6.conf.default.disable_ipv6 = 0"
      echo "#net.ipv6.conf.lo.disable_ipv6 = 0"
      echo "#net.ipv6.bindv6only = 1"
      echo "net.ipv6.conf.default.accept_redirects = 0"
      echo "net.ipv6.conf.all.accept_redirects = 0"
      # Disable IPv6 DAD in kernel
      echo "net.ipv6.conf.${NIC_INTERFACE_NAME}.dad_transmits = 0"
      echo "#IPV4"
      echo "net.ipv4.conf.all.accept_redirects = 0"
      echo "net.ipv4.conf.all.log_martians = 1"
      echo "net.ipv4.conf.all.send_redirects = 0"
      echo "net.ipv4.conf.default.accept_redirects = 0"
      echo "net.ipv4.conf.default.log_martians = 1"
      echo "#net.ipv6.tcp_timestamps = 0"

      echo "# Enable TCP SYN cookie protection"
      echo "net.ipv4.tcp_syncookies = 1"

      echo "# Turn off the tcp_sack"
      echo "#net.ipv4.tcp_sack = 0"

      echo "# Turn off the tcp_window_scaling"
      echo "#net.ipv4.tcp_window_scaling = 0"

      echo "### Enable this when DDOS attack occur ###"
      echo "# Decrease the time default value for tcp_fin_timeout connection"
      echo "#net.ipv4.tcp_fin_timeout = 3"
    } >>/etc/sysctl.conf
    sysctl -p /etc/sysctl.conf
    check_finish_reboot "${FUNCNAME[0]}"
    # No need to reboot. Just run sysctl -p is enough
    # echo "[${SCRIPT_NAME}]: Finished configuring network profile. You may reboot the system then re-run this script again for next setup ..." 2>&1 | tee -a "${REPORT_FILE}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}
# Install missing os requirement, such as sendmail
function upgrade_os() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    # General OS upgrade
    if [ "${DISTRO_ID}" == "centos" ]; then
      echo "[${SCRIPT_NAME}]: Updating CentOS system ..." 2>&1 | tee -a "${REPORT_FILE}"
      sudo dnf -y update 2>&1 | tee -a "${REPORT_FILE}"
      sudo dnf -y install epel-release 2>&1 | tee -a "${REPORT_FILE}"
      # Remember now use powertools not PowerTools. This is bug found in CentOS repo 2 days ago: https://bugs.centos.org/view.php?id=17920
      dnf config-manager --set-enabled powertools 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${DISTRO_ID}" == "debian" ]; then

      # Known usability bug from Debian installer with old grub-pc
      # Fixed grub-pc appear interactive GUI when running dist-upgrade https://github.com/hashicorp/vagrant/issues/289
      # This is the Debian usability bug for grub as explained in here:
      # https://askubuntu.com/questions/23418/what-do-i-select-for-grub-install-devices-after-an-update#comment837055_23418
      # This only show when you have kernel set to GRUB 2

      echo "[${SCRIPT_NAME}]: Updating Debian system ..." 2>&1 | tee -a "${REPORT_FILE}"

      apt-get -y update
      apt-get -y dist-upgrade
      apt-get -y autoremove
      apt clean
    else
      echo "[${SCRIPT_NAME}]: Error, unknown value for distribution ID ${DISTRO_ID}" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi

    # Install other components based on installation type and distribution:
    if [ "${INSTALL_TYPE}" == "general" ]; then
      if [ "${DISTRO_ID}" == "centos" ]; then
        echo "[${SCRIPT_NAME}]: Installing system required components for CentOS General setup ..." 2>&1 | tee -a "${REPORT_FILE}"

        sudo dnf -y install sendmail tar bind-utils git curl gcc make libevent-devel zlib-devel openssl-devel pcre2-devel wget 2>&1 | tee -a "${REPORT_FILE}"
        sudo dnf -y install bc htop ncdu 2>&1 | tee -a "${REPORT_FILE}"
        echo "[${SCRIPT_NAME}]: Installing perl dependencies ..." 2>&1 | tee -a "${REPORT_FILE}"
        sudo dnf -y install @perl perl-libwww-perl net-tools perl-LWP-Protocol-https 2>&1 | tee -a "${REPORT_FILE}"

      elif [ "${DISTRO_ID}" == "debian" ]; then
        echo "[${SCRIPT_NAME}]: Installing system required components for Debian General setup ..." 2>&1 | tee -a "${REPORT_FILE}"
        apt-get -y install curl 2>&1 | tee -a "${REPORT_FILE}" # Needed especially to download lynis latest version
        apt-get -y install sudo 2>&1 | tee -a "${REPORT_FILE}" # By default no sudo is installed
      else
        echo "[${SCRIPT_NAME}]: Error, unknown value for distribution ID ${DISTRO_ID}" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi
    elif [ "${INSTALL_TYPE}" == "directadmin" ]; then
      if [ "${DISTRO_ID}" == "centos" ]; then
        echo "[${SCRIPT_NAME}]: Installing system required components for CentOS Directadmin setup ..." 2>&1 | tee -a "${REPORT_FILE}"
        : # will determine (but RIP CentOS)
      elif [ "${DISTRO_ID}" == "debian" ]; then
        echo "[${SCRIPT_NAME}]: Installing system required components for Debian Directadmin setup ..." 2>&1 | tee -a "${REPORT_FILE}"
        echo "[${SCRIPT_NAME}]: Installing wget on Debian ... " 2>&1 | tee -a "${REPORT_FILE}"
        apt-get -y install wget 2>&1 | tee -a "${REPORT_FILE}"
        echo "[${SCRIPT_NAME}]: Installing ipv6calc for IPv6 conversion on Debian ..." 2>&1 | tee -a "${REPORT_FILE}"
        apt-get -y install ipv6calc 2>&1 | tee -a "${REPORT_FILE}"
        apt-get -y install curl 2>&1 | tee -a "${REPORT_FILE}" # Needed especially to download lynis latest version
        apt-get -y install sudo 2>&1 | tee -a "${REPORT_FILE}" # By default no sudo is installed
      else
        echo "[${SCRIPT_NAME}]: Error, unknown value for distribution ID ${DISTRO_ID}" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi

    fi
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# Install CSF Firewall
configure_csf() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    # If DA INSTALL TYPE IS auto don't run this because it will install CSF automatically (as stated in documentation)
    local gc ipv4_tcp_in ipv4_tcp_out ipv6_tcp_in ipv6_tcp_out all_allow_ports kernel_numericver
    local bl_ip_html_source bl_ip_html_dest gc retval
    if [ "${DA_INSTALL_TYPE}" != "auto" ]; then
      if ! command -v csf &>/dev/null; then
        echo "[${SCRIPT_NAME}]: No CSF binary is found (CSF is not installed)" 2>&1 | tee -a "${REPORT_FILE}"
        sleep 2
        if [ "${INSTALL_TYPE}" == "general" ]; then
          echo "[${SCRIPT_NAME}]: Script installation type is set to 'general'. Installing and Setting up CSF for ${BOX_HOSTNAME_FQDN} ..." 2>&1 | tee -a "${REPORT_FILE}"
          sleep 2
          echo "[${SCRIPT_NAME}]: Removing existing CSF if exist using built-in script ..." 2>&1 | tee -a "${REPORT_FILE}"
          sh /etc/csf/uninstall.sh
          echo "[${SCRIPT_NAME}]: Removing previous downloaded file ..." 2>&1 | tee -a "${REPORT_FILE}"
          rm -fv "${INST_TEMP_DIR}/csf.tgz"
          cd_to_path "${INST_TEMP_DIR}"
          echo "[${SCRIPT_NAME}]: Downloading and extracting CSF file in ${INST_TEMP_DIR} ..." 2>&1 | tee -a "${REPORT_FILE}"
          curl -SL https://download.configserver.com/csf.tgz | tar -xzf - 2>&1 | tee -a "${REPORT_FILE}"
          # Now after extracted we have csf folder, let's enter to this path
          cd_to_path "./csf"

          echo "[${SCRIPT_NAME}]: Testing CSF pre-installation requirement ..." 2>&1 | tee -a "${REPORT_FILE}"
          gc=$(./csftest.pl | tail -n 1 | grep -c 'RESULT: csf should function on this server')
          if [ "${gc}" != "1" ]; then
            ./csftest.pl
            echo ""
            echo ""
            echo "CSF test did not pass. Will not continue. Solve the issue and rerun this script again"
            _exit 2
          else
            echo "[OK]: CSF test passed!"
          fi

          echo "[${SCRIPT_NAME}]: Now installing CSF ..." 2>&1 | tee -a "${REPORT_FILE}"
          chmod +x install.sh
          sh "install.sh"
          # When finished, we go back to original path

          # CSF recommends to disable and remove APF+BFD (if exist). Check APF:
          echo "[${SCRIPT_NAME}]: Checking and removing existing APF+BFD (recommended) ..." 2>&1 | tee -a "${REPORT_FILE}"
          if command -v apf &>/dev/null; then
            echo "[${SCRIPT_NAME}]: Warning, Found apf command. Removing apf bfd with remove_apf_bfd.sh ..." 2>&1 | tee -a "${REPORT_FILE}"
            #sh /usr/local/csf/bin/disable_apf_bfd.sh #Script disabled because not found in the csf bin folder
            sh /usr/local/csf/bin/remove_apf_bfd.sh
          else
            echo "[${SCRIPT_NAME}]: [Skipped]: OK, No existing APF+BFD installation to remove" 2>&1 | tee -a "${REPORT_FILE}"
          fi
        elif [ "${INSTALL_TYPE}" == "directadmin" ]; then
          echo "[${SCRIPT_NAME}]: Script installation type is set to DIRECTADMIN. Installing CSF on ${BOX_HOSTNAME_FQDN} using DA script by Poralix..." 2>&1 | tee -a "${REPORT_FILE}"
          sleep 2
          #wget http://files.directadmin.com/services/all/csf/csf_install.sh 2>&1 | tee -a "${REPORT_FILE}"
          cd_to_path "${INST_TEMP_DIR}"
          cp "${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/usr/local/directadmin/install_scripts/csf_install.sh" "${INST_TEMP_DIR}/csf_install.sh"
          chmod +x csf_install.sh
          /bin/sh ./csf_install.sh 2>&1 | tee -a "${REPORT_FILE}"
        fi
      else
        echo "[${SCRIPT_NAME}]: Found CSF binary (CSF already installed). Continuing setup ..." 2>&1 | tee -a "${REPORT_FILE}"
      fi
      # After install CSF definitely we got this
      if [ -f /etc/csf/csf.conf ]; then
        echo "[${SCRIPT_NAME}]: Now configuring CSF config at /etc/csf/csf.conf ..." 2>&1 | tee -a "${REPORT_FILE}"
        sleep 1
        # This also must have comma,
        if [ -n "${CSF_EXTRA_ALLOW_PORTS}" ]; then
          all_allow_ports=",${DA_PORT},${CSF_EXTRA_ALLOW_PORTS}"
        else
          all_allow_ports=",${DA_PORT}"
        fi
        echo "DEBUG: all_allow_ports=${all_allow_ports}"
        grep -wq "^TCP_IN = .*${all_allow_ports}" /etc/csf/csf.conf
        if [ $? = 1 ]; then
          echo "[${SCRIPT_NAME}]: Adding extra port(s) ${all_allow_ports} in CSF firewall in CSF for TCP_IN ..." 2>&1 | tee -a "${REPORT_FILE}"
          ipv4_tcp_in=$(grep -i '^TCP_IN' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep="${all_allow_ports}" '{ print $1 ep }')
          sed -i "s/TCP_IN = .*/TCP_IN = \"${ipv4_tcp_in}\"/" /etc/csf/csf.conf
        else
          echo "[${SCRIPT_NAME}]: [Skipped]: Extra port(s) ${all_allow_ports} has already added in CSF for TCP_IN before" 2>&1 | tee -a "${REPORT_FILE}"
        fi
        grep -wq "^TCP_OUT = .*${all_allow_ports}" /etc/csf/csf.conf
        if [ $? = 1 ]; then
          echo "[${SCRIPT_NAME}]: Adding extra port(s) ${all_allow_ports} in CSF firewall in CSF for TCP_OUT ..." 2>&1 | tee -a "${REPORT_FILE}"
          ipv4_tcp_out=$(grep -i '^TCP_OUT' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep="${all_allow_ports}" '{ print $1 ep }')
          sed -i "s/TCP_OUT = .*/TCP_OUT = \"${ipv4_tcp_out}\"/" /etc/csf/csf.conf
        else
          echo "[${SCRIPT_NAME}]: [Skipped]: Extra port(s) ${all_allow_ports} has already added in CSF for TCP_OUT before" 2>&1 | tee -a "${REPORT_FILE}"
        fi
        grep -wq "^TCP6_IN = .*${all_allow_ports}" /etc/csf/csf.conf
        if [ $? = 1 ]; then
          echo "[${SCRIPT_NAME}]: Adding extra port(s) ${all_allow_ports} in CSF firewall in CSF for TCP6_IN ..." 2>&1 | tee -a "${REPORT_FILE}"
          ipv6_tcp_in=$(grep -i '^TCP6_IN' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep="${all_allow_ports}" '{ print $1 ep }')
          sed -i "s/TCP6_IN = .*/TCP6_IN = \"${ipv6_tcp_in}\"/" /etc/csf/csf.conf
        else
          echo "[${SCRIPT_NAME}]: [Skipped]: Extra port(s) ${all_allow_ports} has already added in CSF for TCP6_IN before" 2>&1 | tee -a "${REPORT_FILE}"
        fi
        grep -wq "^TCP6_OUT = .*${all_allow_ports}" /etc/csf/csf.conf
        if [ $? = 1 ]; then
          echo "[${SCRIPT_NAME}]: Adding extra port(s) ${all_allow_ports} in CSF firewall in CSF for TCP6_OUT ..." 2>&1 | tee -a "${REPORT_FILE}"
          ipv6_tcp_out=$(grep -i '^TCP6_OUT' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep="${all_allow_ports}" '{ print $1 ep }')
          sed -i "s/TCP6_OUT = .*/TCP6_OUT = \"${ipv6_tcp_out}\"/" /etc/csf/csf.conf
        else
          echo "[${SCRIPT_NAME}]: [Skipped]: Extra port(s) ${all_allow_ports} has already added in CSF for TCP6_OUT before" 2>&1 | tee -a "${REPORT_FILE}"
        fi
        # Disable CSF testing mode
        echo "[${SCRIPT_NAME}]: Disabling CSF testing mode ..." 2>&1 | tee -a "${REPORT_FILE}"
        sed -i 's/TESTING = "1"/TESTING = "0"/g' /etc/csf/csf.conf
        #echo "[${SCRIPT_NAME}]: Setting CONNLIMIT and PORTFLOOD best setting ..." 2>&1 | tee -a "${REPORT_FILE}"
        #sed -i 's/CONNLIMIT = ""/CONNLIMIT = "22;5,80;20,443;20"/g' /etc/csf/csf.conf
        #sed -i 's/PORTFLOOD = ""/PORTFLOOD = "22;tcp;5;300,80;tcp;20;5,443;tcp;20;5"/g' /etc/csf/csf.conf
        echo "[${SCRIPT_NAME}]: Enabling CSF email alert from 0 to 1 ..." 2>&1 | tee -a "${REPORT_FILE}"
        sed -i 's/LF_SSH_EMAIL_ALERT = "0"/LF_SSH_EMAIL_ALERT = "1"/g' /etc/csf/csf.conf
        echo "[${SCRIPT_NAME}]: Setting CSF email alert to ${ADMIN_EMAIL} ..." 2>&1 | tee -a "${REPORT_FILE}"
        sed -i "s/LF_ALERT_TO = .*/LF_ALERT_TO = '\"${ADMIN_EMAIL}\"'/" /etc/csf/csf.conf
        echo "[${SCRIPT_NAME}]: Enabling CSF SMTP_BLOCK ..." 2>&1 | tee -a "${REPORT_FILE}"
        sed -i 's/SMTP_BLOCK = "0"/SMTP_BLOCK = "1"/g' /etc/csf/csf.conf
        echo "[${SCRIPT_NAME}]: Setting CSF RESTRICT_SYSLOG from 0 to 3 to avoid warning ..." 2>&1 | tee -a "${REPORT_FILE}"
        sed -i 's/RESTRICT_SYSLOG = "0"/RESTRICT_SYSLOG = "3"/g' /etc/csf/csf.conf
        echo "[${SCRIPT_NAME}]: Setting CSF SYSLOG_CHECK to ${CSF_SYSLOG_CHECK} ..." 2>&1 | tee -a "${REPORT_FILE}"
        sed -i "s/SYSLOG_CHECK = .*/SYSLOG_CHECK = '\"${CSF_SYSLOG_CHECK}\"'/" /etc/csf/csf.conf
        sleep 1
        echo "[${SCRIPT_NAME}]: Testing CSF after installation ..." 2>&1 | tee -a "${REPORT_FILE}"
        echo "" 2>&1 | tee -a "${REPORT_FILE}"
        perl /usr/local/csf/bin/csftest.pl 2>&1 | tee -a "${REPORT_FILE}"
        echo "" 2>&1 | tee -a "${REPORT_FILE}"
        echo "[${SCRIPT_NAME}]: Setting CSF PT_LOAD_ACTION ..." 2>&1 | tee -a "${REPORT_FILE}"
        sed -i "s/^PT_LOAD_ACTION = .*/PT_LOAD_ACTION = \"\/usr\/local\/maxicode\/maxicsf\/csfload\"/" /etc/csf/csf.conf
        echo "[${SCRIPT_NAME}]: Setting CSF to send security alert to ${ADMIN_EMAIL} ..." 2>&1 | tee -a "${REPORT_FILE}"
        csf -m "${ADMIN_EMAIL}" 2>&1 | tee -a "${REPORT_FILE}"

        echo "[${SCRIPT_NAME}]: Enabling IPSET large IP for CSF ..." 2>&1 | tee -a "${REPORT_FILE}"
        # inspired by: https://community.centminmod.com/threads/what-should-be-the-right-value-for-lf_ipset-on-csf-config.2045/
        kernel_numericver=$(uname -r | awk -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }')
        # shellcheck disable=SC2143
        if [[ ! -f /proc/user_beancounters ]] && [[ "$(uname -r | grep linode)" || "$(find "/lib/modules/$(uname -r)" -name 'ipset')" ]] || [[ -f /proc/user_beancounters && "${kernel_numericver}" -ge '3000000000' ]]; then
          if [[ ! -f /usr/sbin/ipset ]]; then
            if [ "${DISTRO_ID}" == "centos" ]; then
              yum -q -y install ipset ipset-devel
            elif [ "${DISTRO_ID}" == "debian" ]; then
              sudo apt-get install ipset -y
            fi
            sed -i 's/LF_IPSET = \"0\"/LF_IPSET = \"1\"/' /etc/csf/csf.conf
          elif [[ -f /usr/sbin/ipset ]]; then
            sed -i 's/LF_IPSET = \"0\"/LF_IPSET = \"1\"/' /etc/csf/csf.conf
          fi
        fi
        # Increase block limit from 200 to 2500 (specified in config)
        echo "[${SCRIPT_NAME}]: Setting CSF DENY_IP_LIMIT to ${CSF_DENY_IP_LIMIT} ..." 2>&1 | tee -a "${REPORT_FILE}"
        sed -i "s/DENY_IP_LIMIT = .*/DENY_IP_LIMIT = '\"${CSF_DENY_IP_LIMIT}\"'/" /etc/csf/csf.conf
        # CSF Messenger: TODO haven't tested this messenger
        echo "[${SCRIPT_NAME}]: Enabling CSF Messenger ..." 2>&1 | tee -a "${REPORT_FILE}"
        sleep 1
        sed -i "s/MESSENGER = \"0\"/MESSENGER = \"1\"/" /etc/csf/csf.conf
        echo "[${SCRIPT_NAME}]: Inserting CSF RECAPTCHA_SITEKEY ..." 2>&1 | tee -a "${REPORT_FILE}"
        sleep 1
        sed -i "s/RECAPTCHA_SITEKEY = \"\"/RECAPTCHA_SITEKEY = \"${GOOGLE_RECAPTCHA_SITE_V2}\"/" /etc/csf/csf.conf
        echo "[${SCRIPT_NAME}]: Inserting CSF RECAPTCHA_SECRET ..." 2>&1 | tee -a "${REPORT_FILE}"
        sleep 1
        sed -i "s/RECAPTCHA_SECRET = \"\"/RECAPTCHA_SECRET = \"${GOOGLE_RECAPTCHA_SECRET_V2}\"/" /etc/csf/csf.conf
        echo "[${SCRIPT_NAME}]: Adding csf user in the system ..." 2>&1 | tee -a "${REPORT_FILE}"
        useradd csf -s /bin/false 2>&1 | tee -a "${REPORT_FILE}"
        echo "[${SCRIPT_NAME}]: Setting up CSF firewall blacklist template ..." 2>&1 | tee -a "${REPORT_FILE}"
        mkdir -p /usr/local/directadmin/data/templates/custom
        bl_ip_html_source="${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/usr/local/directadmin/data/templates/custom/blacklisted_ip.html"
        bl_ip_html_dest="/usr/local/directadmin/data/templates/custom/blacklisted_ip.html"
        cp -r "${bl_ip_html_source}" "${bl_ip_html_dest}"
        chmod 644 "${bl_ip_html_dest}"
        chown diradmin:diradmin "${bl_ip_html_dest}"
        echo "[${SCRIPT_NAME}]: Starting CSF and LFD for the first time ..." 2>&1 | tee -a "${REPORT_FILE}"
        echo "[${SCRIPT_NAME}]: Before we start it up, please confirm that your sshd port is listed in this output:" 2>&1 | tee -a "${REPORT_FILE}"
        echo "-----------------" 2>&1 | tee -a "${REPORT_FILE}"
        grep ^TCP_IN /etc/csf/csf.conf 2>&1 | tee -a "${REPORT_FILE}"
        echo "" 2>&1 | tee -a "${REPORT_FILE}"
        echo "If you do NOT see the port listed, press ctrl-c to immediately abort the script (you can add port missing port in maxisetup.conf), then re-run this setup" 2>&1 | tee -a "${REPORT_FILE}"
        echo "If you DO, the port correctly added, press enter to continue" 2>&1 | tee -a "${REPORT_FILE}"
        _pause 60
        if [ "${DISTRO_ID}" == "centos" ]; then
          echo "[${SCRIPT_NAME}]: Disabling built-in firewall (firewalld) in CentOS ..." 2>&1 | tee -a "${REPORT_FILE}"
          systemctl disable firewalld 2>&1 | tee -a "${REPORT_FILE}"
          systemctl stop firewalld 2>&1 | tee -a "${REPORT_FILE}"
        elif [ "${DISTRO_ID}" == "debian" ]; then
          echo "[${SCRIPT_NAME}]: Disabling and removing firewall (ufw) in Debian ..." 2>&1 | tee -a "${REPORT_FILE}"
          sudo ufw disable 2>&1 | tee -a "${REPORT_FILE}"
          sudo apt-get -y remove ufw
          sudo apt-get -y purge ufw
        else
          echo "[${SCRIPT_NAME}]: Error, unknown value for distribution ID ${DISTRO_ID}" 2>&1 | tee -a "${REPORT_FILE}"
          _exit 1
        fi
        echo "-----------------" 2>&1 | tee -a "${REPORT_FILE}"
        echo "[${SCRIPT_NAME}]: Starting CSF ..." 2>&1 | tee -a "${REPORT_FILE}"
        systemctl start csf 2>&1 | tee -a "${REPORT_FILE}"
        # Fix that here
        check_fix_service "csf"
        # By default behaviour, LFD should start automatically when we run csf start
        # service lfd start 2>&1 | tee -a "${REPORT_FILE}"
        check_fix_service "lfd"
        # This is a temporary allowed IP during setup which won't be blocked by firewall.
        echo "[${SCRIPT_NAME}]: Temporarily allow IP ${TEMP_ALLOW_IP} in /etc/etc/csf/csf.allow during setup in CSF" 2>&1 | tee -a "${REPORT_FILE}"
        csf -a "${TEMP_ALLOW_IP}" "Added by ${SCRIPT_NAME} for ${BOX_HOSTNAME_FQDN} as temporary allowed IP during setup"
        # After that, the next step is requesting SSL and seems like the box need to restart
        # The reason it needs to restart here because if I don't restart at this point, the front page is not accessible (seems like port 80 is blocked)
        # If I don't restart at this point, I will not be able to renew cert (letsencrypt will produce error like firewall problem but it's not).
        # This is related to Ipv6 DAD. Look at function link_da_ipv6() for more information
        # DAD disable is not working. Still need to restart system. Just restart it and resume later.
        #echo "[${SCRIPT_NAME}]: Creating reboot flag to restart system after installing CSF ..." 2>&1 | tee -a "${REPORT_FILE}"
        #cat /dev/null >/var/run/reboot-required
        #echo "[${SCRIPT_NAME}]: Warning, system will reboot and you can run this script again to continue setup" 2>&1 | tee -a "${REPORT_FILE}"
        #_pause
      else
        echo "[${SCRIPT_NAME}]: This is the weirdest error. Where the hell is /etc/csf/csf.conf? ..." 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi
    # System will reboot automatically from above flag
    else
      echo "[${SCRIPT_NAME}]: [Skipped]: Directadmin installation type is set to AUTO which already include CSF installation" 2>&1 | tee -a "${REPORT_FILE}"
      # TODO: check how DA install using AUTO mode, maybe we need to just use config from here after CSF has installed. Does it auto enable CSF? Will find out
    fi
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  # TIPS. CSF can be removed with this command:
  #sh /etc/csf/uninstall.sh
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function install_da_pre() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    da_latest_version=$(curl -s https://www.directadmin.com/version.php | grep -Eo "[0-9]+\.[0-9]+")
    echo "[${SCRIPT_NAME}]: The latest version of Directadmin is ${da_latest_version}" 2>&1 | tee -a "${REPORT_FILE}"
    _pause 30
    echo "[${SCRIPT_NAME}]: Installing required components to execute DA pre-install ... " 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Setting up DA to run pre-install command ... " 2>&1 | tee -a "${REPORT_FILE}"
    echo 2.0 >/root/.custombuild
    # This will make sure preinstall command is going to be executed when starting DA installation
    echo 1 >/root/.preinstall
    # Here I can set options.conf and php_extensions.conf to custom install.
    mkdir -p /usr/local/directadmin/custombuild
    if [ "${DA_INSTALL_TYPE}" == "custom" ]; then
      echo "[${SCRIPT_NAME}]: [Notice]: Directadmin installation type is custom. Setting up custom options.conf and php_extensions.conf ... " 2>&1 | tee -a "${REPORT_FILE}"
      if [ "${DISTRO_ID}" == "centos" ]; then
        :
      elif [ "${DISTRO_ID}" == "debian" ]; then
        # This one needed if clamav is included
        # https://forum.directadmin.com/threads/configure-error-libcurl-not-found-libcurl-e-g-libcurl-devel-is-required-in-order-to-build-freshclam-and-clamsubmit.62869/
        # No need to install libcurl now, it's working without installing libcurl. I have updated the post.
        :
        #echo "[${SCRIPT_NAME}]: Installing Debian libcurl ..." 2>&1 | tee -a "${REPORT_FILE}"
        #sudo apt-get -y install libcurl4-openssl-dev 2>&1 | tee -a "${REPORT_FILE}"
      else
        echo "[${SCRIPT_NAME}]: Error, unknown value for distribution ID ${DISTRO_ID}" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi
      if [ -d "${DATA_PATH}/maxisetup" ]; then
        echo "[${SCRIPT_NAME}]: Copying Custombuild options.conf ..." 2>&1 | tee -a "${REPORT_FILE}"
        cp "${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/usr/local/directadmin/custombuild/options.conf" "/usr/local/directadmin/custombuild/options.conf"
        sed -i "s|^redirect_host=.*|redirect_host=${BOX_HOSTNAME_FQDN}|" /usr/local/directadmin/custombuild/options.conf
        sed -i "s|^email=.*|email=${ADMIN_EMAIL}|" /usr/local/directadmin/custombuild/options.conf
        sed -i "s|^php_timezone=.*|php_timezone=${BOX_TIMEZONE}|" /usr/local/directadmin/custombuild/options.conf
        echo "[${SCRIPT_NAME}]: Copying Custombuild php_extensions.conf..." 2>&1 | tee -a "${REPORT_FILE}"
        cp "${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/usr/local/directadmin/custombuild/php_extensions.conf" /usr/local/directadmin/custombuild/php_extensions.conf
      else
        echo "[${SCRIPT_NAME}]: Error, directory not exist. Check maxisetup clone folder." 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1 #Just exit because this is weird error if this folder is missing
      fi
    elif [ "${DA_INSTALL_TYPE}" == "ori" ]; then
      echo "[${SCRIPT_NAME}]: [Notice]: Directadmin installation type is set to ori. Directadmin will install using default options" 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${DA_INSTALL_TYPE}" == "interactive" ]; then
      echo "[${SCRIPT_NAME}]: [Notice]: Directadmin installation type is set to interactive. Directadmin will install with some questions" 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${DA_INSTALL_TYPE}" == "auto" ]; then
      echo "[${SCRIPT_NAME}]: [Notice]: Directadmin installation type is set to auto. Directadmin will install all default options including CSF" 2>&1 | tee -a "${REPORT_FILE}"
    else
      echo "[${SCRIPT_NAME}]: Error, invalid installation type set for Directadmin in config file." 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi

  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function install_da() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Downloading Directadmin setup script ... " 2>&1 | tee -a "${REPORT_FILE}"
    cd_to_path "${INST_TEMP_DIR}"
    wget -O setup.sh http://www.directadmin.com/setup.sh
    chmod 755 setup.sh
    echo "[${SCRIPT_NAME}]: Setup will install Directadmin within 30 seconds. It would take a long time, so please be patient" 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: If you don't want to install Directadmin now, press (ctrl+C) to exit and then you can re-run this script to resume at this stage" 2>&1 | tee -a "${REPORT_FILE}"
    _pause 30
    echo "[${SCRIPT_NAME}]: Installing Directadmin on ${BOX_HOSTNAME_FQDN} using ${DA_INSTALL_TYPE} mode ... " 2>&1 | tee -a "${REPORT_FILE}"
    if [[ "${DA_INSTALL_TYPE}" == "custom" || "${DA_INSTALL_TYPE}" == "ori" ]]; then
      # custom and ori depends on the options.conf (this won't ask question)
      ./setup.sh "${DA_CLIENT_ID}" "${DA_LICENSE_ID}" "${BOX_HOSTNAME_FQDN}" "${NIC_INTERFACE_NAME}" "${IPV4_ADD0}" 2>&1 | tee -a "${REPORT_FILE}"
    elif [[ "${DA_INSTALL_TYPE}" == "interactive" ]]; then
      # this will ask question
      bash <(curl -Ss https://www.directadmin.com/setup.sh)
    elif [[ "${DA_INSTALL_TYPE}" == "auto" ]]; then
      # This will not ask question and everything will be installed as default including CSF
      bash <(curl -Ss https://www.directadmin.com/setup.sh) auto
    fi
    script_time
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
}

add_da_ipv6_ip() {
  # Nice info about this: https://forum.directadmin.com/threads/how-to-add-ip-to-server-using-api.37227/
  local ipv6_uncompress_add grep_result ipv6_da_file
  ipv6_uncompress_add=$(ipv6calc --addr2uncompaddr "${IPV6_ADD0}")
  ipv6_da_file="/usr/local/directadmin/data/admin/ips/${ipv6_uncompress_add}"
  # 2 ways: a) Using API or b) Manually create ipv6 file
  #a) Using API
  echo "[${SCRIPT_NAME}]: Adding ipv6 file config using the API method ..." 2>&1 | tee -a "${REPORT_FILE}"
  sleep 1
  da_api_admin "add-ip" "${ipv6_uncompress_add}" "/64"
  #sleep 2
  #b) Manually create ipv6 file (alternative way) if the above method API doesn't produce the IP file (just in case)
  if [ ! -f "${ipv6_da_file}" ]; then
    # Normally API will not fail, but just in case if ipv6 file is still not created,
    # we can use this unofficial method created by me here:
    # https://forum.directadmin.com/threads/how-to-add-ip6-address-in-da-via-terminal-not-through-gui.62752/
    echo "[${SCRIPT_NAME}]: Creating ipv6 file config using manual file creation (alternative method if API failed) ..." 2>&1 | tee -a "${REPORT_FILE}"
    #_exit 1
    touch "${ipv6_da_file}"
    {
      echo "gateway="
      echo "global=no"
      echo "linked_ips="
      echo "netmask=/64"
      echo "ns="
      echo "reseller="
      echo "status=free"
      echo "value="
    } >"/usr/local/directadmin/data/admin/ips/${ipv6_uncompress_add}"
    chmod 600 "/usr/local/directadmin/data/admin/ips/${ipv6_uncompress_add}"
    chown diradmin:diradmin "/usr/local/directadmin/data/admin/ips/${ipv6_uncompress_add}"
    grep_result=$(grep -c "${ipv6_uncompress_add}" /usr/local/directadmin/data/admin/ip.list)
    if [ "${grep_result}" = 0 ]; then
      echo "${ipv6_uncompress_add}" >>/usr/local/directadmin/data/admin/ip.list
    fi
    echo "[${SCRIPT_NAME}]: Rebuilding httpd config files for new IPv6 and linked IPs..." 2>&1 | tee -a "${REPORT_FILE}"
    /usr/local/directadmin/custombuild/build rewrite_confs
  fi
}

function link_da_ipv6() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_ipv6_adds base_da_ipv6 ipv6_uncompress_add linked_ips
    echo "[${SCRIPT_NAME}]: Checking Directadmin IPv6 configuration file ..." 2>&1 | tee -a "${REPORT_FILE}"
    da_ipv6_adds=$(ls /usr/local/directadmin/data/admin/ips/*:* 2>/dev/null)
    #apt-get -y install ipv6calc 2>&1 | tee -a "${REPORT_FILE}"
    ipv6_uncompress_add=$(ipv6calc --addr2uncompaddr "${IPV6_ADD0}")
    # DA IP file use this form 1234:1234:0:0:1234:1234 so we need to convert into this form using ipv6calc
    if [[ -n "${da_ipv6_adds}" && "${AUTO_LINK_DA_IP}" == "yes" ]]; then
      # Change this to for loop instead of ls (best practice mentioned here: https://github.com/koalaman/shellcheck/wiki/SC2010)
      for da_ipv6 in $(echo "${da_ipv6_adds}" | tr ' ' '\n'); do
        #echo $(basename $da_ipv6)
        base_da_ipv6=$(basename "${da_ipv6}")
        if [[ "${base_da_ipv6}" == "${ipv6_uncompress_add}" ]]; then
          echo "[${SCRIPT_NAME}]: IP address ${IPV6_ADD0} is exist in [${da_ipv6}]" 2>&1 | tee -a "${REPORT_FILE}"
          #source "${da_ipv6}"
          linked_ips=$(sed -n 's/^linked_ips=//p' "${da_ipv6}")
          if [[ "${linked_ips}" == "" || -z "${linked_ips}" ]]; then
            echo "IPv6 linked_ip is empty: ${linked_ips}" 2>&1 | tee -a "${REPORT_FILE}"
            sleep 1
            echo "[${SCRIPT_NAME}]: Linking IP address ${base_da_ipv6} with IP address ${IPV4_ADD0} using DA task.queue ..." 2>&1 | tee -a "${REPORT_FILE}"
            echo "action=linked_ips&ip_action=add&ip=${base_da_ipv6}&ip_to_link=${IPV4_ADD0}&apache=yes&dns=yes&apply=yes" >>/usr/local/directadmin/data/task.queue
            /usr/local/directadmin/dataskq d2000
            sleep 2
            echo "[${SCRIPT_NAME}]: Linking IP address ${IPV4_ADD0} with IP address ${base_da_ipv6} using DA task.queue ..." 2>&1 | tee -a "${REPORT_FILE}"
            echo "action=linked_ips&ip_action=add&ip=${IPV4_ADD0}&ip_to_link=${base_da_ipv6}&apache=yes&dns=yes&apply=yes" >>/usr/local/directadmin/data/task.queue
            /usr/local/directadmin/dataskq d2000
            sleep 2
            # Normally DA task.queue completes in 1 minute but sometimes it left than 10 seconds, so we reduce the check in seconds
            echo "[${SCRIPT_NAME}]: Linking is set to task.queue. Let's wait for the linking to complete in 10 seconds ..." 2>&1 | tee -a "${REPORT_FILE}"
            sleep 10
            # Recheck by calling again link_da_ipv6 if still not proceed by task.queue, then sleep 10 seconds .. again and again until success
            link_da_ipv6
          else
            echo "Found IPv6 linked_ips with value: ${linked_ips}" 2>&1 | tee -a "${REPORT_FILE}"
            sleep 1
            # This is when success, we create that executed flag file and break the loop.
            echo "[${SCRIPT_NAME}]: Success, found IP linking entry for IPv6. Continuing setup ..." 2>&1 | tee -a "${REPORT_FILE}"
            check_finish_reboot "${FUNCNAME[0]}"
            break # Good idea to break we only need first match. no reason to loop again.
          fi
        else
          if [ "${AUTO_ADD_IPV6_ENTRY}" == "yes" ]; then
            echo "[${SCRIPT_NAME}]: Warning, no IPv6 matched with ${IPV6_ADD0}. AUTO_ADD_IPV6_ENTRY is set to yes. Automatically adding DA IPv6 config file ..." 2>&1 | tee -a "${REPORT_FILE}"
            sleep 2
            add_da_ipv6_ip
            sleep 10
            link_da_ipv6
          else
            # This might not be executed but just in case if something goes wrong.
            echo "[${SCRIPT_NAME}]: Warning, no IPv6 matched with ${IPV6_ADD0}. Please manually enter IPv6 from GUI (full form) then run this script again" 2>&1 | tee -a "${REPORT_FILE}"
            _exit 1
          fi
        fi
      done
    else
      if [ "${AUTO_ADD_IPV6_ENTRY}" == "yes" ]; then
        echo "[${SCRIPT_NAME}]: Warning, IPv6 has not been setup through Directadmin. AUTO_ADD_IPV6_ENTRY is set to yes. Automatically adding DA IPv6 config file ..." 2>&1 | tee -a "${REPORT_FILE}"
        sleep 2
        add_da_ipv6_ip
        link_da_ipv6
      else
        echo "[${SCRIPT_NAME}]: Warning, IPv6 has not been setup through Directadmin. Please manually enter IPv6 from GUI (full form) then run this script again" 2>&1 | tee -a "${REPORT_FILE}"
        sleep 5
        # Enable the DA port in firewall only when pressing enter (good confirmation from user)
        read -r -s -n 1 -p "[${SCRIPT_NAME}]: Press any key to start adding TCP port ${DA_PORT}/tcp in ufw ..." 2>&1 | tee -a "${REPORT_FILE}"
        echo ""
        echo "[${SCRIPT_NAME}]: Allowing TCP port ${DA_PORT}/tcp for accessing DA admin page ..." 2>&1 | tee -a "${REPORT_FILE}"
        sudo ufw allow "${DA_PORT}/tcp" 2>&1 | tee -a "${REPORT_FILE}"
        # Need to restart DA because we did change port from 2222 to new port before calling this function
        restart_da
        echo "[${SCRIPT_NAME}]: Use the following login information to enter into DA admin page and add IPv6. When done, re-run this script again:". 2>&1 | tee -a "${REPORT_FILE}"
        echo ""
        echo "=============="
        echo "Directadmin now can be accessed through http://${IPV4_ADD0}:${DA_PORT}" 2>&1 | tee -a "${REPORT_FILE}"
        awk '{ print }' /usr/local/directadmin/scripts/setup.txt 2>&1 | tee -a "${REPORT_FILE}"
        echo "=============="
        echo ""
        sleep 5
        _exit 1
      fi
    fi
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi

  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}
function rebuild_da_package() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # Here I can rebuild any missing or change package in DA
  # This to rebuild DA package that cause error like nginx_apache wont start for new install (bug)
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_sql_type da_sql_version
    # Need to rebuild nginx_apache because it cannot be started after installation due to modsecurity directive. See this:
    # https://forum.directadmin.com/threads/nginx-and-apache-nginix-wont-start-due-to-mod_security.61427/
    cd_to_path "/usr/local/directadmin/custombuild"
    echo "[${SCRIPT_NAME}]: Rebuilding DA packages to fix some issues ..."

    ./build update
    # ClamAV and exim rebuild
    echo "[${SCRIPT_NAME}]: Rebuilding ClamAV and exim ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 2
    ./build set clamav yes 2>&1 | tee -a "${REPORT_FILE}"
    ./build set clamav_exim yes 2>&1 | tee -a "${REPORT_FILE}"
    ./build set exim yes 2>&1 | tee -a "${REPORT_FILE}"
    ./build set eximconf yes 2>&1 | tee -a "${REPORT_FILE}"
    ./build set eximconf_release 4.5 2>&1 | tee -a "${REPORT_FILE}"
    ./build clamav 2>&1 | tee -a "${REPORT_FILE}"
    ./build exim 2>&1 | tee -a "${REPORT_FILE}"
    ./build exim_conf 2>&1 | tee -a "${REPORT_FILE}"
    # Mod security rebuild
    echo "[${SCRIPT_NAME}]: Rebuilding modsecurity + ${DA_MODSECURITY_RULESET} ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 2
    ./build set modsecurity yes 2>&1 | tee -a "${REPORT_FILE}"
    ./build set modsecurity_ruleset "${DA_MODSECURITY_RULESET}" 2>&1 | tee -a "${REPORT_FILE}"
    ./build modsecurity 2>&1 | tee -a "${REPORT_FILE}"
    ./build modsecurity_rules 2>&1 | tee -a "${REPORT_FILE}"
    # Web server setting rebuild
    echo "[${SCRIPT_NAME}]: Rebuilding ${CB_WEB_SERVER_SOFTWARE} web server ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 2
    ./build set webserver "${CB_WEB_SERVER_SOFTWARE}" 2>&1 | tee -a "${REPORT_FILE}"
    ./build "${CB_WEB_SERVER_SOFTWARE}" 2>&1 | tee -a "${REPORT_FILE}"
    ./build rewrite_confs 2>&1 | tee -a "${REPORT_FILE}"

    da_sql_type=$(echo "${CB_MYSQL_INS}" | awk -F'-' '{ print $1 }')
    da_sql_version=$(echo "${CB_MYSQL_INS}" | awk -F'-' '{ print $2 }')

    echo "[${SCRIPT_NAME}]: Rebuilding ${da_sql_type} web server to version ${da_sql_version} ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 2

    ./build set "${da_sql_type}" "${da_sql_version}"
    ./build set mysql_inst "${da_sql_type}"
    ./build set mysql_backup yes
    ./build "${da_sql_type}"

    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi

  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}
function install_da_post() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Running DA post installation function ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    # Need this before changing or adding directadmin username
    echo "[${SCRIPT_NAME}]: Setting Directadmin max username to ${DA_MAX_UNAME_LENGTH} ..." 2>&1 | tee -a "${REPORT_FILE}"
    /usr/local/directadmin/directadmin set max_username_length "${DA_MAX_UNAME_LENGTH}"
    # Need to enable ipv6 after install by default DA don't do anything about ipv6
    echo "[${SCRIPT_NAME}]: Enabling ipv6 in directadmin.conf config ..." 2>&1 | tee -a "${REPORT_FILE}"
    /usr/local/directadmin/directadmin set ipv6 1
    sleep 1
    # DA port should be secure don't use 2222 unless you have reason
    echo "[${SCRIPT_NAME}]: Changing DA admin port from 2222 to ${DA_PORT}" 2>&1 | tee -a "${REPORT_FILE}"
    /usr/local/directadmin/directadmin set port "${DA_PORT}"
    sleep 1
    echo "[${SCRIPT_NAME}]: Changing DA login page redirection port from 2222 to ${DA_PORT}" 2>&1 | tee -a "${REPORT_FILE}"
    {
      echo "<?php"
      echo "header(\"Location: http://\".\$_SERVER['HTTP_HOST'].\":${DA_PORT}\");"
      echo "?>"
    } >/var/www/html/redirect.php
    sleep 1
    if [ "${DISTRO_ID}" == "centos" ]; then
      echo "[${SCRIPT_NAME}]: Adding DA new port ${DA_PORT}/tcp to firewalld ..." 2>&1 | tee -a "${REPORT_FILE}"
      sudo firewall-cmd --permanent --zone=public --add-port="${DA_PORT}/tcp" 2>&1 | tee -a "${REPORT_FILE}"
    elif [ "${DISTRO_ID}" == "debian" ]; then
      echo "[${SCRIPT_NAME}]: Adding DA new port ${DA_PORT}/tcp to ufw ..." 2>&1 | tee -a "${REPORT_FILE}"
      sudo ufw allow "${DA_PORT}/tcp" 2>&1 | tee -a "${REPORT_FILE}"
    fi
    echo "[${SCRIPT_NAME}]: Now directadmin can be login using a new port ${DA_PORT}" 2>&1 | tee -a "${REPORT_FILE}"
    sleep 2
    restart_da
    echo "[${SCRIPT_NAME}]: DA post installation has completed!" 2>&1 | tee -a "${REPORT_FILE}"
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi

  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# This is the pre-requirement before getting ssl
# Configure the wildcard certificate option here for external DNS
function configure_da_ssl_pre() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_bin cb_bin
    da_bin="/usr/local/directadmin/directadmin"
    cb_bin="/usr/local/directadmin/custombuild/build"
    # Not enabling this yet
    # echo "[${SCRIPT_NAME}]: Setting directadmin ddns_ttl=1 at directadmin.conf ..." 2>&1 | tee -a "${REPORT_FILE}"
    # sleep 1
    # ${da_bin} set ddns_ttl 1
    # install the latest letsencrypt here (this will only get the latest letsencrypt.sh)
    echo "[${SCRIPT_NAME}]: Installing the latest letsencrypt.sh for Directadmin ..." 2>&1 | tee -a "${REPORT_FILE}"
    ${cb_bin} letsencrypt 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    # Need to reboot
    echo "[${SCRIPT_NAME}]: Creating reboot flag to restart system before requesting SSL certificate for Directadmin ..." 2>&1 | tee -a "${REPORT_FILE}"
    cat /dev/null >/var/run/reboot-required
    echo "[${SCRIPT_NAME}]: Warning, system will reboot and you can run this script again to continue setup" 2>&1 | tee -a "${REPORT_FILE}"
    #_pause 10
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi

  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_ssl() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # Request SSL failed due to DAD (until server restart)
  # Interesting answer: https://serverfault.com/questions/602700/debian-ipv6-is-not-asssigned-to-interface
  # Nice reading: https://www.agwa.name/blog/post/beware_the_ipv6_dad_race_condition
  # https://serverfault.com/questions/421460/nginx-failed-to-start-cannot-assign-requested-address
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    if [ "${SETUP_DA_HOST_SSL}" == "yes" ]; then
      local da_bin cb_bin da_script_path
      da_bin="/usr/local/directadmin/directadmin"
      cb_bin="/usr/local/directadmin/custombuild/build"
      da_script_path="/usr/local/directadmin/scripts"
      echo "[${SCRIPT_NAME}]: Configuring Directadmin SSL Certificate ..." 2>&1 | tee -a "${REPORT_FILE}"
      #0) Set the ssl_redirect_host
      echo "[${SCRIPT_NAME}]: Setting ssl_redirect_host to ${BOX_HOSTNAME_FQDN} in directadmin.conf config ..." 2>&1 | tee -a "${REPORT_FILE}"
      ${da_bin} set ssl_redirect_host "${BOX_HOSTNAME_FQDN}" 2>&1 | tee -a "${REPORT_FILE}"

      echo "[${SCRIPT_NAME}]: Setting redirect_host_https no in Directadmin options.conf config ..." 2>&1 | tee -a "${REPORT_FILE}"
      ${cb_bin} set redirect_host_https no 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      echo "[${SCRIPT_NAME}]: Setting use_hostname_for_alias yes in Directadmin options.conf config ..." 2>&1 | tee -a "${REPORT_FILE}"
      ${cb_bin} set use_hostname_for_alias yes 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      #https://help.directadmin.com/item.php?id=629
      #1) Make sure enable_ssl_sni=1 in directadmin.conf (internal value is already default to 1, so if enable_ssl_sni has no entry this code does nothing)
      echo "[${SCRIPT_NAME}]: Enabling enable_ssl_sni=1 in directadmin.conf config..." 2>&1 | tee -a "${REPORT_FILE}"
      ${da_bin} set enable_ssl_sni 1
      sleep 1
      #2) Make sure letsencrypt=1 in directadmin.conf
      echo "[${SCRIPT_NAME}]: Setting letsencrypt=1 in directadmin.conf config ..." 2>&1 | tee -a "${REPORT_FILE}"
      ${da_bin} set letsencrypt 1 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      #3) Add wellknown-alias
      echo "[${SCRIPT_NAME}]: Creating dummy acme-challenge texts through custombuild rewrite_confs ..." 2>&1 | tee -a "${REPORT_FILE}"
      ${cb_bin} rewrite_confs
      sleep 1
      #4) Install letsencrypt latest version at pre function
      #5) Disable ssl=0 # This one fixed issue where you cannot request cert using ssl=1.
      # only enable ssl=1 after request certificate success. From my notes last year, I disabled this first before renew else it wont work.
      echo "[${SCRIPT_NAME}]: Disabling ssl=0 in directadmin.conf config..." 2>&1 | tee -a "${REPORT_FILE}"
      ${da_bin} set ssl 0 2>&1 | tee -a "${REPORT_FILE}"
      #6) Restart Directadmin
      sleep 1
      echo "[${SCRIPT_NAME}]: Restarting directadmin after changing directadmin.conf ..." 2>&1 | tee -a "${REPORT_FILE}"
      restart_da
      #7) Now let's request
      echo "[${SCRIPT_NAME}]: Requesting SSL certificate for ${BOX_HOSTNAME_FQDN} ..." 2>&1 | tee -a "${REPORT_FILE}"
      ${da_script_path}/letsencrypt.sh request_single "${BOX_HOSTNAME_FQDN}" 4096 2>&1 | tee -a "${REPORT_FILE}"
      retval=$?
      echo "Return status after request certificate is ${retval}"
      sleep 1
      echo "[${SCRIPT_NAME}]: Enabling ssl=1 in directadmin.conf config..." 2>&1 | tee -a "${REPORT_FILE}"
      ${da_bin} set ssl 1 2>&1 | tee -a "${REPORT_FILE}"
      echo "[${SCRIPT_NAME}]: Setting redirect_host_https yes in Directadmin options.conf config ..." 2>&1 | tee -a "${REPORT_FILE}"
      ${cb_bin} set redirect_host_https yes 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      # Always a good idea to restart DA after changing directadmin.conf
      restart_da
      sleep 1
    fi
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi

  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function change_da_auth() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # This function change the directadmin username and password from default to yours (based on config file)
  # It also has more options to secure DA installation. Example maybe this one we can create 2 step authentication
  if [ ! -f "${executed_function}" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_scripts_path
    da_scripts_path="/usr/local/directadmin/scripts"

    # This will change Directadmin admin account:
    echo "[${SCRIPT_NAME}]: Changing Directadmin admin username from admin to ${DA_OWNER_USERNAME1} ... " 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    ${da_scripts_path}/change_username.sh "admin" "${DA_OWNER_USERNAME1}" 2>&1 | tee -a "${REPORT_FILE}"
    # Now on just focus on debian command RIP CentOS
    echo "[${SCRIPT_NAME}]: Changing Directadmin's admin (${DA_OWNER_USERNAME1}) password ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    echo "${DA_OWNER_USERNAME1}:${DA_OWNER_USERPASS1}" | chpasswd
    echo "" 2>&1 | tee -a "${REPORT_FILE}"

    # Create htpasswd for phpmyadmin URL:
    echo "[${SCRIPT_NAME}]: Creating httpasswd for restricting phpMyAdmin URL route ... " 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    # Supply -c for first user
    htpasswd -b -c /etc/httpd/.htpasswd "${HTTPASSWD_PHPMYADMIN_USERNAME}" "${HTTPASSWD_PHPMYADMIN_PASS}"

    echo "[${SCRIPT_NAME}]: Creating httpasswd for restricting roundcube URL route ... " 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    # Don't supply c for next user
    htpasswd -b /etc/httpd/.htpasswd "${HTTPASSWD_ROUNDCUBE_USERNAME}" "${HTTPASSWD_ROUNDCUBE_PASS}"
    sudo chown apache:apache /etc/httpd/.htpasswd
    sudo chmod +r /etc/httpd/.htpasswd
    echo "[${SCRIPT_NAME}]: Restarting Directadmin after changing new username ... " 2>&1 | tee -a "${REPORT_FILE}"
    # I think best to restart DA after changing username because admin has so many configs (what do you think?):
    restart_da
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi

  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}
function configure_da_sql() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    # Note that during installation MySQL generates a short password and DA use this root password. See the text message below:
    # Heard someone said in the forum that root password is not set but that was wrong.
    ##### MySQL root password seems to be unset, setting using MySQL queries...
    ####Setting password: SET PASSWORD FOR 'root'@'localhost' = PASSWORD('*******');
    local da_scripts_path mysql_on_my_cnf_etc mysql_on_my_cnf_da mysql_on_non_cnf gc mysql_granted my_cnf_db_root my_cnf_db_da_admin mysql_conf_db_da_admin
    local randomBlowfishSecret replace_pma_blowfish replace_pma_authtype ret_code loop_count

    da_scripts_path="/usr/local/directadmin/scripts"
    mysql_conf_db_da_admin="/usr/local/directadmin/conf/mysql.conf"
    my_cnf_db_da_admin="/usr/local/directadmin/conf/my.cnf"
    my_cnf_db_root="/etc/my.cnf"

    echo "[${SCRIPT_NAME}]: Securing mysql installation ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "===============================" 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    # By default sql root password is blank (this is not secure). Need to create that root password.
    # This mysqld method can be used only if correct password is supplied in /etc/my.cnf or blank password with no entries in /etc/my.cnf

    # Using mysql if it's running and can be authenticated.
    if command -v mysqld &>/dev/null; then

      mysql_on_non_cnf=$(
        mysql -e 'exit'
        echo $?
      )
      mysql_on_my_cnf_etc=$(
        mysql --defaults-extra-file=${my_cnf_db_root} -e 'exit'
        echo $?
      )
      mysql_on_my_cnf_da=$(
        mysql --defaults-extra-file=${my_cnf_db_da_admin} -e 'exit'
        echo $?
      )

      if [ "${mysql_on_non_cnf}" -eq 0 ]; then
        # In case password is empty then use this (normally initial setup server is empty):
        echo "[${SCRIPT_NAME}]: Authenticating mysql without specifying config ..." 2>&1 | tee -a "${REPORT_FILE}"
        mysql_granted="mysql -e"
        echo "[${SCRIPT_NAME}]: Success, mysql command is able to login without specifying config file. mysql_granted is set to: ${mysql_granted}" 2>&1 | tee -a "${REPORT_FILE}"
        #sleep 1
      elif [ "${mysql_on_my_cnf_etc}" -eq 0 ]; then
        echo "[${SCRIPT_NAME}]: Authenticating mysql using ${my_cnf_db_root} ..." 2>&1 | tee -a "${REPORT_FILE}"
        mysql_granted="mysql --defaults-extra-file=${my_cnf_db_root} -e"
        echo "[${SCRIPT_NAME}]: Success, mysql command is able to login using ${my_cnf_db_root}. mysql_granted is set to: ${mysql_granted}" 2>&1 | tee -a "${REPORT_FILE}"
        #sleep 1
      elif [ "${mysql_on_my_cnf_da}" -eq 0 ]; then
        echo "[${SCRIPT_NAME}]: Authenticating mysql using ${my_cnf_db_da_admin} ..." 2>&1 | tee -a "${REPORT_FILE}"
        mysql_granted="mysql --defaults-extra-file=${my_cnf_db_da_admin} -e"
        echo "[${SCRIPT_NAME}]: Success, mysql command is able to login using ${my_cnf_db_da_admin}. mysql_granted is set to: ${mysql_granted}" 2>&1 | tee -a "${REPORT_FILE}"
        #sleep 1
      else
        # If above not working I can use this: https://help.directadmin.com/item.php?id=45
        # or this: https://www.directadmin.com/features.php?id=2677
        echo "[${SCRIPT_NAME}]: Error, local SQL authentication is needed. If you know your root password, please supply it in ${my_cnf_db_root} or ${my_cnf_db_da_admin}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "If you don't know, you may need to reset root password manually using this article: https://help.directadmin.com/item.php?id=45" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi

      echo "[${SCRIPT_NAME}]: Changing mysql root password ... " 2>&1 | tee -a "${REPORT_FILE}"
      ${mysql_granted} "ALTER USER 'root'@'localhost' IDENTIFIED BY '${DA_ROOT_SQL_PASS}';"
      if [ -w "${my_cnf_db_root}" ]; then

        gc=$(grep -ic '^password=.*\|^password.*=.*' "${my_cnf_db_root}")
        #grep -ic '^password=.*\|^password.*=.*' /etc/my.cnf
        if [ "${gc}" = 0 ]; then
          # Append because not exist
          echo "[${SCRIPT_NAME}]: Updating new SQL root password in ${my_cnf_db_root} under [client] section ... " 2>&1 | tee -a "${REPORT_FILE}"
          #sleep 1
          sed -i "s|\[client\]|&\npassword=${DA_ROOT_SQL_PASS}|" "${my_cnf_db_root}"
        else
          echo "[${SCRIPT_NAME}]: Updating new SQL username root in ${my_cnf_db_root} ... " 2>&1 | tee -a "${REPORT_FILE}"
          # Already exist, but we replace
          sed -i "/\[client\]/,/^\[/ s/password=.*/password=${DA_ROOT_SQL_PASS}/" "${my_cnf_db_root}"
        fi
        gc=$(grep -ic '^user=.*\|^user.*=.*' "${my_cnf_db_root}")
        if [ "${gc}" = 0 ]; then
          echo "[${SCRIPT_NAME}]: Updating new SQL root username in ${my_cnf_db_root} under [client] section ... " 2>&1 | tee -a "${REPORT_FILE}"
          #sleep 1
          # Append under client because not exist
          sed -i 's|\[client\]|&\nuser=root|' "${my_cnf_db_root}"
        else
          echo "[${SCRIPT_NAME}]: Setting SQL user to root in ${my_cnf_db_root} ... " 2>&1 | tee -a "${REPORT_FILE}"
          # Already exist, but we replace
          sed -i "/\[client\]/,/^\[/ s/user=.*/user=root/" "${my_cnf_db_root}"
        fi
        gc=$(grep -ic '^bind-address=.*\|^bind-address.*=.*' "${my_cnf_db_root}")
        if [ "${gc}" = 0 ]; then
          echo "[${SCRIPT_NAME}]: Disabling mysql remote access in ${my_cnf_db_root} under [mysqld] section ... " 2>&1 | tee -a "${REPORT_FILE}"
          #sleep 1
          # Append under client because not exist
          sed -i 's|\[mysqld\]|&\nbind-address=127.0.0.1|' "${my_cnf_db_root}"
        else
          echo "[${SCRIPT_NAME}]: Updating mysql remote access as bind-address=127.0.0.1 in ${my_cnf_db_root} under [mysqld] section ... " 2>&1 | tee -a "${REPORT_FILE}"
          # Already exist, but we replace
          sed -i "/\[mysqld\]/,/^\[/ s/bind-address=.*/bind-address=127.0.0.1/" "${my_cnf_db_root}"
        fi
      else
        echo "[${SCRIPT_NAME}]: Warning, file ${my_cnf_db_root} is missing. It should exist in this location if mysql is installed through DA" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi

      echo "[${SCRIPT_NAME}]: Removing unsecured anonymous users from database ... " 2>&1 | tee -a "${REPORT_FILE}"
      #sleep 1
      ${mysql_granted} "DELETE FROM mysql.user WHERE user='';"
      echo "[${SCRIPT_NAME}]: Removing root users from non-localhost for security ... " 2>&1 | tee -a "${REPORT_FILE}"
      #sleep 1
      ${mysql_granted} "DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1', '::1');"
      echo "[${SCRIPT_NAME}]: Removing test database if exist for security ... " 2>&1 | tee -a "${REPORT_FILE}"
      #sleep 1
      ${mysql_granted} "DROP DATABASE IF EXISTS test;"
      echo "[${SCRIPT_NAME}]: Flushing mysql privileges ... " 2>&1 | tee -a "${REPORT_FILE}"
      #sleep 1
      ${mysql_granted} "FLUSH PRIVILEGES;"
      # There is no recommendation to change da_admin sql username to something else at this moment,
      # so ignore username change for sql, just change password.
      echo "[${SCRIPT_NAME}]: Changing Directadmin da_admin default SQL password ... " 2>&1 | tee -a "${REPORT_FILE}"
      #sleep 1
      ${mysql_granted} "ALTER USER 'da_admin'@'localhost' IDENTIFIED BY '${DA_ADMIN_SQLPASS}';"
      echo "[${SCRIPT_NAME}]: Updating da_admin SQL authentication information at ${mysql_conf_db_da_admin} ... " 2>&1 | tee -a "${REPORT_FILE}"
      #sleep 1

      if [ -s ${mysql_conf_db_da_admin} ]; then
        sed -i "s/^passwd=.*/passwd=${DA_ADMIN_SQLPASS}/" ${mysql_conf_db_da_admin}
      else
        echo -n '' >${mysql_conf_db_da_admin}
        chmod 600 ${mysql_conf_db_da_admin}
        chown diradmin:diradmin ${mysql_conf_db_da_admin}
        echo "user=da_admin" >>${mysql_conf_db_da_admin}
        echo "passwd=${DA_ADMIN_SQLPASS}" >>${mysql_conf_db_da_admin}
      fi

      if [ -s ${my_cnf_db_da_admin} ]; then
        sed -i "s/^password=.*/password=${DA_ADMIN_SQLPASS}/" ${my_cnf_db_da_admin}
      else
        echo -n '' >${my_cnf_db_da_admin}
        chmod 600 ${my_cnf_db_da_admin}
        chown diradmin:diradmin ${my_cnf_db_da_admin}
        echo "[client]"
        echo "user=da_admin" >>${my_cnf_db_da_admin}
        echo "password=${DA_ADMIN_SQLPASS}" >>${my_cnf_db_da_admin}
      fi
    else
      echo "[${SCRIPT_NAME}]: Warning, mysqld is not running. Please inspect why and re-run this script to resume setup." 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    # When done, test running mysql in terminal.
    echo "[${SCRIPT_NAME}]: [Completed]: Now, you can test running 'mysql' command in terminal to see if authentication was correctly setup" 2>&1 | tee -a "${REPORT_FILE}"
    sleep 2

    # Configuring phpmyadmin htaccess
    echo "[${SCRIPT_NAME}]: Creating https redirection .htaccess for phpMyAdmin ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    touch /var/www/html/phpMyAdmin/.htaccess
    {
      echo "RewriteEngine On"
      echo "RewriteCond %{HTTPS} !=on"
      echo "RewriteRule ^/?(.*) https://%{SERVER_NAME}${PHPMYADMIN_LOGIN_ROUTE}\$1 [R=301,L]"
    } >/var/www/html/phpMyAdmin/.htaccess
    chmod 644 /var/www/html/phpMyAdmin/.htaccess
    chown webapps:webapps /var/www/html/phpMyAdmin/.htaccess

    echo "[${SCRIPT_NAME}]: Backing up original phpmyadmin config.inc.php at /var/www/html/phpMyAdmin as config.inc.php_original_${DATE_TIME_NOW}..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    cp -p "/var/www/html/phpMyAdmin/config.inc.php" "/var/www/html/phpMyAdmin/config.inc.php_original_${DATE_TIME_NOW}"

    echo "[${SCRIPT_NAME}]: Generating new blowfish secret key for phpMyAdmin in config.inc.php ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    # Enabling cookie authentication (so that we can use htpasswd for this)
    # To enable cookie authentication we need to have blow fish string
    # Some character might break sed like '/' so we don't want this character because this character can have problem later on.
    # No need to escape https://stackoverflow.com/questions/65528031/how-to-generate-openssl-blowfish-without-certain-characters-or-allow-certain-set
    loop_count=0
    while :; do
      ((loop_count++))
      randomBlowfishSecret=$(openssl rand -base64 32)
      replace_pma_blowfish="\$cfg['blowfish_secret'] = '${randomBlowfishSecret}'; \/* YOU MUST FILL IN THIS FOR COOKIE AUTH! *\/"
      sed -i "s/\$cfg\[.blowfish_secret.\]\s*=.*/${replace_pma_blowfish}/" /var/www/html/phpMyAdmin/config.inc.php 2>/dev/null
      ret_code=$?
      if [ "${ret_code}" = 0 ]; then
        echo "[${SCRIPT_NAME}]: Successfully inserted blowfish secret key into /var/www/html/phpMyAdmin/config.inc.php after ${loop_count} retry(s)" 2>&1 | tee -a "${REPORT_FILE}"
        break
      fi
    done

    echo "[${SCRIPT_NAME}]: Setting phpMyAdmin authentication from http to cookie in config.inc.php to enable page login and httpd protection ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    replace_pma_authtype="\$cfg['Servers'][\$i]['auth_type'] = 'cookie';"
    sed -i "s/\$cfg\['Servers'\]\[\$i\]\['auth_type'\] = 'http';/${replace_pma_authtype}/" /var/www/html/phpMyAdmin/config.inc.php

    # For custom phpMyAdmin theme (not using theme yet). Theme we must get it from maxisetup
    #echo "[${SCRIPT_NAME}]: Setting up phpMyAdmin custom themes ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    #cp -p "phpMyAdmin_theme_from_maxisetup_called_sofibox" into "/var/www/html/phpMyAdmin/themes/sofibox"
    # Temporarily no theme yet. In the future put theme here
    # And all the themes must have this permissions:
    #chmod 644 for files, chmod 755 for folders
    # And all must have this users:
    #chown webapps:webapps /var/www/html/phpMyAdmin/themes/*

    # This is used to fix problem with phpMyAdmin Storage: https://help.directadmin.com/item.php?id=564
    cd_to_path "${INST_TEMP_DIR}"
    echo "[${SCRIPT_NAME}]: Creating phpMyAdmin configuration storage database ..." 2>&1 | tee -a "${REPORT_FILE}"
    wget -O create_tables.sh http://files1.directadmin.com/services/all/phpMyAdmin/create_tables.sh
    chmod 755 create_tables.sh
    echo "[${SCRIPT_NAME}]: Executing create_tables.sh to create phpMyAdmin configuration storage database ..." 2>&1 | tee -a "${REPORT_FILE}"
    ./create_tables.sh

    #TODO install mysql tuner after all above to check mysql or phpmyadmin status here:
    #wget -O /usr/local/sbin/mysqltuner mysqltuner.pl
    #chmod 710 /usr/local/sbin/mysqltuner
    #mysqltuner
    #when you execute mysqltuner, you will get suggestion what to tweak for your sql.
    #The mysqltuner will read directadmin mysql.conf password that you have specified before.
    #In case it cannot read and trigger an error.
    #Make sure the password doesn't contain this character > or < because mysqltuner does not support it.
    # Mysqltuner also does not accept this password: )
    #[Sample my.cnf at /etc/my.cnf](https://gitlab.com/arafatx/sofibox-luks-earth/-/blob/master/etc/my.cnf)
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi

  # Deprecated:
  # echo "[${SCRIPT_NAME}]: Changing Directadmin da_admin SQL password using DA custom script ... " 2>&1 | tee -a "${REPORT_FILE}"
  # This script requires that we have root or da_admin password defined in cnf, else it's not working
  # ${da_scripts_path}/reset_da_admin_password.sh --password "${DA_ADMIN_SQLPASS}"
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}
# This configure_da_mail can be roundcube squirrelmail or others
function configure_da_mail() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local rc_index_file
    rc_index_file="/var/www/html/roundcube/index.php"
    if [ -f ${rc_index_file} ]; then
      local grep_count my_cnf_rc_file replace_rc_authconf replace_rc_prodname rc_config_file
      local replace_rc_rcguard_recaptcha_privatekey replace_rc_rcguard_recaptcha_publickey rc_built_in_plugins rc_version
      rc_version=$(grep '| Version' /var/www/html/roundcube/index.php | awk '{ print $3 }')
      echo "[${SCRIPT_NAME}]: OK, roundcube version ${rc_version} has been detected" 2>&1 | tee -a "${REPORT_FILE}"
      echo "[${SCRIPT_NAME}]: Configuring roundcube ${rc_version} installation ..." 2>&1 | tee -a "${REPORT_FILE}"
      sleep 2

      my_cnf_rc_file="/var/www/html/roundcube/config/my.cnf"
      rc_config_file="/var/www/html/roundcube/config/config.inc.php"
      echo "[${SCRIPT_NAME}]: Backing up original roundcube config.inc.php at /var/www/html/roundcube/config/config.inc.php as config.inc.php_original_${DATE_TIME_NOW}..." 2>&1 | tee -a "${REPORT_FILE}"
      #sleep 1
      cp -p "/var/www/html/roundcube/config/config.inc.php" "/var/www/html/roundcube/config/config.inc.php_original_${DATE_TIME_NOW}"

      echo "[${SCRIPT_NAME}]: Securing roundcube installation ..." 2>&1 | tee -a "${REPORT_FILE}"
      echo "===============================" 2>&1 | tee -a "${REPORT_FILE}"
      #sleep 1
      # By default roundcube is installed with a very short and weak password. We need to change the password to secured one
      # Remember roundcube password cannot contains character '@ , & and :' because config.inc.php use this separator and won't accept that password.
      echo "[${SCRIPT_NAME}]: Changing da_roundcube password in user database ..." 2>&1 | tee -a "${REPORT_FILE}"
      #sleep 1
      mysql -e "ALTER USER 'da_roundcube'@'localhost' IDENTIFIED BY '${DA_ROUNDCUBE_SQL_PASS}'; FLUSH PRIVILEGES;"
      echo "[${SCRIPT_NAME}]: Updating da_roundcube password in config.inc.php ..." 2>&1 | tee -a "${REPORT_FILE}"
      #sleep 1
      replace_rc_authconf="\$config['db_dsnw'] = 'mysql:\/\/da_roundcube:${DA_ROUNDCUBE_SQL_PASS}@localhost\/da_roundcube';"
      sed -i "s/\$config\[.db_dsnw.\]\s*=.*/${replace_rc_authconf}/" "${rc_config_file}"

      echo "[${SCRIPT_NAME}]: Changing DA product name in config.inc.php ..." 2>&1 | tee -a "${REPORT_FILE}"
      #sleep 1
      replace_rc_prodname="\$config['product_name'] = '${ROUNDCUBE_CUSTOM_NAME}';"
      sed -i "s/\$config\[.product_name.\]\s*=.*/${replace_rc_prodname}/" "${rc_config_file}"

      grep_count=$(grep -ic "\$config\['force_https'\]" "${rc_config_file}")
      if [ "${grep_count}" = 0 ]; then
        echo "[${SCRIPT_NAME}]: Enabling force_https for roundcube at config.inc.php ..." 2>&1 | tee -a "${REPORT_FILE}"
        #sleep 1
        echo "\$config['force_https'] = true;" >>"${rc_config_file}"
      else
        echo "[${SCRIPT_NAME}]: The roundcube setting config.inc.php has already set force_https" 2>&1 | tee -a "${REPORT_FILE}"
      fi

      if [ -s "${my_cnf_rc_file}" ]; then
        echo "[${SCRIPT_NAME}]: Updating SQL da_roundcube username in ${my_cnf_rc_file} ... " 2>&1 | tee -a "${REPORT_FILE}"
        #sleep 1
        sed -i "/\[client\]/,/^\[/ s/user=.*/user=da_roundcube/" "${my_cnf_rc_file}"
        echo "[${SCRIPT_NAME}]: Updating SQL da_roundcube password in ${my_cnf_rc_file} ... " 2>&1 | tee -a "${REPORT_FILE}"
        #sleep 1
        sed -i "/\[client\]/,/^\[/ s/password=.*/password=${DA_ROUNDCUBE_SQL_PASS}/" ${my_cnf_rc_file}
      else
        # If no file was created, we write this file for my.cnf (roundcube auth sql config)
        echo -n '' >${my_cnf_rc_file}
        chmod 600 ${my_cnf_rc_file}
        chown diradmin:diradmin ${my_cnf_rc_file}
        echo "[client]"
        echo "user=da_roundcube" >>${my_cnf_rc_file}
        echo "password=${DA_ROUNDCUBE_SQL_PASS}" >>${my_cnf_rc_file}
      fi

      echo "[${SCRIPT_NAME}]: Enabling some roundcube built-in plugins ... " 2>&1 | tee -a "${REPORT_FILE}"
      #sleep 1
      rc_built_in_plugins=("'password',"
        "'archive',"
        "'zipdownload',"
        "'newmail_notifier',"
        "'managesieve',"
        "'markasjunk',"
        "'emoticons',"
        "'attachment_reminder',"
        "'new_user_dialog',"
      )
      #printf "%s\n" "${rc_built_in_plugins[@]}"
      for rc_built_in_plugin in "${rc_built_in_plugins[@]}"; do
        grep_count=$(grep -ic "${rc_built_in_plugin}" "${rc_config_file}")
        if [ "${grep_count}" -eq 0 ]; then
          # Use this code and loop above rc_plugins must be array
          echo "[${SCRIPT_NAME}]: Adding ${rc_built_in_plugin} into roundcube plugin list ..." 2>&1 | tee -a "${REPORT_FILE}"
          #sleep 1
          sed -i "s|\$config\[.plugins.\] = array(|&\n    ${rc_built_in_plugin}|" "${rc_config_file}"
        else
          echo "[${SCRIPT_NAME}]: [Skipped] The plugin ${rc_built_in_plugin} has already been set in ${rc_config_file}" 2>&1 | tee -a "${REPORT_FILE}"
        fi
      done

      echo "[${SCRIPT_NAME}]: Installing roundcube 3rd party plugins ... " 2>&1 | tee -a "${REPORT_FILE}"
      # Here we install roundcube 3rd party plugins
      if [ "${ENABLE_ROUNDCUBE_RCGUARD}" == "yes" ]; then

        #sleep 1
        # I posted bug here: https://github.com/dsoares/roundcube-rcguard/issues/39, but jus that server restart fixed the problem
        echo "[${SCRIPT_NAME}]: Installing rcguard (Google recaptcha) to protect roundcube ... " 2>&1 | tee -a "${REPORT_FILE}"
        #sleep 1
        cd_to_path "/var/www/html/roundcube/plugins/"
        GIT_SSL_NO_VERIFY=true git clone https://github.com/dsoares/rcguard.git rcguard
        chown -R webapps:webapps rcguard/
        chmod 755 rcguard
        cd_to_path "/var/www/html/roundcube/plugins/rcguard/"
        find . -type d -exec chmod 0755 {} \;
        find . -type f -exec chmod 0644 {} \;
        mv config.inc.php.dist config.inc.php

        echo "[${SCRIPT_NAME}]: Configuring rcguard recaptcha_publickey in config.inc.php ..." 2>&1 | tee -a "${REPORT_FILE}"
        #sleep 1
        replace_rc_rcguard_recaptcha_publickey="\$config['recaptcha_publickey'] = '${GOOGLE_RECAPTCHA_SITE_V2}';"
        sed -i "s/\$config\[.recaptcha_publickey.\]\s*=.*/${replace_rc_rcguard_recaptcha_publickey}/" /var/www/html/roundcube/plugins/rcguard/config.inc.php
        echo "[${SCRIPT_NAME}]: Configuring rcguard recaptcha_privatekey in config.inc.php ..." 2>&1 | tee -a "${REPORT_FILE}"
        #sleep 1
        replace_rc_rcguard_recaptcha_privatekey="\$config['recaptcha_privatekey'] = '${GOOGLE_RECAPTCHA_SECRET_V2}';"
        sed -i "s/\$config\[.recaptcha_privatekey.\]\s*=.*/${replace_rc_rcguard_recaptcha_privatekey}/" /var/www/html/roundcube/plugins/rcguard/config.inc.php
        echo "[${SCRIPT_NAME}]: Creating mysql table for rcguard ..." 2>&1 | tee -a "${REPORT_FILE}"
        #sleep 1
        # The plugin already provide initial script to create rcguard table in roundcube. So we can just add this sql file under da_roundcube username
        mysql da_roundcube </var/www/html/roundcube/plugins/rcguard/SQL/mysql.initial.sql

        # Add rcguard plugin into roundcube config if doesn't exist
        grep_count=$(grep -ic "'rcguard'," /var/www/html/roundcube/config/config.inc.php)
        if [ "${grep_count}" -eq 0 ]; then
          # Use this code and loop above rc_plugins must be array
          echo "[${SCRIPT_NAME}]: Adding 'rcguard', into roundcube plugin list ..."
          #sleep 1
          sed -i "s|\$config\[.plugins.\] = array(|&\n    'rcguard',|" /var/www/html/roundcube/config/config.inc.php
        else
          echo "[${SCRIPT_NAME}]: [Skipped] The plugin 'rcguard', has already been set in /var/www/html/roundcube/config/config.inc.php  " 2>&1 | tee -a "${REPORT_FILE}"
        fi

      else
        echo "[${SCRIPT_NAME}]: [Skipped]: rcguard plugin installation is not set to yes" 2>&1 | tee -a "${REPORT_FILE}"
      fi
    else
      echo "[${SCRIPT_NAME}]: [Skipped]: no roundcube has been installed (unable to detect index.php)" 2>&1 | tee -a "${REPORT_FILE}"
    fi

    # configure other mail here, like squirrelmail
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

configure_da_ftp() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local gc
    gc=$(grep -ic '\-\/var\/log\/pureftpd\.log' /etc/rsyslog.conf)
    if [ "${gc}" -eq 0 ]; then
      echo "[${SCRIPT_NAME}]: Setting pure-ftpd to use log at /var/log/pureftpd.log ..." 2>&1 | tee -a "${REPORT_FILE}"
      #sleep 1
      printf "ftp.*\t\t\t\t-/var/log/pureftpd.log\n" >>/etc/rsyslog.conf
    else
      echo "[${SCRIPT_NAME}]: [Skipped]: Found ftp log entry '-/var/log/pureftpd.log' at /etc/ryslog.conf" 2>&1 | tee -a "${REPORT_FILE}"
    fi
    # No need to remove ftp log from rsyslog.conf using ftp.none because DA BFM and LFD from CSF needs the log to auto block
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}
# This function only for configuring nginx_apache (it makes URL phpmyadmin or roundcube secure)
function configure_nginx_apache() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Backing up original httpd-alias.conf at /etc/httpd/ as httpd-alias.conf_original_${DATE_TIME_NOW} ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    cp -p "/etc/httpd/conf/extra/httpd-alias.conf" "/etc/httpd/conf/extra/httpd-alias.conf_original_${DATE_TIME_NOW}"
    echo "[${SCRIPT_NAME}]: Creating DA custom config for httpd-alias.conf ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    cat /dev/null >/etc/httpd/conf/extra/httpd-alias.conf
    {
      echo "# ==============================================="
      echo "# This configuration file was generated by ${SCRIPT_NAME}"
      echo "# Author: ${ADMIN_NAME} | Email: ${ADMIN_EMAIL} | Web: ${BOX_DOMAIN}"
      echo "# ==============================================="
      echo "RewriteEngine On"
      echo "Alias /config "\"/var/www/html/redirect.php"\""
      echo "Alias /.well-known/acme-challenge "\"/var/www/html/.well-known/acme-challenge"\""
      echo ""
      # Here we can specify what URL should be blocked (with 404.html page)
      echo "# BLOCKED URLs:"
      echo "Alias /phpMyAdmin "\"/var/www/html/server/error_docs/404.html"\""
      echo "Alias /phpmyadmin "\"/var/www/html/server/error_docs/404.html"\""
      echo "Alias /pma "\"/var/www/html/server/error_docs/404.html"\""
      echo "Alias /squirrelmail "\"/var/www/html/server/error_docs/404.html"\""
      echo "Alias /webmail "\"/var/www/html/server/error_docs/404.html"\""
      echo "Alias /roundcube "\"/var/www/html/server/error_docs/404.html"\""
      echo ""
      echo "# CUSTOM URLs:"
      echo "# PHPMYADMIN custom URL:"
      echo "Alias ${PHPMYADMIN_LOGIN_ROUTE} "\"/var/www/html/phpMyAdmin/"\""
      echo "# ROUNDCUBE custom URL:"
      echo "Alias ${ROUNDCUBE_LOGIN_ROUTE} "\"/var/www/html/roundcube/"\""
      echo "# HTPASSWD secure directories:"
      echo ""
    } >>/etc/httpd/conf/extra/httpd-alias.conf
    if [ "${SECURE_HTTPASSWD_LOGIN_ROUTE}" == "yes" ]; then
      echo "[${SCRIPT_NAME}]: SECURE HTTPASSWD_LOGIN_ROUTE is set to yes. creating htpasswd authentication for custom routes ..." 2>&1 | tee -a "${REPORT_FILE}"
      #sleep 1
      {
        echo "#Protect phpMyAdmin directory:"
        echo "<Directory "\"/var/www/html/phpMyAdmin/"\">"
        echo "#AllowOverride AuthConfig"
        echo "AuthType Basic"
        echo "AuthName "\""${BOX_HOSTNAME_FQDN}": DB-Auth"\""
        echo "AuthUserFile /etc/httpd/.htpasswd"
        echo "Require user ${HTTPASSWD_PHPMYADMIN_USERNAME}"
        echo "</Directory>"
        echo ""
        echo "#Protect roundcube directory:"
        echo "<Directory "\"/var/www/html/roundcube/"\">"
        echo "#AllowOverride AuthConfig"
        echo "AuthType Basic"
        echo "AuthName "\""${BOX_HOSTNAME_FQDN}": Mail-Auth"\""
        echo "AuthUserFile /etc/httpd/.htpasswd"
        echo "Require user ${HTTPASSWD_ROUNDCUBE_USERNAME}"
        echo "</Directory>"
      } >>/etc/httpd/conf/extra/httpd-alias.conf

    else
      echo "[${SCRIPT_NAME}]: [skipped]: SECURE HTTPASSWD_LOGIN_ROUTE is set to no. Custom URL routes are not protected" 2>&1 | tee -a "${REPORT_FILE}"
      #sleep 1
      {
        echo "##Protect phpMyAdmin directory:"
        echo "#<Directory "\"/var/www/html/phpMyAdmin/"\">"
        echo "##AllowOverride AuthConfig"
        echo "#AuthType Basic"
        echo "#AuthName "\""${BOX_HOSTNAME_FQDN}": DB-Auth"\""
        echo "#AuthUserFile /etc/httpd/.htpasswd"
        echo "#Require user ${HTTPASSWD_PHPMYADMIN_USERNAME}"
        echo "#</Directory>"
        echo ""
        echo "##Protect roundcube directory:"
        echo "#<Directory "\"/var/www/html/roundcube/"\">"
        echo "##AllowOverride AuthConfig"
        echo "#AuthType Basic"
        echo "#AuthName "\""${BOX_HOSTNAME_FQDN}": Mail-Auth"\""
        echo "#AuthUserFile /etc/httpd/.htpasswd"
        echo "#Require user ${HTTPASSWD_ROUNDCUBE_USERNAME}"
        echo "#</Directory>"
      } >>/etc/httpd/conf/extra/httpd-alias.conf

    fi

    echo "[${SCRIPT_NAME}]: Backing up original httpd-includes.conf at /etc/httpd/ as httpd-includes.conf_original_${DATE_TIME_NOW} ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    cp -p "/etc/httpd/conf/extra/httpd-includes.conf" "/etc/httpd/conf/extra/httpd-includes.conf_original_${DATE_TIME_NOW}"
    #echo "[${SCRIPT_NAME}]: Creating https redirection for all routes in httpd-includes.conf ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    # It is a new file, so we make sure it is exist
    #touch /etc/httpd/conf/extra/httpd-includes.conf
    #{ # Temporarily disable this
    #  # Make https for all directories (This will take over force https setting at Directadmin)
    #  echo "# ==============================================="
    #  echo "# This configuration file was generated by ${SCRIPT_NAME}"
    #  echo "# Author: ${ADMIN_NAME} | Email: ${ADMIN_EMAIL} | Web: ${BOX_DOMAIN}"
    #  echo "# ==============================================="
    #  echo "<location /*>"
    #  echo "RewriteEngine On"
    #  echo "RewriteCond %{HTTPS} off"
    #  echo "RewriteRule (.*) https://%{HTTP_HOST}%{REQUEST_URI}"
    #  echo "</location>"
    #} >>/etc/httpd/conf/extra/httpd-includes.conf
    echo "[${SCRIPT_NAME}]: Backing up original httpd-default.conf at /etc/httpd/ as httpd-default.conf_original_${DATE_TIME_NOW} ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    cp -p "/etc/httpd/conf/extra/httpd-default.conf" "/etc/httpd/conf/extra/httpd-default.conf_original_${DATE_TIME_NOW}"
    echo "[${SCRIPT_NAME}]: Customizing server config at httpd-default.conf ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    sed -i 's|^ServerTokens .*|ServerTokens Prod|' /etc/httpd/conf/extra/httpd-default.conf
    sed -i 's|^ServerSignature .*|ServerSignature Off|' /etc/httpd/conf/extra/httpd-default.conf
    # Restarting web server based on config file
    restart_da_web_server
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# Configure apps in /var/www/html
function configure_web_apps_html() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    # TODO copy that webapps here (it should from maxisetup)
    cat /dev/null >/var/www/html/index.php
    {
      echo "<? php"
      echo "MaXi32 - Arafat Ali - Rebuilding"
      echo "?>"
    } >/var/www/html/index.php
    chmod 644 /var/www/html/index.php
    chown webapps:webapps /var/www/html/index.php
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function build_da_custom_conf() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # This function will create / copy all custom configs like roundcube, phpmyadmin, ap2 etc in DA custom folder
  # So when we update Directadmin, it won't replace these files.
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    # This will build custom config for DA with secured settings
    local cb_bin
    cb_bin="/usr/local/directadmin/custombuild/build"
    # 1) create custom folder at /usr/local/directadmin/custombuild/custom/ap2/conf/extra
    mkdir -p /usr/local/directadmin/custombuild/custom/ap2/conf/extra
    echo "[${SCRIPT_NAME}]: Copying httpd-alias.conf into DA custom ap2 folder ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    cp -p "/etc/httpd/conf/extra/httpd-alias.conf" "/usr/local/directadmin/custombuild/custom/ap2/conf/extra/httpd-alias.conf"

    echo "[${SCRIPT_NAME}]: Copying httpd-includes.conf into DA custom ap2 folder ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    cp -p "/etc/httpd/conf/extra/httpd-includes.conf" "/usr/local/directadmin/custombuild/custom/ap2/conf/extra/httpd-includes.conf"

    echo "[${SCRIPT_NAME}]: Copying httpd-default.conf at into DA custom ap2 folder ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    cp -p "/etc/httpd/conf/extra/httpd-default.conf" "/usr/local/directadmin/custombuild/custom/ap2/conf/extra/httpd-default.conf"

    # 2 For phpmyadmin
    mkdir -p /usr/local/directadmin/custombuild/custom/phpmyadmin
    # .htaccess
    echo "[${SCRIPT_NAME}]: Copying phpMyAdmin .htaccess into phpmyadmin DA custom folder ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    cp -p "/var/www/html/phpMyAdmin/.htaccess" "/usr/local/directadmin/custombuild/custom/phpmyadmin/.htaccess"

    # config.inc.php
    echo "[${SCRIPT_NAME}]: Copying original phpmyadmin config.inc.php at /var/www/html/phpMyAdmin into DA phpmyadmin custom folder ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    cp -p "/var/www/html/phpMyAdmin/config.inc.php" "/usr/local/directadmin/custombuild/custom/phpmyadmin/config.inc.php"

    # For custom phpMyAdmin theme (not using theme yet) leave this comment until I have new custom theme
    #mkdir -p /usr/local/directadmin/custombuild/custom/phpmyadmin/themes
    #echo "[${SCRIPT_NAME}]: Copying custom phpMyAdmin themes ..." 2>&1 | tee -a "${REPORT_FILE}"
    #cp -p "/var/www/html/phpMyAdmin/themes/sofibox" "/usr/local/directadmin/custombuild/custom/phpmyadmin/themes/sofibox"
    #sleep 1

    #3 - For main roundcube (2 important files: config.inc.php, my.cnf)
    mkdir -p /usr/local/directadmin/custombuild/custom/roundcube
    echo "[${SCRIPT_NAME}]: Copying original roundcube config.inc.php into DA roundcube custom folder ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    cp -p "/var/www/html/roundcube/config/config.inc.php" "/usr/local/directadmin/custombuild/custom/roundcube/config.inc.php"
    # Remember when rebuild roundcube ./build roundcube DA will automatically update my.cnf. Don't touch that.
    # I wrote answer here: https://forum.directadmin.com/threads/script-to-reset-da_admin-da_roundcube-password.57101/#post-324944
    #4 - For roundcube rcguard plugin (copy the whole folder)
    mkdir -p /usr/local/directadmin/custombuild/custom/roundcube/plugins/
    echo "[${SCRIPT_NAME}]: Copying custom roundcube custom plugins ..." 2>&1 | tee -a "${REPORT_FILE}"
    cp -p -r /var/www/html/roundcube/plugins/rcguard /usr/local/directadmin/custombuild/custom/roundcube/plugins/

    #n - For others later in here

    #n-Create custom php ini file here (create custom php ini file here with the following information) -- what is the purpose? find it out
    # increase memory consumption or upload sql size, make custom path in custom/php.conf.d
    #https://forum.directadmin.com/threads/solved-customized-50-webapps-ini-and-10-directadmin-ini.61045/#post-312326

    # at the end must do build phpmyadmin, roundcube, rewrite_confs to save httpd changes.
    # Need to rebuild this because previously we change config.inc.php. Better rebuild for new setting.
    echo "[${SCRIPT_NAME}]: Rebuilding DA phpMyAdmin for new settings ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    ${cb_bin} phpmyadmin 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Rebuilding DA roundcube for new settings ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    ${cb_bin} roundcube 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Updating DA apache/nginx configs for new settings ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    ${cb_bin} rewrite_confs 2>&1 | tee -a "${REPORT_FILE}"

    # Rebuilding other DA package whatever more here if needed ...
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# For configuring admin setting and extra hardening any DA related installation
function configure_da() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    # From now on we should use maxida since it was released and installed earlier when executing this script (with maxicode update).
    # Maxida (or Maxi Direct Admin) is used to manage everything related to Directadmin. It also has the ability to manage DA API eg:
    # maxida --api <action> <options> ...
    if command -v maxida &>/dev/null; then
      echo "[${SCRIPT_NAME}]: Maxida is installed with the following details: " 2>&1 | tee -a "${REPORT_FILE}"
      maxida -V
      sleep 2
    else
      echo "[${SCRIPT_NAME}]: Warning, no maxida binary is found!" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi

    echo "[${SCRIPT_NAME}]: Enforcing Directadmin difficult password ..." 2>&1 | tee -a "${REPORT_FILE}"
    # or maxida --directadmin set enforce_difficult_passwords 1
    maxida --da set enforce_difficult_passwords 1
    # This will only allow hostname url login in Directadmin. For example, without this option you can use any domain within DA system to login.
    # eg: userdomain.com:2222 . Sometimes this user does not have valid certificate, thus this will cause security issue.
    # so, it is better to redirect to one hostname with a valid certificate:
    # Also explained in here: https://www.directadmin.com/features.php?id=917
    echo "[${SCRIPT_NAME}]: Forcing Directadmin login url to usr ${BOX_HOSTNAME_FQDN} ..." 2>&1 | tee -a "${REPORT_FILE}"
    maxida --da set force_hostname "${BOX_HOSTNAME_FQDN}"

    echo "[${SCRIPT_NAME}]: Securing all php installation ..." 2>&1 | tee -a "${REPORT_FILE}"
    # or maxida --custombuild secure_php
    maxida --cb secure_php
    echo "[${SCRIPT_NAME}]: Enabling Directadmin backup encryption ..." 2>&1 | tee -a "${REPORT_FILE}"
    maxida --da set allow_backup_encryption 1
    echo "[${SCRIPT_NAME}]: Setting Directadmin online help ..." 2>&1 | tee -a "${REPORT_FILE}"
    maxida --da set admin_helper "${DA_HELP_DOMAIN}"
    maxida --da set reseller_helper "${DA_HELP_DOMAIN}"
    maxida --da set user_helper "${DA_HELP_DOMAIN}"

    # For DA Administrator Settings:
    da_api_admin "start+admin"
    echo "[${SCRIPT_NAME}]: Configuring Directadmin Admin settings ..."
    da_api_admin "set-admin-settings"
    echo "[${SCRIPT_NAME}]: Configuring Directadmin Server, Security and Email settings ..."
    da_api_admin "set-server-settings"
    # TODO look at the post about DA external import js, try to avoid that for security and apply it here
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function add_da_ip() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # This is to add DA script to add IP into device.
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Adding ipv6 address for Directadmin using DA addip official script ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    #echo "Usage: $0 <ip> (<netmask> (<eth dev> (<broadcast>)))";
    #echo "example: $0 1.2.3.4 255.255.255.0 eth0";
    local addip_script
    addip_script="/usr/local/directadmin/scripts/addip"
    if [ -f ${addip_script} ]; then
      "${addip_script}" "${IPV6_ADD0}" "255.255.255.0" "${NIC_INTERFACE_NAME}" 2>&1 | tee -a "${REPORT_FILE}"
    else
      echo "[${SCRIPT_NAME}]: Warning file ${addip_script} was not found. Bye!" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# This maxibox is only used for backup purpose (TODO)
function configure_maxibox() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# This is the pre-requisite components for all maxicode
function configure_maxicode_pre() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    apt-get -y install ipcalc bc jq gawk
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# maxicode will be the place to upgrade maxicode binaries (even when script finished running).
# example running maxibox --update-maxicode or maxibox --checkout-all maxibox
# usage: maxicode --update <package_name> or maxicode -u <package_name>
# eg: To update all package: maxicode -u all. To update just maxiwall: maxicode -u maxiwall
function configure_maxicode() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    maxicode_bin="/usr/local/maxicode/maxicode"
    if [ -f ${maxicode_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxicode_bin} ..." 2>&1 | tee -a "${REPORT_FILE}"
      chmod +x ${maxicode_bin}
      # Symbolic name
      ln -s ${maxicode_bin} /usr/local/bin
    else
      echo "[${SCRIPT_NAME}]: Warning, maxicode doesn't exist in /usr/local/maxicode !" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi

    # 1) Install aide and copy maxiaide files (make sure it works)
    # 2) Install rsync and copy maxisetup files (make sure it works)
    # 3) Install suricata and copy maxiwall files (make sure it works)
    # 4) Copy maxicbuild

    #local ORI_PWD
    #echo "[${SCRIPT_NAME}]: Installing OSSEC ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 2
    #echo "[${SCRIPT_NAME}]: Creating directory /usr/src if doesn't exist ..." 2>&1 | tee -a "${REPORT_FILE}"
    #mkdir -p "${INST_TEMP_DIR}"
    #echo "[${SCRIPT_NAME}]: Removing previous download file ..." 2>&1 | tee -a "${REPORT_FILE}"
    #rm -fv "${INST_TEMP_DIR}/3.6.0.tar.gz"
    #echo "[${SCRIPT_NAME}]: Downloading and extracting OSSEC file ..." 2>&1 | tee -a "${REPORT_FILE}"
    #ORI_PWD="${PWD}"
    #cd "${INST_TEMP_DIR}" || {
    #  echo "Failed to enter into directory" 2>&1 | tee -a "${REPORT_FILE}"
    #  _exit 1
    #}
    #wget https://github.com/ossec/ossec-hids/archive/3.6.0.tar.gz
    #tar xzf 3.6.0.tar.gz

    #cd ossec-hids-3.6.0/ || {
    #  echo "Failed to enter into directory" 2>&1 | tee -a "${REPORT_FILE}"
    #  _exit 1
    #}
    #sh "install.sh"
    # If want to silent install follow this documentation: https://www.ossec.net/docs/manual/installation/install-source-unattended.html
    # Need to change the config file (uncomment setting)
    # Tip: To remove OSSEC use this
    # /var/ossec/bin/ossec-control stop && rm -rf /var/ossec && rm /etc/init.d/*ossec* && rm /etc/ossec-init.conf
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_maxiperm() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    local maxiperm_bin
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Configuring maxiperm installation in maxicode ..." 2>&1 | tee -a "${REPORT_FILE}"
    maxiperm_bin="/usr/local/maxicode/maxiperm/perm"
    if [ -f ${maxiperm_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxiperm_bin} ..." 2>&1 | tee -a "${REPORT_FILE}"
      chmod +x ${maxiperm_bin}
      # Symbolic name
      ln -s ${maxiperm_bin} /usr/local/bin
    else
      echo "[${SCRIPT_NAME}]: Warning, maxiperm doesn't exist in /usr/local/maxicode !" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# Harden server based on lynis suggestion
function configure_maxinis() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # Here we do extra hardening for SSHD (based on lynis suggestion)
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local lynis_latest_version maxinis_bin
    maxinis_bin="/usr/local/maxicode/maxinis/maxinis"
    # SSHD config enough. No more
    # TODO MORE HERE for others based on lynis suggestion.. (Need to obtain the scan ID first and get that value)
    # Use that value and auto apply hardening here
    # Install latest lynis using:
    # Get latest version tar.gz inspired by: https://stackoverflow.com/questions/22510705/get-the-latest-download-link-programmatically
    echo "[${SCRIPT_NAME}]: Getting latest version of lynis ..." 2>&1 | tee -a "${REPORT_FILE}"
    lynis_latest_version=$(curl 'https://downloads.cisofy.com/lynis/' | grep -oP 'href="lynis-\K[0-9]+\.[0-9]+\.[0-9]+' | sort -t. -rn -k1,1 -k2,2 -k3,3 | head -1)
    echo "[${SCRIPT_NAME}]: Latest version detected as ${lynis_latest_version}. Downloading lynis version ${lynis_latest_version} ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    mkdir -p /usr/local/lynis
    cd_to_path "/usr/local"
    wget "https://cisofy.com/files/lynis-${lynis_latest_version}.tar.gz" 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Extracting lynis.tar.gz ..." 2>&1 | tee -a "${REPORT_FILE}"
    tar xfvz "lynis-${lynis_latest_version}.tar.gz" 2>&1 | tee -a "${REPORT_FILE}"
    rm -f "lynis-${lynis_latest_version}.tar.gz"
    cd_to_path "lynis"
    # TODO: Configure maxinis binary here
    echo "[${SCRIPT_NAME}]: Checking system security with lynis ..." 2>&1 | tee -a "${REPORT_FILE}"
    # No need to audit system during setup because ain't nobody got time for this
    #./lynis audit system 2>&1 | tee -a "${REPORT_FILE}"
    if [ -f ${maxinis_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxinis_bin} ..." 2>&1 | tee -a "${REPORT_FILE}"
      chmod +x ${maxinis_bin}
      # Symbolic name
      ln -s ${maxinis_bin} /usr/local/bin
    else
      echo "[${SCRIPT_NAME}]: Warning, maxinis doesn't exist in /usr/local/maxicode !" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# Installing other security software based on maxicode
function configure_maxigpg() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local maxigpg_bin ret_val gpg_priv_key gpg_priv_key_encrypted
    echo "[${SCRIPT_NAME}]: Configuring maxigpg installation in maxicode ..." 2>&1 | tee -a "${REPORT_FILE}"
    maxigpg_bin="/usr/local/maxicode/maxigpg/maxigpg"
    if [ -f ${maxigpg_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxigpg_bin} ..." 2>&1 | tee -a "${REPORT_FILE}"
      chmod +x ${maxigpg_bin}
      # Symbolic name
      ln -s ${maxigpg_bin} /usr/local/bin
    else
      echo "[${SCRIPT_NAME}]: Warning, maxigpg doesn't exist in /usr/local/maxicode !" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    if [ "${GPG_USE_EXISTING_KEY}" == "yes" ]; then
      gpg_priv_key_encrypted="${DATA_PATH}/maxisetup/storage/os/debian/usr/local/maxisecure/gpg/keys/priv.key.gpg"
      gpg_priv_key="${DATA_PATH}/maxisetup/storage/os/debian/usr/local/maxisecure/gpg/keys/priv.key"
      rm -f "${gpg_priv_key}"
      gpg --pinentry-mode=loopback --passphrase "${GPG_PASSPHRASE}" -d -o "${gpg_priv_key}" "${gpg_priv_key_encrypted}"
      echo "[${SCRIPT_NAME}]: Importing existing gpg-agent key from maxisetup ..." 2>&1 | tee -a "${REPORT_FILE}"
      gpg --pinentry-mode=loopback --passphrase "${GPG_PASSPHRASE}" --import "${gpg_priv_key}"
      ret_val=$?
      if [ ${ret_val} = 0 ]; then
        echo "[${SCRIPT_NAME}]: Import ok" 2>&1 | tee -a "${REPORT_FILE}"
      else
        echo "[${SCRIPT_NAME}]: Import failed" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi
    else
      # 0) Configure gpg first
      echo "[${SCRIPT_NAME}]: Generating new gpg-agent key ..." 2>&1 | tee -a "${REPORT_FILE}"
      cat >gpgkey <<EOF
     %echo Generating a basic OpenPGP key for ${BOX_HOSTNAME_FQDN}
     Key-Type: RSA
     Key-Length: 2048
     Subkey-Type: RSA
     Subkey-Length: 2048
     Name-Real: ${ADMIN_NAME}
     Name-Comment: This is the main GPG key for ${ADMIN_NAME} in ${BOX_HOSTNAME_FQDN}
     Name-Email: ${ADMIN_EMAIL}
     Expire-Date: 0
     Passphrase: ${GPG_PASSPHRASE}
     # Do a commit here, so that we can later print "done" :-)
     %commit
     %echo done
EOF
      # Generate the key based on the above information
      gpg --verbose --batch --generate-key gpgkey
      # Set trust to 5 for the key so we can encrypt without prompt.
      echo "[${SCRIPT_NAME}]: Setting trust to 5 for the key ${ADMIN_EMAIL} so we can encrypt without prompt ..." 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      echo -e "5\ny\n" | gpg --command-fd 0 --expert --edit-key "${ADMIN_EMAIL}" trust
      # Test the key can encrypt and decrypt.
      echo "[${SCRIPT_NAME}]: Testing key for encrypting ..." 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      gpg -e -a -r "${ADMIN_EMAIL}" gpgkey
      ret_val=$?
      if [ ${ret_val} = 0 ]; then
        echo "[${SCRIPT_NAME}]: Encryption test ok" 2>&1 | tee -a "${REPORT_FILE}"
      else
        echo "[${SCRIPT_NAME}]: Encryption test failed" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi
      # Delete the options and decrypt the original to stdout.
      rm -f gpgkey
      echo "[${SCRIPT_NAME}]: Testing key for decrypting ..." 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      gpg -d gpgkey.asc
      ret_val=$?
      if [ ${ret_val} = 0 ]; then
        echo "[${SCRIPT_NAME}]: Decryption test ok" 2>&1 | tee -a "${REPORT_FILE}"
        rm -f gpgkey.asc
      else
        echo "[${SCRIPT_NAME}]: Decryption test failed" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi
    fi
    # Remove the unprotected key
    rm -f "${gpg_priv_key}"
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# maxida is used to manage directadmin functionalities including APIs.
function configure_maxida() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    local maxida_bin maxida_conf_sample maxida_conf
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Configuring maxida installation in maxicode ..." 2>&1 | tee -a "${REPORT_FILE}"
    maxida_bin="/usr/local/maxicode/maxida/maxida"
    maxida_conf_sample="/usr/local/maxicode/maxida/maxida.conf.sample"
    maxida_conf="/usr/local/maxicode/maxida/maxida.conf"
    if [ -f ${maxida_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxida_bin} ..." 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      chmod +x ${maxida_bin}
      # Symbolic name
      ln -s ${maxida_bin} /usr/local/bin
    else
      echo "[${SCRIPT_NAME}]: Warning, maxida doesn't exist in /usr/local/maxicode !" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi

    if [ -f ${maxida_conf_sample} ]; then
      cp "${maxida_conf_sample}" "${maxida_conf}"
      # Here we create environment variables to use maxida API (Directadmin API). Very important to supply initial authentication
      echo "[${SCRIPT_NAME}]: Creating environment variable for maxida at ${maxida_conf} ..." 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      # Put admin authentication:
      sed -i "s/^API_USERNAME=.*/API_USERNAME=\"${DA_OWNER_USERNAME1}\"/" ${maxida_conf}
      sed -i "s/^API_USERPASS=.*/API_USERPASS=\"${DA_OWNER_USERPASS1}\"/" ${maxida_conf}
      sed -i "s/^BOX_HOSTNAME_FQDN=.*/BOX_HOSTNAME_FQDN=\"${BOX_HOSTNAME_FQDN}\"/" ${maxida_conf}
      sed -i "s/^DA_PORT=.*/DA_PORT=\"${DA_PORT}\"/" ${maxida_conf}
      sed -i "s/^SETUP_GIT_URL=.*/SETUP_GIT_URL=\"${SETUP_GIT_URL}\"/" ${maxida_conf}
      sed -i "s/^GIT_TOKEN=.*/GIT_TOKEN=\"${GIT_TOKEN}\"/" ${maxida_conf}

    else
      echo "[${SCRIPT_NAME}]: Warning, maxida.conf.sample doesn't exist in /usr/local/maxicode !" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi

    # Update directadmin all custom scripts
    # TODO got bug here
    ${maxida_bin} --update all

    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_maxicron() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    local maxicron_bin
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    maxicron_bin="/usr/local/maxicode/maxicron/maxicron"

    if [ -f ${maxicron_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxicron_bin} ..." 2>&1 | tee -a "${REPORT_FILE}"
      chmod +x ${maxicron_bin}
      # Symbolic name
      ln -s ${maxicron_bin} /usr/local/bin
    else
      echo "[${SCRIPT_NAME}]: Warning, maxicron doesn't exist in /usr/local/maxicode !" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_maxiaide() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # Under testing for new version AIDE. New AIDE version has different config format.
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    local maxiaide_bin
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    # install aide
    # No need to install aide because maxiaide --initfull is designed to initialize this and install required packages
    #echo "[${SCRIPT_NAME}]: Installing AIDE file monitoring ..." 2>&1 | tee -a "${REPORT_FILE}"
    #apt-get -y install aide
    maxiaide_bin="/usr/local/maxicode/maxiaide/maxiaide"

    if [ -f ${maxiaide_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxiaide_bin} ..." 2>&1 | tee -a "${REPORT_FILE}"
      chmod +x ${maxiaide_bin}
      # Symbolic name
      ln -s ${maxiaide_bin} /usr/local/bin
    else
      echo "[${SCRIPT_NAME}]: Warning, maxiaide doesn't exist in /usr/local/maxicode !" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    # TODO Waiting for testing
    # maxiaide --initfull
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_maxiwall() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local latest_suricata_version suricata_preferred_version maxiwall_bin maxirbl_bin # suricata_conf suricata_service is_masked
    # suricata_conf="/etc/suricata/suricata.yaml"
    # Instruction: https://forum.suricata.io/t/install-suricata-6-0-1-on-debian-10-from-source/992
    # Install required components for suricata:
    echo "[${SCRIPT_NAME}]: Installing required components for suricata & maxiwall ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    # Essential tools:
    apt-get install make autoconf automake libtool
    # Required by suricata:
    apt-get -y install libpcre3 libpcre3-dbg libpcre3-dev build-essential libpcap-dev \
      libnet1-dev libyaml-0-2 libyaml-dev pkg-config zlib1g zlib1g-dev liblz4-dev \
      libcap-ng-dev libcap-ng0 libmagic-dev libjansson-dev libnspr4-dev \
      libnss3-dev libgeoip-dev liblua5.1-dev libhiredis-dev libevent-dev \
      python-yaml python3-distutils python3-pip #rustc cargo
    pip3 install PyYAML
    # Do not install rustc and cargo
    # This will fix this error -> ERROR: Suricata now requires Rust to build (Debian has bug with rustc package)
    # Bug details: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=976601 | https://redmine.openinfosecfoundation.org/issues/4204
    # workaround step: https://stackoverflow.com/questions/65330382/building-suricata-could-not-compile-der-parser

    # Remove built-in package of rustc
    echo "[${SCRIPT_NAME}]: Removing built-in of existing rustc ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    sudo apt remove --purge rustc
    # apt-get -y install rustc cargo (install latest rust)
    echo "[${SCRIPT_NAME}]: Installing the latest rustc package ..." 2>&1 | tee -a "${REPORT_FILE}"
    # The last command sh -s -- -y will not prompt question
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    echo "[${SCRIPT_NAME}]: Sourcing cargo env file ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    source "$HOME/.cargo/env"
    # Removing suricata compiled source:

    echo "[${SCRIPT_NAME}]: Removing existing suricata installation and log files ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    apt-get remove suricata
    rm -rf /usr/share/suricata
    rm -rf /etc/suricata
    rm -rf /var/lib/suricata
    rm -rf /var/log/suricata
    rm -f /usr/local/bin/suricata
    rm -f /etc/default/suricata
    rm -f /etc/init.d/suricata
    rm -f /etc/systemd/system/suricata.service
    systemctl daemon-reload

    # source configuration
    # Do not use apt to install. Currently Debian package uses old version 4.1.2 but the latest is 6.0.1
    # For CentOS rpm package will install only version 5. So the best is to compile from source using this trick:
    cd_to_path "${INST_TEMP_DIR}"
    latest_suricata_version=$(curl 'https://www.openinfosecfoundation.org/download/' | grep -oP 'href="suricata-\K[0-9]+\.[0-9]+\.[0-9]+' | sort -t. -rn -k1,1 -k2,2 -k3,3 | head -1)
    suricata_preferred_version="${SURICATA_SELECT_VERSION}"
    # If you think the future version of suricata installation will follow below step then put suricata_select_version="${latest_suricata_version}"
    if [ "${latest_suricata_version}" != "${suricata_preferred_version}" ]; then
      echo "[${SCRIPT_NAME}]: Warning, suricata latest version is: ${latest_suricata_version} but selected version in config file is ${SURICATA_SELECT_VERSION}" 2>&1 | tee -a "${REPORT_FILE}"
    fi
    # Below is the installation for Suricata 6.0.1. Sometimes new version release and the way how to install Suricata is not the same like previous one
    # Sometimes new version has extra library so we need to check how to install this.
    echo "[${SCRIPT_NAME}]: Removing suricata downloaded file suricata-${suricata_preferred_version}.tar.gz ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    rm -fv "${INST_TEMP_DIR}/suricata-${suricata_preferred_version}.tar.gz"
    echo "[${SCRIPT_NAME}]: Downloading suricata latest version-${suricata_preferred_version} ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    wget "https://www.openinfosecfoundation.org/download/suricata-${suricata_preferred_version}.tar.gz"
    echo "[${SCRIPT_NAME}]: Extracting suricata version-${suricata_preferred_version} ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    tar xzvf "suricata-${suricata_preferred_version}.tar.gz"
    cd_to_path "suricata-${suricata_preferred_version}/"
    echo "[${SCRIPT_NAME}]: Configuring script for getting ready to build suricata ... " 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    # Dont enable IPS because we will integrate blocking with CSF (using my script called maxicode/maxiwall)
    ./configure --libdir=/usr/lib64 --prefix=/usr/local --sysconfdir=/etc --localstatedir=/var --datarootdir=/usr/local/share --enable-lua --enable-rust
    #make
    #sudo make install
    echo "[${SCRIPT_NAME}]: Installing suricata with make install-full ... " 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    sudo make install-full

    # Use this ldconfig to prevent error described here:
    # https://stackoverflow.com/questions/65330382/building-suricata-could-not-compile-der-parser
    # sudo ldconfig

    # suricata -V
    if command -v suricata &>/dev/null; then
      echo "[${SCRIPT_NAME}]: Suricata is installed with the following details: " 2>&1 | tee -a "${REPORT_FILE}"
      suricata -V
      sleep 2
    else
      echo "[${SCRIPT_NAME}]: No suricata binary is found! Please inspect the log file why " 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    # Maxiwall --init will do all the commented below (already have this function long time ago).

    # Then Create the service file
    #echo "[${SCRIPT_NAME}]: Creating a new suricata.service file ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1

    #{
    #  echo "# ==============================================="
    #  echo "# This configuration file was generated by ${SCRIPT_NAME}"
    #  echo "# Author: ${ADMIN_NAME} | Email: ${ADMIN_EMAIL} | Web: ${BOX_DOMAIN}"
    #  echo "# ==============================================="
    #  echo "[Unit]"
    #  echo "Description=Suricata IDS/IDP Service"
    #  echo "Wants=network.target syslog.target"
    #  echo "After=network.target syslog.target"
    #  echo "Documentation=man:suricata(8) man:suricatasc(8)"
    #  echo "Documentation=https://redmine.openinfosecfoundation.org/projects/suricata/wiki"
    #  echo ""
    #  echo "[Service]"
    #  echo "Type=forking"
    #  echo "Environment=LD_PREDLOAD=/usr/lib/x86_64-linux-gnu/libtcmalloc_minimal.so.4"
    #  echo "# Debug level ---> -v: INFO | -vv: INFO+PERF | -vvv: INFO+PERF+CONFIG | -vvvv: INFO+PERF+CONFIG+DEBUG"
    #  echo "# D - means in daemon | -c read config | --pidfile <file> write pidfile on a file"
    #  echo "ExecStart=suricata --af-packet -vvv -D -c /etc/suricata/suricata.yaml --pidfile /var/run/suricata.pid"
    #  echo "ExecStartPre=rm -f /var/run/suricata.pid"
    #  echo "ExecStop=kill \$MAINPID && rm -f /var/run/suricata.pid"
    #  echo "ExecReload=kill -9 \$MAINPID"
    #  echo ""
    #  echo "[Install]"
    #  echo "WantedBy=multi-user.target"
    #} >/etc/systemd/system/suricata.service
    #sleep 1
    #echo "[${SCRIPT_NAME}]: Checking if suricata.service is masked ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    #is_masked=$(systemctl status suricata | grep -c 'masked')
    #is_masked=$(ls -l /etc/systemd/system/suricata.service | grep -c '/dev/null')
    #if [ "${is_masked}" -gt 0 ]; then
    #  echo "[${SCRIPT_NAME}]: Warning, the suricata.service is masked. Unmasking the service file ..." 2>&1 | tee -a "${REPORT_FILE}"
    #  sleep 1
    #  systemctl unmask suricata
    #else
    #  echo "[${SCRIPT_NAME}]: OK, the suricata.service is not masked" 2>&1 | tee -a "${REPORT_FILE}"
    #fi

    # Enable suricata before starting at /etc/default/suricata (doesn't seems important when I use the above script)
    # Before starting suricata, I need to use custom config file (suricata.yaml) for best performance:

    #echo "[${SCRIPT_NAME}]: Copying suricata.yaml configuration file template into ${suricata_conf} ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    #cp "${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/usr/local/maxicode/maxiwall/code/etc/suricata/suricata.yaml" "${suricata_conf}"

    #echo "[${SCRIPT_NAME}]: Copying maxiwall.lua into /etc/suricata/lua-output ..." 2>&1 | tee -a "${REPORT_FILE}"
    #mkdir -p /etc/suricata/lua-output
    #sleep 1

    #cp "${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/usr/local/maxicode/maxiwall/code/etc/suricata/lua-output/maxiwall.lua" "/etc/suricata/lua-output/maxiwall.lua"
    #chmod +x "/etc/suricata/lua-output/maxiwall.lua"

    #echo "[${SCRIPT_NAME}]: Copying maxiwall-http.lua into /etc/suricata/lua-output ..." 2>&1 | tee -a "${REPORT_FILE}"
    #mkdir -p /etc/suricata/lua-output
    #sleep 1
    #cp "${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/usr/local/maxicode/maxiwall/code/etc/suricata/lua-output/maxiwall-http.lua" "/etc/suricata/lua-output/maxiwall-http.lua"
    #chmod +x "/etc/suricata/lua-output/maxiwall-http.lua"

    #echo "[${SCRIPT_NAME}]: Starting suricata ... " 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    #systemctl start suricata
    #suricata_service=$(systemctl is-active suricata)

    #if [ "${suricata_service}" == "active" ]; then
    #  echo "[${SCRIPT_NAME}]: OK, suricata is running" 2>&1 | tee -a "${REPORT_FILE}"
    #else
    #  echo "[${SCRIPT_NAME}]: Warning, suricata process is not active [unknown reason]. Please inspect log file to understand the reason" 2>&1 | tee -a "${REPORT_FILE}"
    #  _exit 1
    #fi

    maxiwall_bin="/usr/local/maxicode/maxiwall/maxiwall"

    if [ -f ${maxiwall_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxiwall_bin} ..." 2>&1 | tee -a "${REPORT_FILE}"
      chmod +x ${maxiwall_bin}
      # Symbolic name
      ln -s ${maxiwall_bin} /usr/local/bin
    else
      echo "[${SCRIPT_NAME}]: Warning, maxiwall doesn't exist in /usr/local/maxicode !" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi

    maxirbl_bin="/usr/local/maxicode/maxiwall/maxirbl"

    if [ -f ${maxirbl_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxirbl_bin} ..." 2>&1 | tee -a "${REPORT_FILE}"
      chmod +x ${maxirbl_bin}
      # Symbolic name
      ln -s ${maxirbl_bin} /usr/local/bin
    else
      echo "[${SCRIPT_NAME}]: Warning, maxirbl doesn't exist in /usr/local/maxicode !" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi

    # Writing a new maxiwall.conf file (all sensitive variables should be declared in maxisetup.conf and pass here)
    echo "[${SCRIPT_NAME}]: Writing new maxiwall.conf file ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    {
      echo "# The URL. Need to modify this if they change this URL like the v2 to v3"
      echo "AIPDB_CHECK_URL=\"${MAXIWALL_AIPDB_CHECK_URL}"\"
      echo "AIPDB_REPORT_URL=\"${MAXIWALL_AIPDB_REPORT_URL}"\"
      echo "# The main AIPDB key"
      echo "AIPDB_API_KEY=\"${MAXIWALL_AIPDB_API_KEY}"\"
    } >"/usr/local/maxicode/maxiwall/conf/maxiwall.conf"

    # maxiwall --initfull will handle 3rd party rules and signature update
    # suricata-update update-sources
    #echo "[${SCRIPT_NAME}]: Updating suricata new signature ..." 2>&1 | tee -a "${REPORT_FILE}"
    #sleep 1
    #suricata-update

    # Maxiwall --initfull will do all the commented above (already have this function long time ago).
    # Must have maxiwall.conf file first before running --initfull
    echo "[${SCRIPT_NAME}]: Running maxiwall --initfull ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    maxiwall --initfull

    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# For managing cloud storage. Like mounting cloud storage, send file or receive file from cloud. maxicloud will handle that.
function configure_maxicloud() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # TODO configure maxicloud
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    local maxiaide_bin
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local maxicloud_bin maxicloud_conf maxicloud_conf_sample
    maxicloud_bin="/usr/local/maxicode/maxicloud/maxicloud"
    maxicloud_conf="/usr/local/maxicode/maxicloud/maxicloud.conf"
    maxicloud_conf_sample="/usr/local/maxicode/maxicloud/maxicloud.conf.sample"

    if [ -f ${maxicloud_conf_sample} ]; then
      echo "[${SCRIPT_NAME}]: Copying maxicloud sample config into ${maxicloud_conf} ..." 2>&1 | tee -a "${REPORT_FILE}"
      cp -f ${maxicloud_conf_sample} ${maxicloud_conf}
    else
      echo "[${SCRIPT_NAME}]: Warning, the sample config file ${maxicloud_conf_sample} does not exist. Please inspect the file!" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    if [ -f ${maxicloud_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxicloud_bin} ..." 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      chmod +x ${maxicloud_bin}
      # Symbolic name
      ln -s ${maxicloud_bin} /usr/local/bin
    else
      echo "[${SCRIPT_NAME}]: Warning, maxicloud doesn't exist in /usr/local/maxicode !" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_maxipass() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    local maxipass_bin maxipass_conf maxipass_conf_sample #maxipass_da_conf maxipass_da_conf_sample
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local maxipass_bin maxipass_conf maxipass_conf_sample
    maxipass_bin="/usr/local/maxicode/maxipass/maxipass"
    maxipass_conf="/usr/local/maxicode/maxipass/maxipass.conf"
    maxipass_conf_sample="/usr/local/maxicode/maxipass/maxipass.conf.sample"
    #maxipass_da_conf="/usr/local/maxicode/maxipass/secure/da/da.conf"
    #maxipass_da_conf_sample="/usr/local/maxicode/maxipass/secure/da/da.conf.sample"

    if [ -f ${maxipass_conf_sample} ]; then
      echo "[${SCRIPT_NAME}]: Copying maxipass sample config into ${maxipass_conf} ..." 2>&1 | tee -a "${REPORT_FILE}"
      cp -f ${maxipass_conf_sample} ${maxipass_conf}
    else
      echo "[${SCRIPT_NAME}]: Warning, the sample config file ${maxipass_conf_sample} does not exist. Please inspect the file!" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi

    #if [ -f ${maxipass_da_conf_sample} ]; then
    #  echo "[${SCRIPT_NAME}]: Copying maxipass-da sample config into ${maxipass_da_conf} ..." 2>&1 | tee -a "${REPORT_FILE}"
    #  cp -f ${maxipass_da_conf_sample} ${maxipass_da_conf}
    #  sleep 1
    # Put admin authentication (this should be encrypted and only accessed by GPG agent):
    #  sed -i "s/^API_USERNAME=.*/API_USERNAME=\"${DA_OWNER_USERNAME1}\"/" ${maxipass_da_conf}
    #  sed -i "s/^API_USERPASS=.*/API_USERPASS=\"${DA_OWNER_USERPASS1}\"/" ${maxipass_da_conf}
    #else
    #  echo "[${SCRIPT_NAME}]: Warning, the sample config file ${maxipass_da_conf_sample} does not exist. Please inspect the file!" 2>&1 | tee -a "${REPORT_FILE}"
    #  _exit 1
    #fi

    if [ -f ${maxipass_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxipass_bin} ..." 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      chmod +x ${maxipass_bin}
      # Symbolic name
      ln -s ${maxipass_bin} /usr/local/bin
    else
      echo "[${SCRIPT_NAME}]: Warning, maxipass doesn't exist in /usr/local/maxicode !" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# For managing notification (eg. pushover, gotify)
# TODO configure this when https is ready, put in secured port, put httpd layer
# Find a way to add 2 step authentication
function configure_maxify() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    local version platform
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "Installing gotify ..."
    version="2.0.21"
    platform="linux-amd64"
    wget https://github.com/gotify/server/releases/download/v${version}/gotify-${platform}.zip
    unzip gotify-${platform}.zip
    chmod +x gotify-${platform}
    check_finish_reboot "${FUNCNAME[0]}"

    #sudo ./gotify-${platform}
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi

  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_logs() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi

  :
  #### TODO
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# This will install OS memcached and php memcached extension
function configure_da_memcached() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    local gc
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    echo "[${SCRIPT_NAME}]: Installing memcached components in OS level ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    # Remember libmemcached-dev is needed for Debian. In CentOS it's called libmemcached-devel
    sudo apt-get -y install memcached libmemcached-tools libmemcached-dev
    gc=$(grep -ic "\-l ::1" /etc/memcached.conf)
    if [ "${gc}" = 0 ]; then
      echo "[${SCRIPT_NAME}]: Setting memcached to listen to IPv6 ..." 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
      sed -i "s/^\-l.*/\-l 127.0.0.1 \-l ::1/" /etc/memcached.conf
    else
      echo "[${SCRIPT_NAME}]: [Skipped] memcached config is already set to listen to IPv6" 2>&1 | tee -a "${REPORT_FILE}"
      sleep 1
    fi
    echo "[${SCRIPT_NAME}]: Restarting memcached ... " 2>&1 | tee -a "${REPORT_FILE}"

    systemctl restart memcached
    echo "[${SCRIPT_NAME}]: Checking memcached status ... " 2>&1 | tee -a "${REPORT_FILE}"

    systemctl --no-pager status memcached
    echo "[${SCRIPT_NAME}]: Installing memcached for php-extension using Poralix script ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    cd_to_path "${INST_TEMP_DIR}"
    cp "${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/usr/local/directadmin/install_scripts/php_extension.sh" "${INST_TEMP_DIR}/php_extension.sh"
    chmod +x php_extension.sh
    # This one just checking not verifying, so whether exist or not we just execute install
    echo "[${SCRIPT_NAME}]: Checking existing php-memcached installation ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    /bin/sh ./php_extension.sh status memcached 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Installing php-memcached for all PHP versions ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 2
    /bin/sh ./php_extension.sh install memcached 2>&1 | tee -a "${REPORT_FILE}"
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi

  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi

}

function configure_da_geoip() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Installing geoip components in OS level ..." 2>&1 | tee -a "${REPORT_FILE}"
    # Just like the memcached need libmemcache-dev, this geoip needs libgeoip-dev
    apt-get -y install libgeoip-dev geoip-bin geoip-database

    echo "[${SCRIPT_NAME}]: Installing geoip for php-extension using Poralix script ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    cd_to_path "${INST_TEMP_DIR}"
    cp "${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/usr/local/directadmin/install_scripts/php_extension.sh" "${INST_TEMP_DIR}/php_extension.sh"
    chmod +x php_extension.sh
    # This one just checking not verifying, so whether exist or not we just execute install
    echo "[${SCRIPT_NAME}]: Checking existing php-geoip installation ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    /bin/sh ./php_extension.sh status geoip 2>&1 | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Installing php-geoip for all PHP versions ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 2
    # For geoip from poralix script, it needs to select --beta because stable release has error during installation
    /bin/sh ./php_extension.sh install geoip --beta 2>&1 | tee -a "${REPORT_FILE}"

    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

configure_da_dns_templates() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_template_custom ipv6_full_uncompressed da_bin da_latest_version
    da_latest_version=$(curl -s https://www.directadmin.com/version.php | grep -Eo "[0-9]+\.[0-9]+")
    da_template_custom="/usr/local/directadmin/data/templates/custom"
    da_bin="/usr/local/directadmin/directadmin"
    mkdir -p "${da_template_custom}"
    chown diradmin:diradmin ${da_template_custom}
    touch "${da_template_custom}/dns_txt.conf"
    echo "DA latest version is ${da_latest_version}. Current DNS config is compatible with DA 1.61.5. Please check compatibility issue"
    echo "[${SCRIPT_NAME}]: Creating SPF, DKIM and DMARC DNS custom template file for Directadmin ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    {
      # Da version 1.61.6 (unreleased) is enabled by default for SPF this: https://www.directadmin.com/features.php?id=2946
      # Remember once it's released check this:
      echo "|DOMAIN|.=\"v=spf1 a mx ip4:|SERVER_IP||EXTRA_SPF| ~all\""
      echo "_dmarc=\"v=DMARC1; p=none; sp=none; rua=mailto:spam-reports@|DOMAIN|\""
      # Currently have issue using this '_domainkey' with API (GUI works): (fixed-added through API manually)
      # https://forum.directadmin.com/threads/possible-bug-when-using-dns_txt-conf-with-api-include-step-to-reproduce.63247/
      echo "_domainkey=\"o=~; r=webmaster@|DOMAIN|\""
      # Google site verification should be here
    } >"${da_template_custom}/dns_txt.conf"
    chmod 644 "${da_template_custom}/dns_txt.conf"
    chown diradmin:diradmin "${da_template_custom}/dns_txt.conf"
    {
      echo "|*if IS_IPV6!=""\"yes\"|"
      echo "|DOMAIN|.=|IP|"
      echo "mail=|IP|"
      echo "pop=|IP|"
      echo "www=|IP|"
      echo "ftp=|IP|"
      echo "smtp=|IP|"
      echo "|*endif|"
    } >"${da_template_custom}/dns_a.conf"
    chmod 644 "${da_template_custom}/dns_a.conf"

    {
      echo "|*if IS_IPV6=""\"yes\"|"
      echo "|DOMAIN|.=|IP|"
      echo "mail=|IP|"
      echo "pop=|IP|"
      echo "www=|IP|"
      echo "ftp=|IP|"
      echo "smtp=|IP|"
      echo "|*endif|"
    } >"${da_template_custom}/dns_aaaa.conf"
    chmod 644 "${da_template_custom}/dns_aaaa.conf"
    # Note last year I use the full form of IP. Remember DA also has ipv6 calculator from directadmin binary.
    ipv6_full_uncompressed=$(ipv6calc --addr2fulluncompaddr "${IPV6_ADD0}")
    echo "[${SCRIPT_NAME}]: Setting extra_spf_value with ipv6:${ipv6_full_uncompressed} ..." 2>&1 | tee -a "${REPORT_FILE}"
    sleep 1
    ${da_bin} set extra_spf_value " ip6:${ipv6_full_uncompressed}" 2>&1 | tee -a "${REPORT_FILE}"
    restart_da
    # rewrite_confs here so that dns_txt.conf is updated
    # Fixed DNS new record updated:
    echo "[${SCRIPT_NAME}]: Updating DNS template ..." 2>&1 | tee -a "${REPORT_FILE}"
    /usr/local/directadmin/custombuild/build rewrite_confs
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}
# Maybe we need to log into owner (so we fix the menu, time format etc)
# it's best not to use owner. Use admin instead to manage DA user for security purpose
function configure_da_owner_skins() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # We can customize this skin evolution based on this file /usr/local/directadmin/data/users/username/skin_customization/evolution/user_options.json
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    da_api_admin "signas+owner"

    # 1) misc options
    # Set the predefined setting
    da_api_admin "set-da-options" "evolution"

    # 2) configure the Skin Options from menu
    # a) Set logo
    # There is no official documentation how to upload a directadmin logo using API.
    # Da needs this home temporary folder to hold upload file
    mkdir -p /home/tmp
    default_logo_file="${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/usr/local/directadmin/logo/default_logo.png"
    # The upload file need to have random string append to it else it won't work:
    # https://forum.directadmin.com/threads/cmd_api_skins-upload-skin-logo-via-curl-issue.63127/
    # I use random length of 6 because I saw DA always generated length of 6 when append this random string to a file
    default_logo_file_home="/home/tmp/logo.png$(get_rnd_alpha 6)"
    dark_mode_logo_file="${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/usr/local/directadmin/logo/dark_mode_logo.png"
    dark_mode_logo_file_home="/home/tmp/logo2.png$(get_rnd_alpha 6)"

    # Copy the logo files from storage data to the temporary home directory
    cp "${default_logo_file}" "${default_logo_file_home}"
    cp "${dark_mode_logo_file}" "${dark_mode_logo_file_home}"

    # The files that need to be uploaded need to have nobody permission (else it wont work)
    chown nobody:nogroup "${default_logo_file_home}"
    chown nobody:nogroup "${dark_mode_logo_file_home}"

    if [ -f "${default_logo_file_home}" ]; then
      da_api_admin "set-da-logo" evolution default-logo "${default_logo_file_home}"
    else
      echo "[${SCRIPT_NAME}]: Warning, file logo is missing from ${default_logo_file_home}" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi

    if [ -f "${dark_mode_logo_file_home}" ]; then
      da_api_admin "set-da-logo" evolution dark-logo "${dark_mode_logo_file_home}"
    else
      echo "[${SCRIPT_NAME}]: Warning, file logo is missing from ${dark_mode_logo_file_home}" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi

    # Remove both temporary logo from the home directory
    rm -f "${default_logo_file_home}"
    rm -f "${dark_mode_logo_file_home}"

    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# Configure DA skins like set the time format, set logo (focus on Evolution Skin)
function configure_da_admin_skins() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # We can customize this skin evolution based on this file /usr/local/directadmin/data/users/username/skin_customization/evolution/user_options.json
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    da_api_admin "signas+admin"

    # 1) misc options
    # Set the predefined setting
    da_api_admin "set-da-options" "evolution"

    # 2) configure the Skin Options from menu
    # a) Set logo
    # There is no official documentation how to upload a directadmin logo using API.
    # Da needs this home temporary folder to hold upload file
    mkdir -p /home/tmp
    default_logo_file="${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/usr/local/directadmin/logo/default_logo.png"
    # The upload file need to have random string append to it else it won't work:
    # https://forum.directadmin.com/threads/cmd_api_skins-upload-skin-logo-via-curl-issue.63127/
    # I use random length of 6 because I saw DA always generated length of 6 when append this random string to a file
    default_logo_file_home="/home/tmp/logo.png$(get_rnd_alpha 6)"
    dark_mode_logo_file="${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/usr/local/directadmin/logo/dark_mode_logo.png"
    dark_mode_logo_file_home="/home/tmp/logo2.png$(get_rnd_alpha 6)"

    # Copy the logo files from storage data to the temporary home directory
    cp "${default_logo_file}" "${default_logo_file_home}"
    cp "${dark_mode_logo_file}" "${dark_mode_logo_file_home}"

    # The files that need to be uploaded need to have nobody permission (else it wont work)
    chown nobody:nogroup "${default_logo_file_home}"
    chown nobody:nogroup "${dark_mode_logo_file_home}"

    if [ -f "${default_logo_file_home}" ]; then
      da_api_admin "set-da-logo" evolution default-logo "${default_logo_file_home}"
    else
      echo "[${SCRIPT_NAME}]: Warning, file logo is missing from ${default_logo_file_home}" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi

    if [ -f "${dark_mode_logo_file_home}" ]; then
      da_api_admin "set-da-logo" evolution dark-logo "${dark_mode_logo_file_home}"
    else
      echo "[${SCRIPT_NAME}]: Warning, file logo is missing from ${dark_mode_logo_file_home}" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi

    # Remove both temporary logo from the home directory
    rm -f "${default_logo_file_home}"
    rm -f "${dark_mode_logo_file_home}"

    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_reseller_skins() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    da_api_admin "signas+reseller"
    # 1) misc options
    # Set the predefined setting
    da_api_admin "set-da-options" "evolution"

    # 2) configure the Skin Options from menu
    # a) Set logo
    # There is no official documentation how to upload a directadmin logo using API.
    # Da needs this home temporary folder to hold upload file
    mkdir -p /home/tmp
    default_logo_file="${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/usr/local/directadmin/logo/default_logo.png"
    # The upload file need to have random string append to it else it won't work:
    # https://forum.directadmin.com/threads/cmd_api_skins-upload-skin-logo-via-curl-issue.63127/
    # I use random length of 6 because I saw DA always generated length of 6 when append this random string to a file
    default_logo_file_home="/home/tmp/logo.png$(get_rnd_alpha 6)"
    dark_mode_logo_file="${DATA_PATH}/maxisetup/storage/os/${DISTRO_ID}/usr/local/directadmin/logo/dark_mode_logo.png"
    dark_mode_logo_file_home="/home/tmp/logo2.png$(get_rnd_alpha 6)"

    # Copy the logo files from storage data to the temporary home directory
    cp "${default_logo_file}" "${default_logo_file_home}"
    cp "${dark_mode_logo_file}" "${dark_mode_logo_file_home}"

    # The files that need to be uploaded need to have nobody permission (else it wont work)
    chown nobody:nogroup "${default_logo_file_home}"
    chown nobody:nogroup "${dark_mode_logo_file_home}"

    if [ -f "${default_logo_file_home}" ]; then
      da_api_admin "set-da-logo" evolution default-logo "${default_logo_file_home}"
    else
      echo "[${SCRIPT_NAME}]: Warning, file logo is missing from ${default_logo_file_home}" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi

    if [ -f "${dark_mode_logo_file_home}" ]; then
      da_api_admin "set-da-logo" evolution dark-logo "${dark_mode_logo_file_home}"
    else
      echo "[${SCRIPT_NAME}]: Warning, file logo is missing from ${dark_mode_logo_file_home}" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi

    # Remove both temporary logo from the home directory
    rm -f "${default_logo_file_home}"
    rm -f "${dark_mode_logo_file_home}"

    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_admin_admin_settings() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  :
  ######
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_owner_accounts() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "Renaming owner account name to ${DA_OWNER_NAME1} ..."
    da_api_admin "signas+owner"
    da_api_admin "modify-user" "${DA_OWNER_USERNAME1}" "name" "${DA_OWNER_NAME1}"
    #echo "[${SCRIPT_NAME}]: Restarting directadmin before configuring Directadmin accounts ..." 2>&1 | tee -a "${REPORT_FILE}"
    #restart_da
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}
# This function is to configure da_admin accounts
# eg: You can create any extra admin accounts here or create multiple reseller packages.
# Note: Only DA owner or existing admin can create another admin account
function configure_da_admin_accounts() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    # An owner account must exist (this script will complain if it doesn't exist)
    # We will use admin account to fully manage DA instead of owner for security but for API we only use DA owner account
    #echo "[${SCRIPT_NAME}]: Restarting directadmin before configuring Directadmin admin accounts ..." 2>&1 | tee -a "${REPORT_FILE}"
    #restart_da
    echo "[${SCRIPT_NAME}]: Creating new DA admin account ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
    # Must sign in as owner to create a new admin account. If sign in as admin you get error admin not exist
    # Start owner session to use API (it will automatically destroy after execution or use da_api_admin "end+owner" to destroy manually)
    # da_api_admin "signas+owner" means we sign-in as owner
    da_api_admin "signas+owner"
    # While signing as owner, we use this owner account to create an admin account in Directadmin using this syntax:
    da_api_admin "create-admin-account" "${DA_ADMIN_USERNAME1}" "${DA_ADMIN_SYSTEM_EMAIL1}" "${DA_ADMIN_USERPASS1}"
    echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
    echo ""
    echo ""
    echo "[${SCRIPT_NAME}]: Renaming admin account default name 'admin' to '${DA_ADMIN_NAME1}' ..."
    echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
    da_api_admin "modify-user" "${DA_ADMIN_USERNAME1}" "name" "${DA_ADMIN_NAME1}"
    echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
    echo ""
    echo ""
    # No need domain for admin for security
    # First create reseller unlimited package
    # Make sure admin account is created first (da_api_admin will check this)
    echo "[${SCRIPT_NAME}]: Creating a new unlimited package for resellers with the following name: ${DA_RESELLER_PACKAGE_NAME1} ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
    # Use admin to create reseller package (dont use owner for security purpose)
    da_api_admin "signas+admin"
    da_api_admin "create-reseller-package" "${DA_RESELLER_PACKAGE_NAME1}"
    echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
    echo ""
    echo ""
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}
# Create reseller accounts here including packages and reseller and all domains
# For security purpose, all reseller users creation depend on admin account. So, we must create at least an admin account to manage this
# We will use this admin account to assign reseller package. After a reseller package is created then we can create reseller account
# In package creation, for security do not use anonymous FTP accounts, do not use SSH access
# Info & URL: Check if reseller package is created
# https://forum.directadmin.com/threads/server-migration-how-to-use-the-existing-configuration-during-setup.62937/
# https://forum.directadmin.com/threads/default-user-package-s-for-resellers.49156/

function configure_da_reseller_accounts() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  #rm -rf "${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_reseller_packages_list gc

    local da_reseller_unames da_reseller_count count_r

    local this_da_reseller_uname this_da_reseller_password this_da_reseller_system_email \
      this_da_reseller_mail_users this_da_reseller_mail_passwords this_da_reseller_domains \
      this_da_reseller_ip_type this_da_reseller_package_name this_da_reseller_enable_domain_ssl

    # Inside this file contains list of packages for admin and reseller (use this file for checking existing package)
    da_reseller_packages_list="/usr/local/directadmin/data/admin/packages.list"
    # Restarting Directadmin to clear pending Directadmin cron
    echo "[${SCRIPT_NAME}]: Restarting directadmin before configuring Directadmin accounts ..." 2>&1 | tee -a "${REPORT_FILE}"
    restart_da

    # Get reseller account information dynamically based on the config files:
    da_reseller_unames="${!DA_RESELLER_USERNAME@}"
    # Count the total number of reseller account from config file
    da_reseller_count=$(echo "${da_reseller_unames}" | wc -w)
    # Debug variables:
    echo "List of resellers information from config is: " 2>&1 | tee -a "${REPORT_FILE}"
    echo "==---==---==" 2>&1 | tee -a "${REPORT_FILE}"
    echo "${da_reseller_unames}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "Total reseller: ${da_reseller_count}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "==---==---==" 2>&1 | tee -a "${REPORT_FILE}"
    echo "" 2>&1 | tee -a "${REPORT_FILE}"

    # Adding reseller by looping
    count_r=1
    while [[ ${count_r} -le ${da_reseller_count} ]]; do
      echo "" 2>&1 | tee -a "${REPORT_FILE}"
      echo "=========== start DEBUG value ========="
      echo "Executing while loop: count=${count_r} while less than da_user_count ${da_reseller_count}"
      typeset -n "this_da_reseller_uname"="DA_RESELLER_USERNAME${count_r}"
      typeset -n "this_da_reseller_name"="DA_RESELLER_NAME${count_r}"
      typeset -n "this_da_reseller_password"="DA_RESELLER_USERPASS${count_r}"
      typeset -n "this_da_reseller_system_email"="DA_RESELLER_SYSTEM_EMAIL${count_r}"
      typeset -n "this_da_reseller_mail_users"="DA_RESELLER_MAIL_USER${count_r}"
      typeset -n "this_da_reseller_mail_passwords"="DA_RESELLER_MAIL_PASSWORD${count_r}"
      typeset -n "this_da_reseller_domains"="DA_RESELLER_DOMAIN${count_r}"
      typeset -n "this_da_reseller_ip_type"="DA_RESELLER_IP_TYPE${count_r}"
      typeset -n "this_da_reseller_package_name"="DA_RESELLER_PACKAGE_NAME${count_r}"
      typeset -n "this_da_reseller_enable_domain_ssl"="DA_RESELLER_ENABLE_DOMAIN_SSL${count_r}"
      echo ""
      echo "=========== start reseller value ========="
      echo "this_da_reseller_uname = ${this_da_reseller_uname}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_name = ${this_da_reseller_name}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_password = ${this_da_reseller_password}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_system_email = ${this_da_reseller_system_email}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_mail_users = ${this_da_reseller_mail_users[*]}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_mail_passwords = ${this_da_reseller_mail_passwords[*]}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_domains = ${this_da_reseller_domains[*]}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_ip_type = ${this_da_reseller_ip_type}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_package_name = ${this_da_reseller_package_name}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_enable_domain_ssl = ${this_da_reseller_enable_domain_ssl}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "=========== end reseller value =========" 2>&1 | tee -a "${REPORT_FILE}"

      echo "[${SCRIPT_NAME}]: Checking if reseller package name ${this_da_reseller_package_name} was created by admin before ..." 2>&1 | tee -a "${REPORT_FILE}"
      #_pause 2
      gc=$(grep -ic "${this_da_reseller_package_name}" "${da_reseller_packages_list}")
      if [ "${gc}" -gt 0 ]; then
        # The total domain count for this reseller
        da_reseller_domain_count="${#this_da_reseller_domains[@]}"
        # The first domain is used to create account (default domain for that reseller)
        da_reseller_domain_first=$(echo "${this_da_reseller_domains[@]}" | awk '{ print $1 }')
        echo "-=-=-=-=-=-=-=" 2>&1 | tee -a "${REPORT_FILE}"
        echo "This reseller ${this_da_reseller_uname} has the following domain(s): " 2>&1 | tee -a "${REPORT_FILE}"
        echo "${this_da_reseller_domains}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "Domain count: ${da_reseller_domain_count}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "The first domain is: ${da_reseller_domain_first}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "-=-=-=-=-=-=-=" 2>&1 | tee -a "${REPORT_FILE}"

        # Use admin to create reseller account and its default domain:
        #echo "[${SCRIPT_NAME}]: Authenticating Directadmin API as a default admin (first admin account) ..." 2>&1 | tee -a "${REPORT_FILE}"
        da_api_admin "signas+admin"
        echo "[${SCRIPT_NAME}]: Creating reseller account ${this_da_reseller_uname} using the following details: "
        #echo "Username: ${this_da_reseller_uname} | Email: ${this_da_reseller_system_email} | Password: ${this_da_reseller_password} | Default (First) domain: ${da_reseller_domain_first} | Package selection: ${this_da_reseller_package_name}"
        #_pause 2
        echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
        da_api_admin "create-reseller-account" "${this_da_reseller_uname}" "${this_da_reseller_system_email}" "${this_da_reseller_password}" "${da_reseller_domain_first}" "${this_da_reseller_package_name}" "${this_da_reseller_ip_type}"
        echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
        echo "" 2>&1 | tee -a "${REPORT_FILE}"
        echo "" 2>&1 | tee -a "${REPORT_FILE}"
        echo "[${SCRIPT_NAME}]: Renaming reseller account name to ${this_da_reseller_name} ..."
        echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
        # Still use the admin signas above to modify reseller info here:
        da_api_admin "modify-user" "${this_da_reseller_uname}" "name" "${this_da_reseller_name}"
        echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
        echo "" 2>&1 | tee -a "${REPORT_FILE}"
        echo "" 2>&1 | tee -a "${REPORT_FILE}"
        # Use each reseller account to enable its own email DKIM
        # Use reseller account to configure its own user-level variable settings like DKIM or DNS
        echo "[${SCRIPT_NAME}]: Enabling email DKIM for the domain ${da_reseller_domain_first} ..." 2>&1 | tee -a "${REPORT_FILE}"
        echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
        #_pause 2
        da_api_admin "signas+${this_da_reseller_uname}+${this_da_reseller_password}"
        da_api_admin "enable-email-dkim" "${da_reseller_domain_first}"
        echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
        echo "" 2>&1 | tee -a "${REPORT_FILE}"
        echo "" 2>&1 | tee -a "${REPORT_FILE}"

        # Still use the signas login above to create TXT record _domainkey for DKIM signing policy
        echo "[${SCRIPT_NAME}]: Creating DA TXT DNS for DKIM signing policy for ${da_reseller_domain_first} ..." 2>&1 | tee -a "${REPORT_FILE}"
        echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
        da_api_admin "create-dns-record" "${da_reseller_domain_first}" "TXT" "_domainkey" "o%3D%7E%3B+r%3Dwebmaster%40${da_reseller_domain_first}"
        echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
        echo "" 2>&1 | tee -a "${REPORT_FILE}"
        echo "" 2>&1 | tee -a "${REPORT_FILE}"

        # Get the DKIM DMARC and SPF record from Directadmin local DNS:
        echo "[${SCRIPT_NAME}]: Getting DKIM, DMARC and SPF records from Directadmin local DNS ..." 2>&1 | tee -a "${REPORT_FILE}"
        echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
        dkim_val=$(da_api_admin "get-dns-zone" "${da_reseller_domain_first}" "x._domainkey+TXT+v=DKIM1+.value" | tail -n 1) || exit 1
        dkim_val_count=$(echo "${dkim_val}" | wc -l)
        dkim_policy_val=$(da_api_admin "get-dns-zone" "${da_reseller_domain_first}" "_domainkey+TXT+o=+.value" | tail -n 1) || exit 1
        dkim_policy_val_count=$(echo "${dkim_policy_val}" | wc -l)
        dmarc_val=$(da_api_admin "get-dns-zone" "${da_reseller_domain_first}" "_dmarc+TXT+v=DMARC1+.value" | tail -n 1) || exit 1
        dmarc_val_count=$(echo "${dmarc_val}" | wc -l)
        spf_val=$(da_api_admin "get-dns-zone" "${da_reseller_domain_first}" "${da_reseller_domain_first}.+TXT+v=spf1+.value" | tail -n 1) || exit 1
        spf_val_count=$(echo "${spf_val}" | wc -l)
        echo "There is/are ${dkim_val_count} dkim value for this reseller domain ${da_reseller_domain_first}. First value is: ${dkim_val}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "There is/are ${dkim_policy_val_count} dkim policy value for this domain ${da_reseller_domain_first}. First value is: ${dkim_policy_val}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "There is/are ${dmarc_val_count} dmarc value for this reseller domain ${da_reseller_domain_first}. First value is: ${dmarc_val}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "There is/are ${spf_val_count} spf value for this reseller domain ${da_reseller_domain_first}. First value is: ${spf_val}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
        echo "" 2>&1 | tee -a "${REPORT_FILE}"
        echo "" 2>&1 | tee -a "${REPORT_FILE}"

        if [ "${EXTERNAL_DNS_PROVIDER}" == "linode" ]; then
          echo "[${SCRIPT_NAME}]: External DNS provider for domain ${da_reseller_domain_first} is set to linode [Using linode API ...]" 2>&1 | tee -a "${REPORT_FILE}"
          echo "***"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          echo "[${SCRIPT_NAME}]: Creating domain ${da_reseller_domain_first} in linode DNS management ..."
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"

          linode_api_admin "create-domain" "master" "${da_reseller_domain_first}" "${this_da_reseller_system_email}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          # For mx record, linode_api_admin "add-dns-record" "maxibi.com" "MX" "mail" "sofibox.com." "5"
          echo "[${SCRIPT_NAME}]: Creating MX record for ${da_reseller_domain_first} in linode DNS management ..."
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          linode_api_admin "add-dns-record" "${da_reseller_domain_first}" "MX" "mail" "${da_reseller_domain_first}." "5"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          echo "[${SCRIPT_NAME}]: Deleting external DNS record on linode for domain ${da_reseller_domain_first} ... "
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "[linode delete-dns-record]: Name: _domainkey | Type: TXT" 2>&1 | tee -a "${REPORT_FILE}"
          #_pause 2
          echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
          linode_api_admin "delete-dns-record" "${da_reseller_domain_first}" "_domainkey" "TXT"
          echo "[linode delete-dns-record]: Name: x._domainkey | Type: TXT" 2>&1 | tee -a "${REPORT_FILE}"
          #_pause 2
          echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
          linode_api_admin "delete-dns-record" "${da_reseller_domain_first}" "x._domainkey" "TXT"
          echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
          echo "[linode delete-dns-record]: Name: _dmarc | Type: TXT" 2>&1 | tee -a "${REPORT_FILE}"
          #_pause 2
          echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
          linode_api_admin "delete-dns-record" "${da_reseller_domain_first}" "_dmarc" "TXT" 2>&1 | tee -a "${REPORT_FILE}"
          echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
          echo "[linode delete-dns-record]: Name: empty-string | Type: TXT" 2>&1 | tee -a "${REPORT_FILE}"
          #_pause 2
          echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
          linode_api_admin "delete-dns-record" "${da_reseller_domain_first}" "" "TXT" 2>&1 | tee -a "${REPORT_FILE}"
          echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
          echo "End of deletion DNS record on linode ======= " 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          echo "[${SCRIPT_NAME}]: Adding external DNS record on linode for domain ${da_reseller_domain_first} ... "
          echo "[linode add-dns-record]: Name: _domainkey | Value: ${dkim_policy_val} | Type: TXT | TTL: 5" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          #_pause 2
          echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
          linode_api_admin "add-dns-record" "${da_reseller_domain_first}" "TXT" "_domainkey" "${dkim_policy_val}" "5" 2>&1 | tee -a "${REPORT_FILE}"
          echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          echo "[linode add-dns-record]: Name: x._domainkey | Value: ${dkim_val} | Type: TXT | TTL: 5" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          #_pause 2
          echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
          linode_api_admin "add-dns-record" "${da_reseller_domain_first}" "TXT" "x._domainkey" "${dkim_val}" "5" 2>&1 | tee -a "${REPORT_FILE}"
          echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          echo "[linode add-dns-record]: Name: _dmarc | Value: ${dmarc_val} | Type: TXT | TTL: 5" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          #_pause 2
          echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
          linode_api_admin "add-dns-record" "${da_reseller_domain_first}" "TXT" "_dmarc" "${dmarc_val}" "5" 2>&1 | tee -a "${REPORT_FILE}"
          echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          echo "[linode add-dns-record]: Name: ${da_reseller_domain_first} | Value: ${spf_val} | Type: TXT | TTL: 5" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          #_pause 2
          echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
          linode_api_admin "add-dns-record" "${da_reseller_domain_first}" "TXT" "${da_reseller_domain_first}" "${spf_val}" "5" 2>&1 | tee -a "${REPORT_FILE}"
          echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          echo "End of creation DNS record on linode ======= " 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
        elif [ "${EXTERNAL_DNS_PROVIDER}" == "digitalocean" ]; then
          echo "[${SCRIPT_NAME}]: External DNS provider for domain ${da_reseller_domain_first} is set to digitalocean [Using digitalocean API ...]" 2>&1 | tee -a "${REPORT_FILE}"
          # Call digitalocean_api_admin
        #elif other provider
        elif [ "${EXTERNAL_DNS_PROVIDER}" == "local" ]; then
          echo "[${SCRIPT_NAME}]: External DNS provider for domain ${da_reseller_domain_first} is set to local" 2>&1 | tee -a "${REPORT_FILE}"
          # Do nothing because it's local DNS managed by Directadmin
        fi

        # This will be executed if reseller has more than 1 domains. We add the extra domains here and skipped the default domain:
        if [ "${da_reseller_domain_count}" -gt 1 ]; then
          echo "[${SCRIPT_NAME}]: This reseller ${this_da_reseller_uname} has ${da_reseller_domain_count} domain(s)" 2>&1 | tee -a "${REPORT_FILE}"
          #sleep 1
          echo ""
          for extra_domain in "${this_da_reseller_domains[@]}"; do
            # Don't add first domain, we did that before (when we first create user account, DA automatically add this default domain)
            if [ "${extra_domain}" == "${da_reseller_domain_first}" ]; then
              echo "[${SCRIPT_NAME}]: Skipped adding the default domain: ${da_reseller_domain_first}"
              #sleep 1
              continue
            fi

            echo "[${SCRIPT_NAME}]: Creating extra domain ${extra_domain} for reseller ${this_da_reseller_uname} ..." 2>&1 | tee -a "${REPORT_FILE}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            #_pause 2
            # Calling reseller authentication
            #echo "[${SCRIPT_NAME}]: Authenticating Directadmin API for reseller ${this_da_reseller_uname} ..." 2>&1 | tee -a "${REPORT_FILE}"
            da_api_admin "signas+${this_da_reseller_uname}+${this_da_reseller_password}"
            da_api_admin "create-reseller-domain" "${extra_domain}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"

            echo "[${SCRIPT_NAME}]: Enabling email DKIM for extra domain ${extra_domain} for reseller ${this_da_reseller_uname} ..." 2>&1 | tee -a "${REPORT_FILE}"
            #_pause 2
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            da_api_admin "enable-email-dkim" "${extra_domain}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"

            echo "[${SCRIPT_NAME}]: Creating DA TXT DNS for DKIM signing policy for ${extra_domain} ..." 2>&1 | tee -a "${REPORT_FILE}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            da_api_admin "create-dns-record" "${extra_domain}" "TXT" "_domainkey" "o%3D%7E%3B+r%3Dwebmaster%40${extra_domain}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"

            echo "[${SCRIPT_NAME}]: Getting DKIM, DMARC and SPF records from Directadmin local DNS ..." 2>&1 | tee -a "${REPORT_FILE}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            # Make sure if duplicated entry found, just return 1 line with tail -n 1
            dkim_val=$(da_api_admin "get-dns-zone" "${extra_domain}" "x._domainkey+TXT+v=DKIM1+.value" | tail -n 1) || exit 1
            dkim_val_count=$(echo "${dkim_val}" | wc -l)
            dkim_policy_val=$(da_api_admin "get-dns-zone" "${extra_domain}" "_domainkey+TXT+o=+.value" | tail -n 1) || exit 1
            dkim_policy_val_count=$(echo "${dkim_policy_val}" | wc -l)
            dmarc_val=$(da_api_admin "get-dns-zone" "${extra_domain}" "_dmarc+TXT+v=DMARC1+.value" | tail -n 1) || exit 1
            dmarc_val_count=$(echo "${dmarc_val}" | wc -l)
            spf_val=$(da_api_admin "get-dns-zone" "${extra_domain}" "${extra_domain}.+TXT+v=spf1+.value" | tail -n 1) || exit 1
            spf_val_count=$(echo "${spf_val}" | wc -l)
            echo "There is/are ${dkim_val_count} dkim value for this extra_domain ${extra_domain}. First value is: ${dkim_val}"
            echo "There is/are ${dmarc_val_count} dmarc value for this extra_domain ${extra_domain}. First value is: ${dmarc_val}"
            echo "There is/are ${spf_val_count} spf value for this extra_domain ${extra_domain}. First value is: ${spf_val}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"

            if [ "${EXTERNAL_DNS_PROVIDER}" == "linode" ]; then
              echo "[${SCRIPT_NAME}]: External DNS provider for extra domain ${extra_domain} is set to linode [Using linode API ...]" 2>&1 | tee -a "${REPORT_FILE}"
              echo "***"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"
              echo "[${SCRIPT_NAME}]: Creating domain ${extra_domain} in linode DNS management ..."
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"

              linode_api_admin "create-domain" "master" "${extra_domain}" "${this_da_reseller_system_email}"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"

              # For mx record, linode_api_admin "add-dns-record" "maxibi.com" "MX" "mail" "sofibox.com." "5"
              echo "[${SCRIPT_NAME}]: Creating MX record for ${extra_domain} in linode DNS management ..."
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              linode_api_admin "add-dns-record" "${extra_domain}" "MX" "mail" "${extra_domain}." "5"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"

              echo "[${SCRIPT_NAME}]: Deleting external DNS record on linode for domain ${extra_domain} ... "
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              echo "[linode delete-dns-record]: Name: _domainkey | Type: TXT" 2>&1 | tee -a "${REPORT_FILE}"
              #_pause 2
              echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
              linode_api_admin "delete-dns-record" "${extra_domain}" "_domainkey" "TXT"
              echo "[linode delete-dns-record]: Name: x._domainkey | Type: TXT" 2>&1 | tee -a "${REPORT_FILE}"
              #_pause 2
              echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
              linode_api_admin "delete-dns-record" "${extra_domain}" "x._domainkey" "TXT"
              echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
              echo "[linode delete-dns-record]: Name: _dmarc | Type: TXT" 2>&1 | tee -a "${REPORT_FILE}"
              #_pause 2
              echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
              linode_api_admin "delete-dns-record" "${extra_domain}" "_dmarc" "TXT" 2>&1 | tee -a "${REPORT_FILE}"
              echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
              echo "[linode delete-dns-record]: Name: empty-string | Type: TXT" 2>&1 | tee -a "${REPORT_FILE}"
              #_pause 2
              echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
              linode_api_admin "delete-dns-record" "${extra_domain}" "" "TXT" 2>&1 | tee -a "${REPORT_FILE}"
              echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
              echo "End of deletion DNS record on linode ======= " 2>&1 | tee -a "${REPORT_FILE}"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"

              echo "[${SCRIPT_NAME}]: Adding external DNS record on linode for domain ${extra_domain} ... "
              echo "[linode add-dns-record]: Name: _domainkey | Value: ${dkim_policy_val} | Type: TXT | TTL: 5" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"
              #_pause 2
              echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
              linode_api_admin "add-dns-record" "${extra_domain}" "TXT" "_domainkey" "${dkim_policy_val}" "5" 2>&1 | tee -a "${REPORT_FILE}"
              echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"

              echo "[linode add-dns-record]: Name: x._domainkey | Value: ${dkim_val} | Type: TXT | TTL: 5" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"
              #_pause 2
              echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
              linode_api_admin "add-dns-record" "${extra_domain}" "TXT" "x._domainkey" "${dkim_val}" "5" 2>&1 | tee -a "${REPORT_FILE}"
              echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"

              echo "[linode add-dns-record]: Name: _dmarc | Value: ${dmarc_val} | Type: TXT | TTL: 5" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"
              #_pause 2
              echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
              linode_api_admin "add-dns-record" "${extra_domain}" "TXT" "_dmarc" "${dmarc_val}" "5" 2>&1 | tee -a "${REPORT_FILE}"
              echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"

              echo "[linode add-dns-record]: Name: ${extra_domain} | Value: ${spf_val} | Type: TXT | TTL: 5" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"
              #_pause 2
              echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
              linode_api_admin "add-dns-record" "${extra_domain}" "TXT" "${extra_domain}" "${spf_val}" "5" 2>&1 | tee -a "${REPORT_FILE}"
              echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"
              echo "End of creation DNS record on linode ======= " 2>&1 | tee -a "${REPORT_FILE}"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"

            elif [ "${EXTERNAL_DNS_PROVIDER}" == "digitalocean" ]; then
              echo "[${SCRIPT_NAME}]: External DNS provider for domain ${extra_domain} is set to digitalocean [Using digitalocean API ...]" 2>&1 | tee -a "${REPORT_FILE}"
              # Call digitalocean_api_admin
            #elif other provider
            elif [ "${EXTERNAL_DNS_PROVIDER}" == "local" ]; then
              echo "[${SCRIPT_NAME}]: External DNS provider for domain ${extra_domain} is set to local" 2>&1 | tee -a "${REPORT_FILE}"
              # Do nothing because it's local DNS managed by Directadmin
            fi
          done # End looping for adding extra domains
        fi
      else
        echo "[${SCRIPT_NAME}]: Warning, ${this_da_reseller_package_name} does not exist in ${da_reseller_packages_list}. Please inspect why!" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi
      echo "*** Total count: ${count_r} ***" 2>&1 | tee -a "${REPORT_FILE}"
      ((count_r++))
      #sleep 10
      echo "--" 2>&1 | tee -a "${REPORT_FILE}"
      echo "" 2>&1 | tee -a "${REPORT_FILE}"
    done # End looping

    # Now we create user unlimited package. A reseller account is needed to create user package (da_api_admin will check this condition)
    # We use reseller account to create user package:

    # Assign DA_USER_PACKAGE_NAME1 because it's the first package for user
    echo "[${SCRIPT_NAME}]: Creating user unlimited package with the following name: ${DA_USER_PACKAGE_NAME1} ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
    #_pause 2
    #echo "[${SCRIPT_NAME}]: Authenticating DA API for user for default reseller user ..." 2>&1 | tee -a "${REPORT_FILE}"
    da_api_admin "signas+reseller"
    da_api_admin "create-user-package" "${DA_USER_PACKAGE_NAME1}"
    echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
    echo "" 2>&1 | tee -a "${REPORT_FILE}"
    echo "" 2>&1 | tee -a "${REPORT_FILE}"

    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_reseller_root_domains() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_reseller_domains da_reseller_domains_count this_da_reseller_username this_da_reseller_userpass \
      this_da_reseller_domains this_da_reseller_domains_count
    local count_x count_n count_o domain
    # Get list of all reseller subdomains
    da_reseller_domains="${!DA_RESELLER_DOMAIN@}"
    # Count the total domains
    da_reseller_domains_count=$(echo "${da_reseller_domains}" | wc -w)
    # Debug:
    echo "da_reseller_domains: ${da_reseller_domains}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "da_reseller_domains_count ${da_reseller_domains_count}" 2>&1 | tee -a "${REPORT_FILE}"
    # initial value to loop
    count_x=1
    while [[ ${count_x} -le ${da_reseller_domains_count} ]]; do
      echo "Count_x: ${count_x}"
      echo "DA_RESELLER_DOMAINS_COUNT ${da_reseller_domains_count}"
      echo "=~=~=~=~=~=~=~=~=~+~+~+~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
      echo "count_reseller_domain_loop = ${count_x}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "" 2>&1 | tee -a "${REPORT_FILE}"
      typeset -n "this_da_reseller_username"="DA_RESELLER_USERNAME${count_x}"
      typeset -n "this_da_reseller_userpass"="DA_RESELLER_USERPASS${count_x}"

      this_da_reseller_domains=$(cat "/usr/local/directadmin/data/users/${this_da_reseller_username}/domains.list")
      # Debug:
      echo "this_da_reseller_username: ${this_da_reseller_username}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_userpass: ${this_da_reseller_userpass}" 2>&1 | tee -a "${REPORT_FILE}"

      echo "this_da_reseller_domains: ${this_da_reseller_domains[*]}" 2>&1 | tee -a "${REPORT_FILE}"
      this_da_reseller_domains_count=$(echo "${this_da_reseller_domains}" | wc -w)
      echo "this_da_reseller_domains_count: ${this_da_reseller_domains_count}"
      count_n=1
      while [ ${count_n} -le "${this_da_reseller_domains_count}" ]; do
        echo "------------------------" 2>&1 | tee -a "${REPORT_FILE}"
        echo "Total count: ${count_n}" 2>&1 | tee -a "${REPORT_FILE}"
        count_o=0
        for domain in ${this_da_reseller_domains}; do
          echo "count_o: ${count_o}"
          # Debug
          echo "domain is set: ${domain}" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          echo "[${SCRIPT_NAME}]: Creating root domain ${domain} for both IPv4 and IPv6 ..." 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          da_api_admin "signas+${this_da_reseller_username}+${this_da_reseller_userpass}"
          # Note if record exist, it won't create in DA
          da_api_admin "create-dns-record" "${domain}" "A" "${domain}." "${IPV4_ADD0}"
          da_api_admin "create-dns-record" "${domain}" "AAAA" "${domain}." "$(ipv6calc --addr2uncompaddr "${IPV6_ADD0}")"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          if [ "${EXTERNAL_DNS_PROVIDER}" == "linode" ]; then
            # In linode DNS record are duplicated, we don't want so must delete previous record first before adding new
            echo "[${SCRIPT_NAME}]: DNS provider is set to linode. Using linode API" 2>&1 | tee -a "${REPORT_FILE}"

            echo "[${SCRIPT_NAME}]: Deleting root ${domain} record for IPv4 and IPv6 from linode" 2>&1 | tee -a "${REPORT_FILE}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            # In linode empty there means hostname or I can use @ or try domain.com
            linode_api_admin "delete-dns-record" "${domain}" "" "A"
            linode_api_admin "delete-dns-record" "${domain}" "" "AAAA"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"

            # Also add wildcard domain for linode API here
            echo "[${SCRIPT_NAME}]: Adding wildcard domain ${domain} record for IPv4 and IPv6 from linode" 2>&1 | tee -a "${REPORT_FILE}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            #In linode empty there means hostname or I can use @ or try domain.com
            linode_api_admin "add-dns-record" "${domain}" "A" "" "${IPV4_ADD0}" "5"
            linode_api_admin "add-dns-record" "${domain}" "AAAA" "" "${IPV6_ADD0}" "5"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"
          elif [ "${EXTERNAL_DNS_PROVIDER}" == "digitalocean" ]; then
            echo "[${SCRIPT_NAME}]: DNS provider is set to digitalocean" 2>&1 | tee -a "${REPORT_FILE}"
            # Call digitalocean_api_admin
            #elif other provider
          elif [ "${EXTERNAL_DNS_PROVIDER}" == "local" ]; then
            echo "[${SCRIPT_NAME}]: DNS provider is set to local (Internal DNS)" 2>&1 | tee -a "${REPORT_FILE}"
            # Do nothing
          fi
          ((count_o++))
        done
        ((count_n++))
      done
      ((count_x++))
    done
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}
function configure_da_reseller_wildcard_domains() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_reseller_wildcard_domains da_reseller_wildcard_domains_count this_da_reseller_username this_da_reseller_userpass \
      this_da_reseller_wildcard_domains this_da_reseller_wildcard_domains_count
    local count_x count_n count_o wildcard_domain wildcard_domains
    # Get list of all reseller subdomains
    da_reseller_wildcard_domains="${!DA_RESELLER_WILDCARD_DOMAIN@}"
    # Count the total wildcard domains
    da_reseller_wildcard_domains_count=$(echo "${da_reseller_wildcard_domains}" | wc -w)
    # Debug:
    echo "da_reseller_wildcard_domains: ${da_reseller_wildcard_domains}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "da_reseller_wildcard_domains_count ${da_reseller_wildcard_domains_count}" 2>&1 | tee -a "${REPORT_FILE}"
    # initial value to loop
    count_x=1
    while [[ ${count_x} -le ${da_reseller_wildcard_domains_count} ]]; do
      echo "=~=~=~=~=~=~=~=~=~+~+~+~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
      echo "count_reseller_wildcard_domain_loop = ${count_x}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "" 2>&1 | tee -a "${REPORT_FILE}"
      typeset -n "this_da_reseller_username"="DA_RESELLER_USERNAME${count_x}"
      typeset -n "this_da_reseller_userpass"="DA_RESELLER_USERPASS${count_x}"
      typeset -n "this_da_reseller_wildcard_domains"="DA_RESELLER_WILDCARD_DOMAIN${count_x}"

      # Debug:
      echo "this_da_reseller_username: ${this_da_reseller_username}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_userpass: ${this_da_reseller_userpass}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_wildcard_domains: ${this_da_reseller_wildcard_domains[*]}" 2>&1 | tee -a "${REPORT_FILE}"
      this_da_reseller_wildcard_domains_count="${#this_da_reseller_wildcard_domains[@]}"

      count_n=0
      while [ ${count_n} -le $((this_da_reseller_wildcard_domains_count - 1)) ]; do
        echo "------------------------" 2>&1 | tee -a "${REPORT_FILE}"
        echo "Total count: ${count_n}" 2>&1 | tee -a "${REPORT_FILE}"

        wildcard_domains=$(echo "${this_da_reseller_wildcard_domains}" | awk -F':' '{for (i=1;i<=NF;i++)print $i}') #or tr ":" "\n"
        count_o=0
        for wildcard_domain in ${wildcard_domains}; do
          echo "count_o: ${count_o}"
          # Debug
          echo "wildcard_domain is set for domain: ${wildcard_domain}" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          echo "[${SCRIPT_NAME}]: Creating wildcard entry for domain ${wildcard_domain} for both IPv4 and IPv6 ..." 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          da_api_admin "signas+${this_da_reseller_username}+${this_da_reseller_userpass}"
          # By default DA don't create wildcard entry for this domain (unless wildcard option is enabled)
          # Note if record exist, it won't create in DA
          da_api_admin "create-dns-record" "${wildcard_domain}" "A" "*" "${IPV4_ADD0}"
          da_api_admin "create-dns-record" "${wildcard_domain}" "AAAA" "*" "$(ipv6calc --addr2uncompaddr "${IPV6_ADD0}")"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          if [ "${EXTERNAL_DNS_PROVIDER}" == "linode" ]; then
            # In linode DNS record are duplicated, we don't want so must delete previous record first before adding new
            echo "[${SCRIPT_NAME}]: DNS provider is set to linode. Using linode API" 2>&1 | tee -a "${REPORT_FILE}"

            echo "[${SCRIPT_NAME}]: Deleting subdomain ${wildcard_domain} record for IPv4 and IPv6 from linode" 2>&1 | tee -a "${REPORT_FILE}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            linode_api_admin "delete-dns-record" "${wildcard_domain}" "*" "A"
            linode_api_admin "delete-dns-record" "${wildcard_domain}" "*" "AAAA"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"

            # Also add wildcard domain for linode API here
            echo "[${SCRIPT_NAME}]: Adding wildcard domain ${wildcard_domain} record for IPv4 and IPv6 from linode" 2>&1 | tee -a "${REPORT_FILE}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            #linode_api_admin "add-dns-record" "maxibi.com" "TXT" "x._domainkey" "*i..2uiu1KJM@#9IU@J()!@IJI92" "5"
            linode_api_admin "add-dns-record" "${wildcard_domain}" "A" "*" "${IPV4_ADD0}" "5"
            linode_api_admin "add-dns-record" "${wildcard_domain}" "AAAA" "*" "${IPV6_ADD0}" "5"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"
          elif [ "${EXTERNAL_DNS_PROVIDER}" == "digitalocean" ]; then
            echo "[${SCRIPT_NAME}]: DNS provider is set to digitalocean" 2>&1 | tee -a "${REPORT_FILE}"
            # Call digitalocean_api_admin
            #elif other provider
          elif [ "${EXTERNAL_DNS_PROVIDER}" == "local" ]; then
            echo "[${SCRIPT_NAME}]: DNS provider is set to local (Internal DNS)" 2>&1 | tee -a "${REPORT_FILE}"
            # Do nothing
          fi
          ((count_o++))
        done
        ((count_n++))
      done
      ((count_x++))
    done
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# This will create user accounts and domains
function configure_da_user_accounts() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # Manually create user account first
  #rm -f "${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_user_packages_list gc count #da_admin_packages_list
    local da_user_unames                 #da_user_passwords da_user_emails da_user_domains da_user_package_names
    local this_da_user_uname this_da_user_password this_da_user_system_email this_da_user_mail_users
    local this_da_user_mail_passwords this_da_user_domains this_da_user_package_name this_da_user_enable_domain_ssl
    local da_user_count
    local dkim_val dmarc_val spf_val

    da_user_packages_list="/usr/local/directadmin/data/users/${DA_RESELLER_USERNAME1}/packages.list"
    # ALL API documentation: https://www.directadmin.com/search_versions.php?query=CMD_API
    # Create CURL action for API: https://help.directadmin.com/item.php?id=580
    # How to debug API: https://help.directadmin.com/item.php?id=356
    # https://help.directadmin.com/item.php?id=293

    # Create user dynamically based on config files
    da_user_unames="${!DA_USER_USERNAME@}"
    da_user_count=$(echo "${da_user_unames}" | wc -w)
    echo "List of users information from config is: " 2>&1 | tee -a "${REPORT_FILE}"
    echo "---==---" 2>&1 | tee -a "${REPORT_FILE}"
    echo "${da_user_unames}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "Total: ${da_user_count}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "---==---" 2>&1 | tee -a "${REPORT_FILE}"
    local count_user
    count_user=1
    while [[ ${count_user} -le ${da_user_count} ]]; do
      echo "Executing while loop: count=${count_user} while less or equal to da_user_count ${da_user_count}"
      typeset -n "this_da_user_uname"="DA_USER_USERNAME${count_user}"
      typeset -n "this_da_user_password"="DA_USER_USERPASS${count_user}"
      typeset -n "this_da_user_name"="DA_USER_NAME${count_user}"
      typeset -n "this_da_user_system_email"="DA_USER_SYSTEM_EMAIL${count_user}"
      typeset -n "this_da_user_mail_users"="DA_USER_MAIL_USER${count_user}"
      typeset -n "this_da_user_mail_passwords"="DA_USER_MAIL_PASSWORD${count_user}"
      typeset -n "this_da_user_domains"="DA_USER_DOMAIN${count_user}"
      typeset -n "this_da_user_package_name"="DA_USER_PACKAGE_NAME${count_user}"
      typeset -n "this_da_user_enable_domain_ssl"="DA_USER_ENABLE_DOMAIN_SSL${count_user}"

      echo "=========== start user value ========="
      echo "this_da_user_uname = ${this_da_user_uname}"
      echo "this_da_user_password = ${this_da_user_password}"
      echo "this_da_user_name = ${this_da_user_name}"
      echo "this_da_user_system_email = ${this_da_user_system_email}"
      echo "this_da_user_mail_users = ${this_da_user_mail_users}"
      echo "this_da_user_mail_passwords = ${this_da_user_mail_passwords}"
      echo "this_da_user_domains = ${this_da_user_domains}"
      echo "this_da_user_package_name = ${this_da_user_package_name}"
      echo "this_da_user_enable_domain_ssl = ${this_da_user_enable_domain_ssl}"
      echo "=========== end user value ========="
      echo ""

      echo "Checking user package ${this_da_user_package_name} ..."
      #_pause 2
      gc=$(grep -ic "${this_da_user_package_name}" "${da_user_packages_list}")
      if [ "${gc}" -gt 0 ]; then
        echo "[${SCRIPT_NAME}]: [${SCRIPT_NAME}]: Found package ${this_da_user_package_name}" 2>&1 | tee -a "${REPORT_FILE}"
        # The total domain count for this user
        da_user_domain_count="${#this_da_user_domains[@]}"
        # The first domain is used to create account (default domain for that user)
        da_user_domain_first=$(echo "${this_da_user_domains[@]}" | awk '{ print $1 }')
        echo "-=-=-=-=-=-=-="
        echo "This user ${this_da_user_uname} has the following ${da_user_domain_count} domain(s): "
        echo "${this_da_user_domains}"
        echo "The first domain is: ${da_user_domain_first}"
        echo "-=-=-=-=-=-=-="
        echo "[${SCRIPT_NAME}]: Authenticating DA API for user for default reseller user ..." 2>&1 | tee -a "${REPORT_FILE}"
        echo "Creating user account ${this_da_user_uname} using the following details: "
        echo "Username: ${this_da_user_uname} | Email: ${this_da_user_system_email} | Password: ${this_da_user_password} | Default (First) domain: ${da_user_domain_first} | Package selection: ${this_da_user_package_name}"
        echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
        #_pause 2
        # Use reseller to create user account and its default domain:
        da_api_admin "signas+reseller"
        da_api_admin "create-user-account" "${this_da_user_uname}" "${this_da_user_system_email}" "${this_da_user_password}" "${da_user_domain_first}" "${this_da_user_package_name}"
        echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
        echo "[${SCRIPT_NAME}]: Renaming user account name to ${this_da_user_name} ..."
        da_api_admin "modify-user" "${this_da_user_uname}" "name" "${this_da_user_name}"
        echo "[${SCRIPT_NAME}]: Enabling email DKIM for the domain ${da_user_domain_first} ..." 2>&1 | tee -a "${REPORT_FILE}"
        # Use user account to configure variable settings like DKIM or DNS
        da_api_admin "signas+${this_da_user_uname}+${this_da_user_password}"
        da_api_admin "enable-email-dkim" "${da_user_domain_first}"
        echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"

        echo "[${SCRIPT_NAME}]: Creating DA TXT DNS for DKIM signing policy for ${da_user_domain_first} ..." 2>&1 | tee -a "${REPORT_FILE}"
        echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
        da_api_admin "create-dns-record" "${da_user_domain_first}" "TXT" "_domainkey" "o%3D%7E%3B+r%3Dwebmaster%40${da_user_domain_first}"
        echo "-----" 2>&1 | tee -a "${REPORT_FILE}"

        # START DEBUG:
        #da_api_admin "get-dns-zone" "${da_user_domain_first}" "x._domainkey+TXT+v=DKIM1+.value"
        #da_api_admin "get-dns-zone" "${da_user_domain_first}" "_dmarc+TXT+v=DMARC1+.value"
        #da_api_admin "get-dns-zone" "${da_user_domain_first}" "${da_user_domain_first}.+TXT+v=spf1+.value"
        #exit 1
        # END DEBUG
        # Make sure if duplicated entry found, just return 1 line with tail -n 1

        dkim_val=$(da_api_admin "get-dns-zone" "${da_user_domain_first}" "x._domainkey+TXT+v=DKIM1+.value" | tail -n 1) || exit 1
        dkim_val_count=$(echo "${dkim_val}" | wc -l)
        dkim_policy_val=$(da_api_admin "get-dns-zone" "${da_user_domain_first}" "_domainkey+TXT+o=+.value" | tail -n 1) || exit 1
        dkim_policy_val_count=$(echo "${dkim_policy_val}" | wc -l)
        dmarc_val=$(da_api_admin "get-dns-zone" "${da_user_domain_first}" "_dmarc+TXT+v=DMARC1+.value" | tail -n 1) || exit 1
        dmarc_val_count=$(echo "${dmarc_val}" | wc -l)
        spf_val=$(da_api_admin "get-dns-zone" "${da_user_domain_first}" "${da_user_domain_first}.+TXT+v=spf1+.value" | tail -n 1) || exit 1
        spf_val_count=$(echo "${spf_val}" | wc -l)

        echo "=-=-=-=-=-=-=-=-=-=-"
        echo "There is/are ${dkim_val_count} dkim value for this domain ${da_user_domain_first}. First value is: ${dkim_val}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "There is/are ${dkim_policy_val_count} dkim policy value for this domain ${da_user_domain_first}. First value is: ${dkim_policy_val}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "There is/are ${dmarc_val_count} dmarc value for this domain ${da_user_domain_first}. First value is: ${dmarc_val}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "There is/are ${spf_val_count} spf value for this domain ${da_user_domain_first}. First value is: ${spf_val}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "=-=-=-=-=-=-=-=-=-=-"
        echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"

        if [ "${EXTERNAL_DNS_PROVIDER}" == "linode" ]; then
          echo "[${SCRIPT_NAME}]: DNS provider is set to linode. Using linode API" 2>&1 | tee -a "${REPORT_FILE}"
          echo "[${SCRIPT_NAME}]: Creating domain ${da_user_domain_first} if missing ..."
          linode_api_admin "create-domain" "master" "${da_user_domain_first}" "${this_da_user_system_email}"
          echo "0) Name: _domainkey | Type: TXT" 2>&1 | tee -a "${REPORT_FILE}"
          #_pause 2
          echo "-----" 2>&1 | tee -a "${REPORT_FILE}"

          # For mx record, linode_api_admin "add-dns-record" "maxibi.com" "MX" "mail" "sofibox.com." "5"
          echo "[${SCRIPT_NAME}]: Creating MX record for ${da_user_domain_first} in linode DNS management ..."
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          linode_api_admin "add-dns-record" "${da_user_domain_first}" "MX" "mail" "${da_user_domain_first}." "5"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          linode_api_admin "delete-dns-record" "${da_user_domain_first}" "_domainkey" "TXT"

          echo "Deleting dns record x._domainkey for ${da_user_domain_first}" 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          #_pause 2
          linode_api_admin "delete-dns-record" "${da_user_domain_first}" "x._domainkey" "TXT"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          echo "Deleting dns record _dmarc. for ${da_user_domain_first}" 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          #_pause 2
          linode_api_admin "delete-dns-record" "${da_user_domain_first}" "_dmarc" "TXT" 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          echo "Deleting dns record for ${da_user_domain_first}" 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          #_pause 2
          linode_api_admin "delete-dns-record" "${da_user_domain_first}" "" "TXT" 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          echo "Adding DKIM outbound signing policy DNS record ..."
          linode_api_admin "add-dns-record" "${da_user_domain_first}" "TXT" "_domainkey" "${dkim_policy_val}" "5" 2>&1 | tee -a "${REPORT_FILE}"

          echo "Adding record for x._domainkey for ${da_user_domain_first}" 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          #_pause 2
          linode_api_admin "add-dns-record" "${da_user_domain_first}" "TXT" "x._domainkey" "${dkim_val}" "5" 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          echo "Adding record for _dmarc for ${da_user_domain_first}" 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          #_pause 2
          linode_api_admin "add-dns-record" "${da_user_domain_first}" "TXT" "_dmarc" "${dmarc_val}" "5" 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          echo "Adding dns record for ${da_user_domain_first} with empty name (provide the hostname)" 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          #_pause 2
          linode_api_admin "add-dns-record" "${da_user_domain_first}" "TXT" "${da_user_domain_first}" "${spf_val}" "5" 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

        elif [ "${EXTERNAL_DNS_PROVIDER}" == "digitalocean" ]; then

          echo "[${SCRIPT_NAME}]: DNS provider is set to digitalocean" 2>&1 | tee -a "${REPORT_FILE}"

          # Call digitalocean_api_admin
        #elif other provider
        elif [ "${EXTERNAL_DNS_PROVIDER}" == "local" ]; then
          echo "[${SCRIPT_NAME}]: DNS provider is set to local (Internal DNS)" 2>&1 | tee -a "${REPORT_FILE}"
          # Do nothing because it's local DNS managed by DA
        fi

        # This will be executed if user has more than 1 domains. We add the extra domains here and skipped the default domain:
        if [ "${da_user_domain_count}" -gt 1 ]; then
          echo "[${SCRIPT_NAME}]: This user ${this_da_user_uname} has more than 1 domains" 2>&1 | tee -a "${REPORT_FILE}"
          #sleep 1
          echo ""
          for extra_domain in "${this_da_user_domains[@]}"; do
            # Don't add first domain, we did that before
            if [ "${extra_domain}" == "${da_user_domain_first}" ]; then
              echo "[${SCRIPT_NAME}]: Skipped adding the default domain: ${da_user_domain_first}"
              #sleep 1
              continue
            fi

            echo "[${SCRIPT_NAME}]: Creating extra domain ${extra_domain} for ${this_da_user_uname} ..." 2>&1 | tee -a "${REPORT_FILE}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            #_pause 2
            da_api_admin "signas+${this_da_user_uname}+${this_da_user_password}"
            da_api_admin "create-user-domain" "${extra_domain}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            echo ""

            echo "[${SCRIPT_NAME}]: Enabling email DKIM for extra domain ${extra_domain} for user ${this_da_user_uname} ..." 2>&1 | tee -a "${REPORT_FILE}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            #_pause 2
            da_api_admin "signas+${this_da_user_uname}+${this_da_user_password}"
            da_api_admin "enable-email-dkim" "${extra_domain}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            echo ""

            echo "[${SCRIPT_NAME}]: Creating DA TXT DNS for DKIM signing policy for ${extra_domain} ..." 2>&1 | tee -a "${REPORT_FILE}"
            echo "-----" 2>&1 | tee -a "${REPORT_FILE}"

            da_api_admin "create-dns-record" "${extra_domain}" "TXT" "_domainkey" "o%3D%7E%3B+r%3Dwebmaster%40${extra_domain}"
            echo "-----" 2>&1 | tee -a "${REPORT_FILE}"

            echo "[${SCRIPT_NAME}]: Querying DNS record ..." 2>&1 | tee -a "${REPORT_FILE}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            # Make sure if duplicated entry found, just return 1 line with tail -n 1
            dkim_val=$(da_api_admin "get-dns-zone" "${extra_domain}" "x._domainkey+TXT+v=DKIM1+.value" | tail -n 1) || exit 1
            dkim_val_count=$(echo "${dkim_val}" | wc -l)
            dkim_policy_val=$(da_api_admin "get-dns-zone" "${extra_domain}" "_domainkey+TXT+o=+.value" | tail -n 1) || exit 1
            dkim_policy_val_count=$(echo "${dkim_policy_val}" | wc -l)
            dmarc_val=$(da_api_admin "get-dns-zone" "${extra_domain}" "_dmarc+TXT+v=DMARC1+.value" | tail -n 1) || exit 1
            dmarc_val_count=$(echo "${dmarc_val}" | wc -l)
            spf_val=$(da_api_admin "get-dns-zone" "${extra_domain}" "${extra_domain}.+TXT+v=spf1+.value" | tail -n 1) || exit 1
            spf_val_count=$(echo "${spf_val}" | wc -l)

            echo "=-=-=-=-=-=-=-=-=-=-"
            echo "There is/are ${dkim_val_count} dkim value for this extra_domain ${extra_domain}. First value is: ${dkim_val}"
            echo "There is/are ${dkim_policy_val_count} dkim policy value for this domain ${extra_domain}. First value is: ${dkim_policy_val}" 2>&1 | tee -a "${REPORT_FILE}"
            echo "There is/are ${dmarc_val_count} dmarc value for this extra_domain ${extra_domain}. First value is: ${dmarc_val}"
            echo "There is/are ${spf_val_count} spf value for this extra_domain ${extra_domain}. First value is: ${spf_val}"
            echo "=-=-=-=-=-=-=-=-=-=-"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            echo ""

            if [ "${EXTERNAL_DNS_PROVIDER}" == "linode" ]; then
              echo "[${SCRIPT_NAME}]: DNS provider is set to linode. Using linode API" 2>&1 | tee -a "${REPORT_FILE}"
              echo "[${SCRIPT_NAME}]: Creating domain ${extra_domain} if missing ..."
              linode_api_admin "create-domain" "master" "${extra_domain}" "${this_da_user_system_email}"

              # For mx record, linode_api_admin "add-dns-record" "maxibi.com" "MX" "mail" "sofibox.com." "5"
              echo "[${SCRIPT_NAME}]: Creating MX record for ${extra_domain} in linode DNS management ..."
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              linode_api_admin "add-dns-record" "${extra_domain}" "MX" "mail" "${extra_domain}." "5"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"

              echo "0) Name: _domainkey | Type: TXT" 2>&1 | tee -a "${REPORT_FILE}"
              #_pause 2
              echo "-----" 2>&1 | tee -a "${REPORT_FILE}"
              linode_api_admin "delete-dns-record" "${extra_domain}" "_domainkey" "TXT"
              echo "Deleting dns record x._domainkey for ${extra_domain}" 2>&1 | tee -a "${REPORT_FILE}"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              #_pause 2
              linode_api_admin "delete-dns-record" "${extra_domain}" "x._domainkey" "TXT"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"

              echo "Deleting dns record _dmarc. for ${extra_domain}" 2>&1 | tee -a "${REPORT_FILE}"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              #_pause 2
              linode_api_admin "delete-dns-record" "${extra_domain}" "_dmarc" "TXT" 2>&1 | tee -a "${REPORT_FILE}"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"

              echo "Deleting dns record for ${extra_domain}" 2>&1 | tee -a "${REPORT_FILE}"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              #_pause 2
              linode_api_admin "delete-dns-record" "${extra_domain}" "" "TXT" 2>&1 | tee -a "${REPORT_FILE}"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"

              echo "Adding DKIM outbound signing policy DNS record ..."
              linode_api_admin "add-dns-record" "${extra_domain}" "TXT" "_domainkey" "${dkim_policy_val}" "5" 2>&1 | tee -a "${REPORT_FILE}"

              echo "Adding record for x._domainkey for ${extra_domain}" 2>&1 | tee -a "${REPORT_FILE}"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              #_pause 2
              linode_api_admin "add-dns-record" "${extra_domain}" "TXT" "x._domainkey" "${dkim_val}" "5" 2>&1 | tee -a "${REPORT_FILE}"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"

              echo "Adding record for _dmarc for ${extra_domain}" 2>&1 | tee -a "${REPORT_FILE}"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              #_pause 2
              linode_api_admin "add-dns-record" "${extra_domain}" "TXT" "_dmarc" "${dmarc_val}" "5" 2>&1 | tee -a "${REPORT_FILE}"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"

              echo "Adding dns record for ${extra_domain} with empty name (provide the hostname)" 2>&1 | tee -a "${REPORT_FILE}"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              #_pause 2
              linode_api_admin "add-dns-record" "${extra_domain}" "TXT" "${extra_domain}" "${spf_val}" "5" 2>&1 | tee -a "${REPORT_FILE}"
              echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
              echo "" 2>&1 | tee -a "${REPORT_FILE}"
            elif
              [ "${EXTERNAL_DNS_PROVIDER}" == "digitalocean" ]
            then
              echo "[${SCRIPT_NAME}]: DNS provider is set to digitalocean" 2>&1 | tee -a "${REPORT_FILE}"
              # Call digitalocean_api_admin
            #elif other provider
            elif [ "${EXTERNAL_DNS_PROVIDER}" == "local" ]; then
              echo "[${SCRIPT_NAME}]: DNS provider is set to local (Internal DNS)" 2>&1 | tee -a "${REPORT_FILE}"
              # Do nothing because it's local DNS managed by DA
            fi
          done
        fi
      else
        echo "[${SCRIPT_NAME}]: Warning, ${this_da_user_package_name} does not exist in ${da_user_packages_list}. Please inspect why!" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi

      ((count_user++))
      echo "count_user is now: ${count_user}" 2>&1 | tee -a "${REPORT_FILE}"
      #sleep 10
    done

    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_user_root_domains() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_user_domains da_user_domains_count this_da_user_username this_da_user_userpass \
      this_da_user_domains this_da_user_domains_count
    local count_x count_n count_o domain
    # Get list of all user subdomains
    da_user_domains="${!DA_USER_DOMAIN@}"
    # Count the total domains
    da_user_domains_count=$(echo "${da_user_domains}" | wc -w)
    # Debug:
    echo "da_user_domains: ${da_user_domains}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "da_user_domains_count ${da_user_domains_count}" 2>&1 | tee -a "${REPORT_FILE}"
    # initial value to loop
    count_x=1
    while [[ ${count_x} -le ${da_user_domains_count} ]]; do
      echo "Count_x: ${count_x}"
      echo "DA_USER_DOMAINS_COUNT ${da_user_domains_count}"
      echo "=~=~=~=~=~=~=~=~=~+~+~+~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
      echo "count_user_domain_loop = ${count_x}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "" 2>&1 | tee -a "${REPORT_FILE}"
      typeset -n "this_da_user_username"="DA_USER_USERNAME${count_x}"
      typeset -n "this_da_user_userpass"="DA_USER_USERPASS${count_x}"

      this_da_user_domains=$(cat "/usr/local/directadmin/data/users/${this_da_user_username}/domains.list")
      # Debug:
      echo "this_da_user_username: ${this_da_user_username}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_user_userpass: ${this_da_user_userpass}" 2>&1 | tee -a "${REPORT_FILE}"

      echo "this_da_user_domains: ${this_da_user_domains[*]}" 2>&1 | tee -a "${REPORT_FILE}"
      this_da_user_domains_count=$(echo "${this_da_user_domains}" | wc -w)
      echo "this_da_user_domains_count: ${this_da_user_domains_count}"
      count_n=1
      while [ ${count_n} -le "${this_da_user_domains_count}" ]; do
        echo "------------------------" 2>&1 | tee -a "${REPORT_FILE}"
        echo "Total count: ${count_n}" 2>&1 | tee -a "${REPORT_FILE}"
        count_o=0
        for domain in ${this_da_user_domains}; do
          echo "count_o: ${count_o}"
          # Debug
          echo "domain is set: ${domain}" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          echo "[${SCRIPT_NAME}]: Creating root domain ${domain} for both IPv4 and IPv6 ..." 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          da_api_admin "signas+${this_da_user_username}+${this_da_user_userpass}"
          # Note if record exist, it won't create in DA
          da_api_admin "create-dns-record" "${domain}" "A" "${domain}." "${IPV4_ADD0}"
          da_api_admin "create-dns-record" "${domain}" "AAAA" "${domain}." "$(ipv6calc --addr2uncompaddr "${IPV6_ADD0}")"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          if [ "${EXTERNAL_DNS_PROVIDER}" == "linode" ]; then
            # In linode DNS record are duplicated, we don't want so must delete previous record first before adding new
            echo "[${SCRIPT_NAME}]: DNS provider is set to linode. Using linode API" 2>&1 | tee -a "${REPORT_FILE}"

            echo "[${SCRIPT_NAME}]: Deleting root ${domain} record for IPv4 and IPv6 from linode" 2>&1 | tee -a "${REPORT_FILE}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            # In linode empty there means hostname or I can use @ or try domain.com
            linode_api_admin "delete-dns-record" "${domain}" "" "A"
            linode_api_admin "delete-dns-record" "${domain}" "" "AAAA"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"

            # Also add wildcard domain for linode API here
            echo "[${SCRIPT_NAME}]: Adding wildcard domain ${domain} record for IPv4 and IPv6 from linode" 2>&1 | tee -a "${REPORT_FILE}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            #In linode empty there means hostname or I can use @ or try domain.com
            linode_api_admin "add-dns-record" "${domain}" "A" "" "${IPV4_ADD0}" "5"
            linode_api_admin "add-dns-record" "${domain}" "AAAA" "" "${IPV6_ADD0}" "5"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"
          elif [ "${EXTERNAL_DNS_PROVIDER}" == "digitalocean" ]; then
            echo "[${SCRIPT_NAME}]: DNS provider is set to digitalocean" 2>&1 | tee -a "${REPORT_FILE}"
            # Call digitalocean_api_admin
            #elif other provider
          elif [ "${EXTERNAL_DNS_PROVIDER}" == "local" ]; then
            echo "[${SCRIPT_NAME}]: DNS provider is set to local (Internal DNS)" 2>&1 | tee -a "${REPORT_FILE}"
            # Do nothing
          fi
          ((count_o++))
        done
        ((count_n++))
      done
      ((count_x++))
    done
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_user_wildcard_domains() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_user_wildcard_domains da_user_wildcard_domains_count this_da_user_username this_da_user_userpass \
      this_da_user_wildcard_domains this_da_user_wildcard_domains_count
    local count_x count_n count_o wildcard_domain wildcard_domains
    # Get list of all user wildcard domains
    da_user_wildcard_domains="${!DA_USER_WILDCARD_DOMAIN@}"
    # Count the total subdomains
    da_user_wildcard_domains_count=$(echo "${da_user_wildcard_domains}" | wc -w)
    # Debug:
    echo "da_user_wildcard_domains: ${da_user_wildcard_domains}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "da_user_wildcard_domains_count ${da_user_wildcard_domains_count}" 2>&1 | tee -a "${REPORT_FILE}"
    # initial value to loop
    count_x=1
    while [[ ${count_x} -le ${da_user_wildcard_domains_count} ]]; do
      echo "=~=~=~=~=~=~=~=~=~+~+~+~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
      echo "count_user_wildcard_domain_loop = ${count_x}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "" 2>&1 | tee -a "${REPORT_FILE}"
      typeset -n "this_da_user_username"="DA_USER_USERNAME${count_x}"
      typeset -n "this_da_user_userpass"="DA_USER_USERPASS${count_x}"
      typeset -n "this_da_user_wildcard_domains"="DA_USER_WILDCARD_DOMAIN${count_x}"

      # Debug:
      echo "this_da_user_username: ${this_da_user_username}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_user_userpass: ${this_da_user_userpass}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_user_wildcard_domains: ${this_da_user_wildcard_domains[*]}" 2>&1 | tee -a "${REPORT_FILE}"
      this_da_user_wildcard_domains_count="${#this_da_user_wildcard_domains[@]}"

      count_n=0
      while [ ${count_n} -le $((this_da_user_wildcard_domains_count - 1)) ]; do
        echo "------------------------" 2>&1 | tee -a "${REPORT_FILE}"
        echo "Total count: ${count_n}" 2>&1 | tee -a "${REPORT_FILE}"

        wildcard_domains=$(echo "${this_da_user_wildcard_domains}" | awk -F':' '{for (i=1;i<=NF;i++)print $i}') #or tr ":" "\n"
        count_o=0
        for wildcard_domain in ${wildcard_domains}; do
          echo "count_o: ${count_o}"
          # Debug
          echo "wildcard_domain is set for domain: ${wildcard_domain}" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          echo "[${SCRIPT_NAME}]: Creating wildcard entry for domain ${wildcard_domain} for both IPv4 and IPv6 ..." 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          da_api_admin "signas+${this_da_user_username}+${this_da_user_userpass}"
          # By default DA don't create wildcard entry for this domain (unless wildcard option is enabled)
          # Note if record exist, it won't create in DA
          da_api_admin "create-dns-record" "${wildcard_domain}" "A" "*" "${IPV4_ADD0}"
          da_api_admin "create-dns-record" "${wildcard_domain}" "AAAA" "*" "$(ipv6calc --addr2uncompaddr "${IPV6_ADD0}")"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          if [ "${EXTERNAL_DNS_PROVIDER}" == "linode" ]; then
            # In linode DNS record are duplicated, we don't want so must delete previous record first before adding new
            echo "[${SCRIPT_NAME}]: DNS provider is set to linode. Using linode API" 2>&1 | tee -a "${REPORT_FILE}"

            echo "[${SCRIPT_NAME}]: Deleting subdomain ${wildcard_domain} record for IPv4 and IPv6 from linode" 2>&1 | tee -a "${REPORT_FILE}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            linode_api_admin "delete-dns-record" "${wildcard_domain}" "*" "A"
            linode_api_admin "delete-dns-record" "${wildcard_domain}" "*" "AAAA"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"

            # Also add wildcard domain for linode API here
            echo "[${SCRIPT_NAME}]: Adding wildcard domain ${wildcard_domain} record for IPv4 and IPv6 from linode" 2>&1 | tee -a "${REPORT_FILE}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            #linode_api_admin "add-dns-record" "maxibi.com" "TXT" "x._domainkey" "*i..2uiu1KJM@#9IU@J()!@IJI92" "5"
            linode_api_admin "add-dns-record" "${wildcard_domain}" "A" "*" "${IPV4_ADD0}" "5"
            linode_api_admin "add-dns-record" "${wildcard_domain}" "AAAA" "*" "${IPV6_ADD0}" "5"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"
          elif [ "${EXTERNAL_DNS_PROVIDER}" == "digitalocean" ]; then
            echo "[${SCRIPT_NAME}]: DNS provider is set to digitalocean" 2>&1 | tee -a "${REPORT_FILE}"
            # Call digitalocean_api_admin
            #elif other provider
          elif [ "${EXTERNAL_DNS_PROVIDER}" == "local" ]; then
            echo "[${SCRIPT_NAME}]: DNS provider is set to local (Internal DNS)" 2>&1 | tee -a "${REPORT_FILE}"
            # Do nothing
          fi
          ((count_o++))
        done
        ((count_n++))
      done
      ((count_x++))
    done
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_reseller_subdomains() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_reseller_subdomains da_reseller_subdomains_count this_da_reseller_username this_da_reseller_userpass \
      this_da_reseller_subdomains this_da_reseller_subdomains_count
    local count_x count_n count_o sub_domain sub_domains_raw sub_domains root_domain
    # Get list of all reseller subdomains
    da_reseller_subdomains="${!DA_RESELLER_SUBDOMAIN@}"
    # Count the total subdomains
    da_reseller_subdomains_count=$(echo "${da_reseller_subdomains}" | wc -w)
    # Debug:
    echo "da_reseller_subdomains: ${da_reseller_subdomains}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "da_reseller_subdomains_count ${da_reseller_subdomains_count}" 2>&1 | tee -a "${REPORT_FILE}"
    # initial value to loop
    count_x=1
    while [[ ${count_x} -le ${da_reseller_subdomains_count} ]]; do
      echo "=~=~=~=~=~=~=~=~=~+~+~+~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
      echo "count_reseller_domain_loop = ${count_x}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "" 2>&1 | tee -a "${REPORT_FILE}"
      typeset -n "this_da_reseller_username"="DA_RESELLER_USERNAME${count_x}"
      typeset -n "this_da_reseller_userpass"="DA_RESELLER_USERPASS${count_x}"
      typeset -n "this_da_reseller_subdomains"="DA_RESELLER_SUBDOMAIN${count_x}"

      # Error checking:
      if [ -z "${this_da_reseller_username}" ]; then
        echo "[${SCRIPT_NAME}]: [Skipped]: Warning, no user name is set in config file for this reseller ${this_da_reseller_username}. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      elif [ -z "${this_da_reseller_userpass}" ]; then
        echo "[${SCRIPT_NAME}]: [Skipped]: Warning, no user password is set in config file for this user ${this_da_reseller_username}. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      elif [ -z "${this_da_reseller_subdomains}" ]; then
        echo "[${SCRIPT_NAME}]: [Skipped]: Warning, no user subdomains is set for this user ${this_da_reseller_username}. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi

      # Debug:
      echo "this_da_reseller_username: ${this_da_reseller_username}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_userpass: ${this_da_reseller_userpass}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_subdomains: ${this_da_reseller_subdomains[*]}" 2>&1 | tee -a "${REPORT_FILE}"
      this_da_reseller_subdomains_count="${#this_da_reseller_subdomains[@]}"

      count_n=0
      while [ ${count_n} -le $((this_da_reseller_subdomains_count - 1)) ]; do
        echo "------------------------" 2>&1 | tee -a "${REPORT_FILE}"
        echo "Total count: ${count_n}" 2>&1 | tee -a "${REPORT_FILE}"

        # Deprecated syntax
        #sub_domain=$(echo "${this_da_reseller_subdomains[count_n]}" | awk -F'+' '{ print $1 }')
        #root_domain=$(echo "${this_da_reseller_subdomains[count_n]}" | awk -F'+' '{ print $2 }')

        root_domain=$(echo "${this_da_reseller_subdomains[count_n]}" | awk -F':' '{ print $1 }')
        sub_domains_raw=$(echo "${this_da_reseller_subdomains[count_n]}" | awk -F':' '{ print $2 }')
        # Debug

        sub_domains=$(echo "${sub_domains_raw}" | awk -F'+' '{for (i=1;i<=NF;i++)print $i}')
        count_o=0
        for sub_domain in ${sub_domains}; do
          echo "count_o: ${count_o}"
          # Debug
          echo "Sub_domain is: ${sub_domain}" 2>&1 | tee -a "${REPORT_FILE}"
          echo "Root_domain is: ${root_domain}" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          # Now we got sub_domain and root_domain, call the da_api_admin:
          # reseller and user share the same API
          # da_api_admin "create-user-subdomain" "<root_domain>" "<subdomain>"
          # Start the user login authentication:
          echo "[${SCRIPT_NAME}]: Creating reseller ${this_da_reseller_username} subdomain ${sub_domain}" 2>&1 | tee -a "${REPORT_FILE}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          da_api_admin "signas+${this_da_reseller_username}+${this_da_reseller_userpass}"
          da_api_admin "create-user-subdomain" "${root_domain}" "${sub_domain}"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"
          if [ "${EXTERNAL_DNS_PROVIDER}" == "linode" ]; then
            echo "[${SCRIPT_NAME}]: DNS provider is set to linode. Using linode API" 2>&1 | tee -a "${REPORT_FILE}"
            # Also add subdomain for linode API here
            #linode_api_admin "delete-dns-record" <domain_name> <record_name> <record_type>
            echo "[${SCRIPT_NAME}]: Deleting subdomain ${sub_domain} record for IPv4 and IPv6 from linode" 2>&1 | tee -a "${REPORT_FILE}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            linode_api_admin "delete-dns-record" "${root_domain}" "${sub_domain}" "A"
            linode_api_admin "delete-dns-record" "${root_domain}" "${sub_domain}" "AAAA"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"
            echo "[${SCRIPT_NAME}]: Adding subdomain ${sub_domain} record for IPv4 and IPv6 from linode" 2>&1 | tee -a "${REPORT_FILE}"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            #linode_api_admin "add-dns-record" "maxibi.com" "TXT" "x._domainkey" "*i..2uiu1KJM@#9IU@J()!@IJI92" "5"
            linode_api_admin "add-dns-record" "${root_domain}" "A" "${sub_domain}" "${IPV4_ADD0}" "5"
            linode_api_admin "add-dns-record" "${root_domain}" "AAAA" "${sub_domain}" "${IPV6_ADD0}" "5"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
            echo "" 2>&1 | tee -a "${REPORT_FILE}"
          elif [ "${EXTERNAL_DNS_PROVIDER}" == "digitalocean" ]; then
            echo "[${SCRIPT_NAME}]: DNS provider is set to digitalocean" 2>&1 | tee -a "${REPORT_FILE}"
            # Call digitalocean_api_admin
            #elif other provider
          elif [ "${EXTERNAL_DNS_PROVIDER}" == "local" ]; then
            echo "[${SCRIPT_NAME}]: DNS provider is set to local (Internal DNS)" 2>&1 | tee -a "${REPORT_FILE}"
            # Do nothing
          fi
          ((count_o++))
        done
        ((count_n++))
      done
      ((count_x++))
    done
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_user_subdomains() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_user_subdomains da_user_subdomains_count this_da_user_username this_da_user_userpass this_da_user_subdomains
    local this_da_user_subdomains_count
    local count_x count_n sub_domain sub_domains sub_domains_raw root_domain
    # Get list of all user subdomains
    da_user_subdomains="${!DA_USER_SUBDOMAIN@}"
    # Count the total subdomains
    da_user_subdomains_count=$(echo "${da_user_subdomains}" | wc -w)
    # Debug:
    echo "da_user_subdomains: ${da_user_subdomains}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "da_user_subdomains_count ${da_user_subdomains_count}" 2>&1 | tee -a "${REPORT_FILE}"
    # initial value to loop
    count_x=1
    while [[ ${count_x} -le ${da_user_subdomains_count} ]]; do
      echo "=~=~=~=~=~=~=~=~=~+~+~+~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
      echo "count_user_domain = ${count_x}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "" 2>&1 | tee -a "${REPORT_FILE}"
      typeset -n "this_da_user_username"="DA_USER_USERNAME${count_x}"
      typeset -n "this_da_user_userpass"="DA_USER_USERPASS${count_x}"
      #typeset -n "this_da_user_domains"="DA_USER_DOMAIN${count_x}"
      typeset -n "this_da_user_subdomains"="DA_USER_SUBDOMAIN${count_x}"

      # Error checking:
      if [ -z "${this_da_user_username}" ]; then
        echo "[${SCRIPT_NAME}]: [Skipped]: Warning, no user_name is set in config file for this user ${this_da_user_username}. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      elif [ -z "${this_da_user_userpass}" ]; then
        echo "[${SCRIPT_NAME}]: [Skipped]: Warning, no user_password is set in config file for this user ${this_da_user_username}. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      #elif [ -z "${this_da_user_domains}" ]; then
      #  echo "[${SCRIPT_NAME}]: [Skipped]: Warning, user domains not set for this user ${this_da_user_username}. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
      #  _exit 1
      elif [ -z "${this_da_user_subdomains}" ]; then
        echo "[${SCRIPT_NAME}]: [Skipped]: Warning, user subdomains not set for this user ${this_da_user_username}. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi

      # Debug:
      #this_da_user_domains="${this_da_user_domains[*]}"
      echo "this_da_user_username: ${this_da_user_username}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_user_userpass: ${this_da_user_userpass}" 2>&1 | tee -a "${REPORT_FILE}"
      #echo "this_da_user_domains: ${this_da_user_domains[*]}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_user_subdomains: ${this_da_user_subdomains[*]}" 2>&1 | tee -a "${REPORT_FILE}"
      this_da_user_subdomains_count="${#this_da_user_subdomains[@]}"

      count_n=0
      while [ ${count_n} -le $((this_da_user_subdomains_count - 1)) ]; do
        echo "------------------------" 2>&1 | tee -a "${REPORT_FILE}"
        echo "Total count: ${count_n}" 2>&1 | tee -a "${REPORT_FILE}"

        # sub_domain=$(echo "${this_da_user_subdomains[count_n]}" | awk -F'+' '{ print $1 }')
        # root_domain=$(echo "${this_da_user_subdomains[count_n]}" | awk -F'+' '{ print $2 }')

        root_domain=$(echo "${this_da_user_subdomains[count_n]}" | awk -F':' '{ print $1 }')
        sub_domains_raw=$(echo "${this_da_user_subdomains[count_n]}" | awk -F':' '{ print $2 }')

        sub_domains=$(echo "${sub_domains_raw}" | awk -F'+' '{for (i=1;i<=NF;i++)print $i}')
        count_o=0
        for sub_domain in ${sub_domains}; do
          echo "count_o: ${count_o}"
          # Debug
          echo "Sub_domain is: ${sub_domain}" 2>&1 | tee -a "${REPORT_FILE}"
          echo "Root_domain is: ${root_domain}" 2>&1 | tee -a "${REPORT_FILE}"
          # Now we got sub_domain and root_domain, call the da_api_admin:
          # da_api_admin "create-user-subdomain" "<root_domain>" "<subdomain>"
          # Start the user login authentication:
          da_api_admin "signas+${this_da_user_username}+${this_da_user_userpass}"
          da_api_admin "create-user-subdomain" "${root_domain}" "${sub_domain}"
          # Also add subdomain for linode API here

          #linode_api_admin "delete-dns-record" <domain_name> <record_name> <record_type>
          linode_api_admin "delete-dns-record" "${root_domain}" "${sub_domain}" "A"
          linode_api_admin "delete-dns-record" "${root_domain}" "${sub_domain}" "AAAA"

          #linode_api_admin "add-dns-record" "maxibi.com" "TXT" "x._domainkey" "*i..2uiu1KJM@#9IU@J()!@IJI92" "5"
          linode_api_admin "add-dns-record" "${root_domain}" "A" "${sub_domain}" "${IPV4_ADD0}" "5"
          linode_api_admin "add-dns-record" "${root_domain}" "AAAA" "${sub_domain}" "${IPV6_ADD0}" "5"
          echo "" 2>&1 | tee -a "${REPORT_FILE}"

          ((count_o++))
        done

        ((count_n++))
      done

      ((count_x++))
    done

    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}
function configure_da_reseller_emails() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  #rm -f "${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_reseller_mail_users da_reseller_mail_users_count count_x
    local this_da_reseller_username this_da_reseller_userpass this_da_reseller_mail_users \
      this_da_reseller_mail_passwords this_da_reseller_mail_users_count this_da_reseller_mail_password_count
    local count_n mail_user mail_domain
    # Get all variables set for DA_RESELLER_MAIL_USER[index]:
    da_reseller_mail_users="${!DA_RESELLER_MAIL_USER@}"
    # Calculate the total for the total variable of DA_USER_MAIL_USER
    da_reseller_mail_users_count=$(echo "${da_reseller_mail_users}" | wc -w)
    # Debug:
    echo "DA_RESELLER_MAIL_USERS: ${da_reseller_mail_users}"
    echo "DA_RESELLER_MAIL_USERS_COUNT: ${da_reseller_mail_users_count}"
    # Initial value to start looping
    count_x=1
    while [[ ${count_x} -le ${da_reseller_mail_users_count} ]]; do
      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
      echo "COUNT_MAIL_USER INDEX = ${count_x}"
      echo ""
      # Assign all variables from the config file as array index
      typeset -n "this_da_reseller_username"="DA_RESELLER_USERNAME${count_x}"
      typeset -n "this_da_reseller_userpass"="DA_RESELLER_USERPASS${count_x}"
      typeset -n "this_da_reseller_mail_users"="DA_RESELLER_MAIL_USER${count_x}"
      typeset -n "this_da_reseller_mail_passwords"="DA_RESELLER_MAIL_PASSWORD${count_x}"
      # Error checking for missing variable values:
      if [ -z "${this_da_reseller_username}" ]; then
        echo "[${SCRIPT_NAME}]: [Skipped]: Warning, no user_name is set in config file for this reseller ${this_da_reseller_username}. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      elif [ -z "${this_da_reseller_userpass}" ]; then
        echo "[${SCRIPT_NAME}]: [Skipped]: Warning, no user_password is set in config file for this reseller ${this_da_reseller_username}. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      elif [ -z "${this_da_reseller_mail_users}" ]; then
        echo "[${SCRIPT_NAME}]: [Skipped]: Warning, no user_emails is set in config file for this reseller ${this_da_reseller_username}. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      elif [ -z "${this_da_reseller_mail_passwords}" ]; then
        echo "[${SCRIPT_NAME}]: [Skipped]: Warning, no user_email_passwords is set in config file for this reseller ${this_da_reseller_username}. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      elif [ ${#this_da_reseller_mail_users[@]} -ne ${#this_da_reseller_mail_passwords[@]} ]; then
        echo "[${SCRIPT_NAME}]: [Skipped]: Warning, mail users and mail passwords defined with different length of array" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      else
        this_da_reseller_mail_users_count="${#this_da_reseller_mail_users[@]}"
        this_da_reseller_mail_password_count="${#this_da_reseller_mail_passwords[@]}"
        # Debug
        echo "this_da_reseller_mail_users: ${this_da_reseller_mail_users[*]}"
        echo "this_da_reseller_mail_passwords: ${this_da_reseller_mail_passwords[*]}"
        echo "mail_reseller_count: ${this_da_reseller_mail_users_count}"
        echo "mail_password_count: ${this_da_reseller_mail_password_count}"
        count_n=0
        while [ ${count_n} -le $((this_da_reseller_mail_users_count - 1)) ]; do
          echo "=~=~=~=~+~Count: ${count_n}+~+~=~+~+~+~+"

          mail_user=$(echo "${this_da_reseller_mail_users[count_n]}" | awk -F'@' '{ print $1 }')
          mail_domain=$(echo "${this_da_reseller_mail_users[count_n]}" | awk -F'@' '{ print $2 }')
          mail_password=${this_da_reseller_mail_passwords[count_n]}

          echo "DA reseller_username: ${this_da_reseller_username}"
          echo "DA reseller_userpass: ${this_da_reseller_userpass}"
          echo "The full user email address: [${count_n}]: ${this_da_reseller_mail_users[count_n]}"
          echo "The mail_username (no @domain.com): ${mail_user}"
          echo "The mail_domain: ${mail_domain}"
          echo "The mail_password:[${count_n}]: ${this_da_reseller_mail_passwords[count_n]}"
          echo "=~=~=~=~+~+~+~=~+~+=~+~+=~+~+=~+~+=~+=~+~+"
          # Now we got all variables for creating email:
          # Call API here:
          da_api_admin "signas+${this_da_reseller_username}+${this_da_reseller_userpass}"
          # Reseller and user share the same API
          da_api_admin "create-user-email" "${mail_domain}" "${mail_user}" "${mail_password}" "0" "200"
          ((count_n++))
        done
        ((count_x++))
        echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
      fi
    done
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_user_emails() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  #rm -f "${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_user_mail_users da_user_mail_users_count count_mail_user
    local this_da_user_username this_da_user_userpass this_da_user_mail_users this_da_user_mail_passwords
    local this_da_user_mail_users_count this_da_user_mail_password_count
    local count_n mail_user mail_domain
    # Get all variables set for DA_USER_MAIL_USER[index]:
    da_user_mail_users="${!DA_USER_MAIL_USER@}"
    # Calculate the total for the total variable of DA_USER_MAIL_USER
    da_user_mail_users_count=$(echo "${da_user_mail_users}" | wc -w)
    # Debug:
    echo "DA_USER_MAIL_USERS: ${da_user_mail_users}"
    echo "DA_USER_MAIL_USERS_COUNT: ${da_user_mail_users_count}"
    # Initial value to start looping
    count_mail_user=1
    while [[ ${count_mail_user} -le ${da_user_mail_users_count} ]]; do
      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
      echo "COUNT_MAIL_USER INDEX = ${count_mail_user}"
      echo ""
      # Assign all variables from the config file as array index
      typeset -n "this_da_user_username"="DA_USER_USERNAME${count_mail_user}"
      typeset -n "this_da_user_userpass"="DA_USER_USERPASS${count_mail_user}"
      typeset -n "this_da_user_mail_users"="DA_USER_MAIL_USER${count_mail_user}"
      typeset -n "this_da_user_mail_passwords"="DA_USER_MAIL_PASSWORD${count_mail_user}"
      # Error checking for missing variable values:
      if [ -z "${this_da_user_username}" ]; then
        echo "[${SCRIPT_NAME}]: [Skipped]: Warning, no user_name is set in config file for this mail_user. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      elif [ -z "${this_da_user_userpass}" ]; then
        echo "[${SCRIPT_NAME}]: [Skipped]: Warning, no user_password is set in config file for this mail_user. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      elif [ -z "${this_da_user_mail_users}" ]; then
        echo "[${SCRIPT_NAME}]: [Skipped]: Warning, no user_emails is set in config file for this mail_user. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      elif [ -z "${this_da_user_mail_passwords}" ]; then
        echo "[${SCRIPT_NAME}]: [Skipped]: Warning, no user_email_passwords is set in config file for this mail_user. Please check configuration file " 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      elif [ ${#this_da_user_mail_users[@]} -ne ${#this_da_user_mail_passwords[@]} ]; then
        echo "[${SCRIPT_NAME}]: [Skipped]: Warning, mail users and mail passwords defined with different length of array" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      else
        this_da_user_mail_users_count="${#this_da_user_mail_users[@]}"
        this_da_user_mail_password_count="${#this_da_user_mail_passwords[@]}"
        # Debug
        echo "this_da_user_mail_users: ${this_da_user_mail_users[*]}"
        echo "this_da_user_mail_passwords: ${this_da_user_mail_passwords[*]}"
        echo "mail_user_count: ${this_da_user_mail_users_count}"
        echo "mail_password_count: ${this_da_user_mail_password_count}"
        count_n=0
        while [ ${count_n} -le $((this_da_user_mail_users_count - 1)) ]; do
          echo "=~=~=~=~+~Count: ${count_n}+~+~=~+~+~+~+"

          mail_user=$(echo "${this_da_user_mail_users[count_n]}" | awk -F'@' '{ print $1 }')
          mail_domain=$(echo "${this_da_user_mail_users[count_n]}" | awk -F'@' '{ print $2 }')
          mail_password=${this_da_user_mail_passwords[count_n]}

          echo "DA user_username: ${this_da_user_username}"
          echo "DA user_userpass: ${this_da_user_userpass}"
          echo "The full user email address: [${count_n}]: ${this_da_user_mail_users[count_n]}"
          echo "The mail_username (no @domain.com): ${mail_user}"
          echo "The mail_domain: ${mail_domain}"
          echo "The mail_password:[${count_n}]: ${this_da_user_mail_passwords[count_n]}"
          echo "=~=~=~=~+~+~+~=~+~+=~+~+=~+~+=~+~+=~+=~+~+"
          # Now we got all variables for creating email:
          # Call API here:
          da_api_admin "signas+${this_da_user_username}+${this_da_user_userpass}"
          da_api_admin "create-user-email" "${mail_domain}" "${mail_user}" "${mail_password}" "0" "200"
          ((count_n++))
        done
        ((count_mail_user++))
        echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
      fi
    done
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_reseller_domain_ssl_pre() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_reseller_ssl_sub_names da_reseller_ssl_sub_names_count count_x count_n count_o
    local this_da_reseller_uname this_da_reseller_userpass this_da_reseller_enable_domain_ssl \
      this_da_reseller_ssl_sub_names retval le_select_query
    # Get all the reseller ssl_sub_names
    da_reseller_ssl_sub_names="${!DA_RESELLER_SSL_SUB_NAME@}"
    # Get the total count for reseller ssl_sub_names
    da_reseller_ssl_sub_names_count=$(echo "${da_reseller_ssl_sub_names}" | wc -w)
    count_x=1
    echo "[${SCRIPT_NAME}]: Creating acme-challenge file through custombuild rewrite_confs ..." 2>&1 | tee -a "${REPORT_FILE}"
    /usr/local/directadmin/custombuild/build rewrite_confs
    while [[ ${count_x} -le ${da_reseller_ssl_sub_names_count} ]]; do
      echo ""
      echo "===== Loop count: ${count_x} ========="
      typeset -n "this_da_reseller_username"="DA_RESELLER_USERNAME${count_x}"
      typeset -n "this_da_reseller_userpass"="DA_RESELLER_USERPASS${count_x}"
      typeset -n "this_da_reseller_enable_domain_ssl"="DA_RESELLER_ENABLE_DOMAIN_SSL${count_x}"
      typeset -n "this_da_reseller_ssl_sub_names"="DA_RESELLER_SSL_SUB_NAME${count_x}"

      echo "this_da_reseller_username: ${this_da_reseller_username}"
      echo "this_da_reseller_userpass: ${this_da_reseller_userpass}"
      echo "this_da_reseller_enable_domain_ssl: ${this_da_reseller_enable_domain_ssl}"
      echo "this_da_reseller_ssl_sub_names: ${this_da_reseller_ssl_sub_names[*]}"
      this_da_reseller_ssl_sub_names_count=${#this_da_reseller_ssl_sub_names[@]}
      echo "this_da_reseller_ssl_sub_names_count: ${this_da_reseller_ssl_sub_names_count}"
      echo "=========================================="

      if [[ ${this_da_reseller_enable_domain_ssl} == "yes" ]]; then
        echo ""
        echo "OK, This reseller is set to enable SSL"
        count_n=0
        while [ ${count_n} -le $((this_da_reseller_ssl_sub_names_count - 1)) ]; do
          echo ""

          ssl_provider=$(echo "${this_da_reseller_ssl_sub_names[count_n]}" | awk -F':' '{ print $1 }')
          ssl_domain=$(echo "${this_da_reseller_ssl_sub_names[count_n]}" | awk -F':' '{ print $2 }')
          ssl_subdomains_raw=$(echo "${this_da_reseller_ssl_sub_names[count_n]}" | awk -F':' '{ print $3 }')
          # Debug
          # echo "==============---count_n = ${count_n} ---==============="
          # echo "SSL_PROVIDER: ${ssl_provider}"
          # echo "SSL_DOMAIN: ${ssl_domain}"
          # echo "SSL_SUBDOMAINS_RAW: ${ssl_subdomains_raw}"

          if [ "${ssl_provider}" == "letsencrypt" ]; then
            echo "Testing, requesting letsencrypt SSL certificate for domain ${ssl_domain} in staging mode ..."
            staging=yes /usr/local/directadmin/scripts/letsencrypt.sh request_single "${ssl_domain}"
            retval=$?
            if [ ${retval} -ne 0 ]; then
              echo "Warning, this domain ${ssl_domain} has issue when requesting ssl certificate in staging mode"
            else
              echo "OK, this domain ${ssl_domain} has no issue when requesting ssl certificate in staging mode"
            fi

            count_o=0
            le_select_query=""
            for ssl_subdomain in ${ssl_subdomains}; do
              if [ ${count_o} = 0 ]; then
                le_select[${count_o}]="${ssl_domain}"
                echo "Count OO: ${le_select_query}"
              else
                le_select[${count_o}]="${ssl_subdomain}.${ssl_domain}"
                echo "Count > 00: ${le_select_query}"
              fi
              ((count_o++))
            done
          elif [ "${ssl_provider}" == "digicert" ]; then
            :
          fi
          ((count_n++))
        done
      elif [[ ${this_da_user_enable_domain_ssl} == "no" ]]; then
        echo "Warning This user is set to not enable SSL. Do nothing for this"
      fi
      echo ""
      ((count_x++))

    done
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_user_domain_ssl_pre() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_user_ssl_sub_names da_user_ssl_sub_names_count
    local this_da_user_uname this_da_user_userpass this_da_user_enable_domain_ssl \
      this_da_user_ssl_sub_names retval
    # Get all the user ssl_sub_names
    da_user_ssl_sub_names="${!DA_USER_SSL_SUB_NAME@}"
    # Get the total count for user ssl_sub_names
    da_user_ssl_sub_names_count=$(echo "${da_user_ssl_sub_names}" | wc -w)
    count_x=1
    echo "[${SCRIPT_NAME}]: Creating acme-challenge file through custombuild rewrite_confs ..." 2>&1 | tee -a "${REPORT_FILE}"
    /usr/local/directadmin/custombuild/build rewrite_confs
    while [[ ${count_x} -le ${da_user_ssl_sub_names_count} ]]; do
      echo ""
      echo "===== Loop count: ${count_x} ========="
      typeset -n "this_da_user_username"="DA_USER_USERNAME${count_x}"
      typeset -n "this_da_user_userpass"="DA_USER_USERPASS${count_x}"
      typeset -n "this_da_user_enable_domain_ssl"="DA_USER_ENABLE_DOMAIN_SSL${count_x}"
      typeset -n "this_da_user_ssl_sub_names"="DA_USER_SSL_SUB_NAME${count_x}"

      echo "this_da_user_username: ${this_da_user_username}"
      echo "this_da_user_userpass: ${this_da_user_userpass}"
      echo "this_da_user_enable_domain_ssl: ${this_da_user_enable_domain_ssl}"
      echo "this_da_user_ssl_sub_names: ${this_da_user_ssl_sub_names[*]}"
      this_da_user_ssl_sub_names_count=${#this_da_user_ssl_sub_names[@]}
      echo "=========================================="

      if [[ ${this_da_user_enable_domain_ssl} == "yes" ]]; then
        echo ""
        echo "OK, This user is set to enable SSL"
        count_n=0
        while [ ${count_n} -le $((this_da_user_ssl_sub_names_count - 1)) ]; do
          echo ""

          ssl_provider=$(echo "${this_da_user_ssl_sub_names[count_n]}" | awk -F':' '{ print $1 }')
          ssl_domain=$(echo "${this_da_user_ssl_sub_names[count_n]}" | awk -F':' '{ print $2 }')
          ssl_subdomains_raw=$(echo "${this_da_user_ssl_sub_names[count_n]}" | awk -F':' '{ print $3 }')
          # Debug
          # echo "==============---count_n = ${count_n} ---==============="
          # echo "SSL_PROVIDER: ${ssl_provider}"
          # echo "SSL_DOMAIN: ${ssl_domain}"
          # echo "SSL_SUBDOMAINS_RAW: ${ssl_subdomains_raw}"

          if [ "${ssl_provider}" == "letsencrypt" ]; then
            echo "Testing, requesting letsencrypt SSL certificate for domain ${ssl_domain} in staging mode ..."
            staging=yes /usr/local/directadmin/scripts/letsencrypt.sh request_single "${ssl_domain}"
            retval=$?
            if [ ${retval} -ne 0 ]; then
              echo "Warning, this domain ${ssl_domain} has issue when requesting ssl certificate in staging mode"
            else
              echo "OK, this domain ${ssl_domain} has no issue when requesting ssl certificate in staging mode"
            fi
          elif [ "${ssl_provider}" == "digicert" ]; then
            :
          fi
          ((count_n++))
        done
      elif [[ ${this_da_user_enable_domain_ssl} == "no" ]]; then
        echo "Warning This user is set to not enable SSL. Do nothing for this"
      fi
      echo ""
      ((count_x++))

    done
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_reseller_domain_ssl() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # Here we configure SSL for specific domains we want based on the config variable: DA_RESELLER_ENABLE_DOMAIN_SSL{?}
  # Where Domain can have 1 or more
  #rm -f "${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_reseller_ssl_sub_names da_reseller_ssl_sub_names_count
    local this_da_reseller_uname this_da_reseller_userpass this_da_reseller_enable_domain_ssl \
      this_da_reseller_ssl_sub_names retval
    # Get all the reseller ssl_sub_names
    da_reseller_ssl_sub_names="${!DA_RESELLER_SSL_SUB_NAME@}"
    # Get the total count for reseller ssl_sub_names
    da_reseller_ssl_sub_names_count=$(echo "${da_reseller_ssl_sub_names}" | wc -w)
    count_x=1
    echo "[${SCRIPT_NAME}]: Creating acme-challenge file through custombuild rewrite_confs ..." 2>&1 | tee -a "${REPORT_FILE}"
    /usr/local/directadmin/custombuild/build rewrite_confs
    while [[ ${count_x} -le ${da_reseller_ssl_sub_names_count} ]]; do
      echo ""
      echo "===== Loop count: ${count_x} ========="
      typeset -n "this_da_reseller_username"="DA_RESELLER_USERNAME${count_x}"
      typeset -n "this_da_reseller_userpass"="DA_RESELLER_USERPASS${count_x}"
      typeset -n "this_da_reseller_enable_domain_ssl"="DA_RESELLER_ENABLE_DOMAIN_SSL${count_x}"
      typeset -n "this_da_reseller_ssl_sub_names"="DA_RESELLER_SSL_SUB_NAME${count_x}"

      echo "this_da_reseller_username: ${this_da_reseller_username}"
      echo "this_da_reseller_userpass: ${this_da_reseller_userpass}"
      echo "this_da_reseller_enable_domain_ssl: ${this_da_reseller_enable_domain_ssl}"
      echo "this_da_reseller_ssl_sub_names: ${this_da_reseller_ssl_sub_names[*]}"
      this_da_reseller_ssl_sub_names_count=${#this_da_reseller_ssl_sub_names[@]}
      echo "=========================================="

      if [[ ${this_da_reseller_enable_domain_ssl} == "yes" ]]; then
        echo ""
        echo "OK, This reseller is set to enable SSL"
        count_n=0
        while [ ${count_n} -le $((this_da_reseller_ssl_sub_names_count - 1)) ]; do
          echo ""

          ssl_provider=$(echo "${this_da_reseller_ssl_sub_names[count_n]}" | awk -F':' '{ print $1 }')
          ssl_domain=$(echo "${this_da_reseller_ssl_sub_names[count_n]}" | awk -F':' '{ print $2 }')
          ssl_subdomains_raw=$(echo "${this_da_reseller_ssl_sub_names[count_n]}" | awk -F':' '{ print $3 }')
          # Debug
          echo "==============---count_n = ${count_n} ---==============="
          echo "SSL_PROVIDER: ${ssl_provider}"
          echo "SSL_DOMAIN: ${ssl_domain}"
          echo "SSL_SUBDOMAINS_RAW: ${ssl_subdomains_raw}"

          if [ "${ssl_provider}" == "letsencrypt" ]; then
            echo "Testing, requesting letsencrypt SSL certificate for domain ${ssl_domain} in staging mode ..."
            staging=yes /usr/local/directadmin/scripts/letsencrypt.sh request "${ssl_domain}"
            retval=$?
            if [ ${retval} -ne 0 ]; then
              echo "Warning, this domain ${ssl_domain} has issue when requesting ssl certificate in staging mode"
              # TODO add the ability to resume failed certificate request for reseller (when rerun this script)
            else
              echo "OK, this domain ${ssl_domain} has no issue when requesting ssl certificate in staging mode"
            fi
            ssl_subdomains=$(echo "${ssl_subdomains_raw}" | awk -F'+' '{for (i=0;i<=NF;i++)print $i}')
            count_o=0
            le_select_query=""
            for ssl_subdomain in ${ssl_subdomains}; do
              if [ ${count_o} = 0 ]; then
                le_select[${count_o}]="${ssl_domain}"
                ls="le_select${count_o}=${le_select[${count_o}]}"
              else
                le_select[${count_o}]="${ssl_subdomain}.${ssl_domain}"
                ls="&le_select${count_o}=${le_select[${count_o}]}"
              fi
              le_select_query="${le_select_query}${ls}"
              ((count_o++))
            done
            echo "LE_SELECT_QUERY: ${le_select_query}"
            echo "================-------------------======================="
            echo ""
            # Now we got all variables. Call API here:
            # da_api_admin "request-domain-ssl" <provider> <root_domain> <keysize> <encryption> <ssl_sub_domains_query>
            # Seems like DA admin or owner level also can use this authentication to request certificate for user (I will verify this again)
            da_api_admin "signas+${this_da_reseller_username}+${this_da_reseller_userpass}"
            # Most secure key now is secp521r1 and sha256
            echo "Requesting SSL for domain ${ssl_domain} with the following query: ${le_select_query}"
            echo "This might take sometimes ... (please wait)"
            da_api_admin "request-domain-ssl" "${ssl_provider}" "${ssl_domain}" "secp521r1" "sha256" "${le_select_query}"
          elif [ "${ssl_provider}" == "digicert" ]; then
            :
          fi
          ((count_n++))
        done
      elif [[ ${this_da_user_enable_domain_ssl} == "no" ]]; then
        echo "Warning This user is set to not enable SSL. Do nothing for this"
      fi
      echo ""
      ((count_x++))

    done
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}
function configure_da_user_domain_ssl() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # Here we configure SSL for specific domains we want based on the config variable: DA_USER_ENABLE_DOMAIN_SSL{?}
  # Where Domain can have 1 or more
  #rm -f "${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_user_ssl_sub_names da_user_ssl_sub_names_count this_da_user_username this_da_user_userpass \
      this_da_user_enable_domain_ssl this_da_user_ssl_sub_names this_da_user_ssl_sub_names_count
    local ssl_provider ssl_domain ssl_subdomains_raw le_select_query le_s count_o count_n count_x retval
    # Get all the user ssl_sub_names
    da_user_ssl_sub_names="${!DA_USER_SSL_SUB_NAME@}"
    # Get the total count for user ssl_sub_names
    da_user_ssl_sub_names_count=$(echo "${da_user_ssl_sub_names}" | wc -w)
    count_x=1
    while [[ ${count_x} -le ${da_user_ssl_sub_names_count} ]]; do
      echo ""
      echo ""
      echo "===== countx = ${count_x} ========="
      typeset -n "this_da_user_username"="DA_USER_USERNAME${count_x}"
      typeset -n "this_da_user_userpass"="DA_USER_USERPASS${count_x}"
      typeset -n "this_da_user_enable_domain_ssl"="DA_USER_ENABLE_DOMAIN_SSL${count_x}"
      typeset -n "this_da_user_ssl_sub_names"="DA_USER_SSL_SUB_NAME${count_x}"

      echo "this_da_user_username: ${this_da_user_username}"
      echo "this_da_user_userpass: ${this_da_user_userpass}"
      echo "this_da_user_enable_domain_ssl: ${this_da_user_enable_domain_ssl}"
      echo "this_da_user_ssl_sub_names: ${this_da_user_ssl_sub_names[*]}"
      this_da_user_ssl_sub_names_count=${#this_da_user_ssl_sub_names[@]}

      if [[ ${this_da_user_enable_domain_ssl} == "yes" ]]; then
        echo ""
        echo "=========================================="
        echo "OK, This user is set to enable SSL"
        count_n=0
        while [ ${count_n} -le $((this_da_user_ssl_sub_names_count - 1)) ]; do
          echo ""
          echo "---count_n=${count_n} ---"
          ssl_provider=$(echo "${this_da_user_ssl_sub_names[count_n]}" | awk -F':' '{ print $1 }')
          ssl_domain=$(echo "${this_da_user_ssl_sub_names[count_n]}" | awk -F':' '{ print $2 }')
          ssl_subdomains_raw=$(echo "${this_da_user_ssl_sub_names[count_n]}" | awk -F':' '{ print $3 }')
          # Debug
          echo "SSL_PROVIDER: ${ssl_provider}"
          echo "SSL_DOMAIN: ${ssl_domain}"
          echo "SSL_SUBDOMAINS_RAW: ${ssl_subdomains_raw}"
          if [ "${ssl_provider}" == "letsencrypt" ]; then
            echo "Testing, requesting letsencrypt SSL certificate for domain ${ssl_domain} in staging mode ..."
            staging=yes /usr/local/directadmin/scripts/letsencrypt.sh request "${ssl_domain}"
            retval=$?
            if [ ${retval} -ne 0 ]; then
              echo "Warning, this domain ${ssl_domain} has issue when requesting ssl certificate in staging mode"
              # TODO add the ability to resume failed certificate request for user when rerun this script
            else
              echo "OK, this domain ${ssl_domain} has no issue when requesting ssl certificate in staging mode"
            fi
            ssl_subdomains=$(echo "${ssl_subdomains_raw}" | awk -F'+' '{for (i=0;i<=NF;i++)print $i}')
            count_o=0
            le_select_query=""
            for ssl_subdomain in ${ssl_subdomains}; do
              if [ ${count_o} = 0 ]; then
                le_select[${count_o}]="${ssl_domain}"
                le_s="le_select${count_o}=${le_select[${count_o}]}"
              else
                le_select[${count_o}]="${ssl_subdomain}.${ssl_domain}"
                le_s="&le_select${count_o}=${le_select[${count_o}]}"
              fi
              le_select_query="${le_select_query}${le_s}"
              ((count_o++))
            done
            echo "---------------"
            echo "LE_SELECT_QUERY: ${le_select_query}"
            echo ""
            # Now we got all variables. Call API here:
            # da_api_admin "request-domain-ssl" <provider> <root_domain> <keysize> <encryption> <ssl_sub_domains_query>
            da_api_admin "signas+${this_da_user_username}+${this_da_user_userpass}"
            # Most secure key now is secp521r1 and sha256
            echo "Requesting SSL for domain ${ssl_domain} with the following query: ${le_select_query}"
            da_api_admin "request-domain-ssl" "${ssl_provider}" "${ssl_domain}" "secp521r1" "sha256" "${le_select_query}"

          elif [ "${ssl_provider}" == "digicert" ]; then
            :
          fi

          ((count_n++))
        done

      elif [[ ${this_da_user_enable_domain_ssl} == "no" ]]; then
        echo "Warning This user is set to not enable SSL. Do nothing for this"
      fi
      echo "=========================================="
      ((count_x++))

    done
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_owner_security() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # Set owner security and answer questions:
  # da_admin_api "set-security-qna" "Sekolah menengah dulu aliran apa ?" "sains"

  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_owner_usernames da_owner_usernames_count this_da_owner_username this_da_owner_userpass
    local this_da_owner_security_qs this_da_owner_security_as this_da_owner_security_qs_count count_n

    da_owner_usernames="${!DA_OWNER_USERNAME@}"
    da_owner_usernames_count=$(echo "${da_owner_usernames}" | wc -w)
    count_n=1
    echo "da_owner_usernames: ${da_owner_usernames}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "da_owner_usernames_count: ${da_owner_usernames_count}" 2>&1 | tee -a "${REPORT_FILE}"
    # Debug:
    while [ ${count_n} -le "${da_owner_usernames_count}" ]; do

      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"
      echo "count_n INDEX = ${count_n}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "" 2>&1 | tee -a "${REPORT_FILE}"
      # Assign all variables from the config file as array index
      typeset -n "this_da_owner_username"="DA_OWNER_USERNAME${count_n}"
      typeset -n "this_da_owner_userpass"="DA_OWNER_USERPASS${count_n}"
      typeset -n "this_da_owner_security_qs"="DA_OWNER_SECURITY_Q${count_n}"
      typeset -n "this_da_owner_security_as"="DA_OWNER_SECURITY_A${count_n}"

      echo "this_da_owner_username: ${this_da_owner_username}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_owner_userpass: ${this_da_owner_userpass}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_owner_security_qs: ${this_da_owner_security_qs[*]}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_owner_security_as: ${this_da_owner_security_as[*]}" 2>&1 | tee -a "${REPORT_FILE}"

      this_da_owner_security_qs_count="${#this_da_owner_security_qs[@]}"

      count_o=0

      while [ ${count_o} -le $((this_da_owner_security_qs_count - 1)) ]; do
        security_question=${this_da_owner_security_qs[count_o]}
        security_answer=${this_da_owner_security_as[count_o]}

        echo "Security question for owner: ${this_da_owner_username}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "Security question: ${security_question}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "Security answer: ${security_answer}" 2>&1 | tee -a "${REPORT_FILE}"
        if [[ "${#security_question}" == 0 || "${#security_answer}" == 0 ]]; then
          echo "[${SCRIPT_NAME}]: [skipped]: Value defined for security_question or security answer (or both) are empty"
          ((count_o++))
          continue
        fi
        echo "[${SCRIPT_NAME}]: Setting up security question and answer for owner ${this_da_owner_username}" 2>&1 | tee -a "${REPORT_FILE}"
        da_api_admin "signas+${this_da_owner_username}+${this_da_owner_userpass}"
        da_api_admin "set-security-qna" "${security_question}" "${security_answer}"

        ((count_o++))
      done

      ((count_n++))
      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"

    done
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_admin_security() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # Set admin security and answer questions:
  # da_admin_api "set-security-qna" "Sekolah menengah dulu aliran apa ?" "sains"

  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_admin_usernames da_admin_usernames_count this_da_admin_username this_da_admin_userpass
    local this_da_admin_security_qs this_da_admin_security_as this_da_admin_security_qs_count count_n

    da_admin_usernames="${!DA_ADMIN_USERNAME@}"
    da_admin_usernames_count=$(echo "${da_admin_usernames}" | wc -w)
    count_n=1
    echo "da_admin_usernames: ${da_admin_usernames}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "da_admin_usernames_count: ${da_admin_usernames_count}" 2>&1 | tee -a "${REPORT_FILE}"
    # Debug:
    while [ ${count_n} -le "${da_admin_usernames_count}" ]; do

      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"
      echo "count_n INDEX = ${count_n}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "" 2>&1 | tee -a "${REPORT_FILE}"
      # Assign all variables from the config file as array index
      typeset -n "this_da_admin_username"="DA_ADMIN_USERNAME${count_n}"
      typeset -n "this_da_admin_userpass"="DA_ADMIN_USERPASS${count_n}"
      typeset -n "this_da_admin_security_qs"="DA_ADMIN_SECURITY_Q${count_n}"
      typeset -n "this_da_admin_security_as"="DA_ADMIN_SECURITY_A${count_n}"

      echo "this_da_admin_username: ${this_da_admin_username}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_admin_userpass: ${this_da_admin_userpass}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_admin_security_qs: ${this_da_admin_security_qs[*]}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_admin_security_as: ${this_da_admin_security_as[*]}" 2>&1 | tee -a "${REPORT_FILE}"

      this_da_admin_security_qs_count="${#this_da_admin_security_qs[@]}"

      count_o=0

      while [ ${count_o} -le $((this_da_admin_security_qs_count - 1)) ]; do
        security_question=${this_da_admin_security_qs[count_o]}
        security_answer=${this_da_admin_security_as[count_o]}

        echo "Security question for admin: ${this_da_admin_username}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "Security question: ${security_question}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "Security answer: ${security_answer}" 2>&1 | tee -a "${REPORT_FILE}"
        if [[ "${#security_question}" == 0 || "${#security_answer}" == 0 ]]; then
          echo "[${SCRIPT_NAME}]: [skipped]: Value defined for security_question or security answer (or both) are empty"
          ((count_o++))
          continue
        fi
        echo "[${SCRIPT_NAME}]: Setting up security question and answer for admin ${this_da_admin_username}" 2>&1 | tee -a "${REPORT_FILE}"
        da_api_admin "signas+${this_da_admin_username}+${this_da_admin_userpass}"
        da_api_admin "set-security-qna" "${security_question}" "${security_answer}"

        ((count_o++))
      done

      ((count_n++))
      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"

    done
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_reseller_security() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # Set reseller security and answer questions:
  # da_admin_api "set-security-qna" "Sekolah menengah dulu aliran apa ?" "sains"

  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_reseller_usernames da_reseller_usernames_count this_da_reseller_username this_da_reseller_userpass
    local this_da_reseller_security_qs this_da_reseller_security_as this_da_reseller_security_qs_count count_n

    da_reseller_usernames="${!DA_RESELLER_USERNAME@}"
    da_reseller_usernames_count=$(echo "${da_reseller_usernames}" | wc -w)
    count_n=1
    echo "da_reseller_usernames: ${da_reseller_usernames}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "da_reseller_usernames_count: ${da_reseller_usernames_count}" 2>&1 | tee -a "${REPORT_FILE}"
    # Debug:
    while [ ${count_n} -le "${da_reseller_usernames_count}" ]; do

      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"
      echo "count_n INDEX = ${count_n}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "" 2>&1 | tee -a "${REPORT_FILE}"
      # Assign all variables from the config file as array index
      typeset -n "this_da_reseller_username"="DA_RESELLER_USERNAME${count_n}"
      typeset -n "this_da_reseller_userpass"="DA_RESELLER_USERPASS${count_n}"
      typeset -n "this_da_reseller_security_qs"="DA_RESELLER_SECURITY_Q${count_n}"
      typeset -n "this_da_reseller_security_as"="DA_RESELLER_SECURITY_A${count_n}"

      echo "this_da_reseller_username: ${this_da_reseller_username}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_userpass: ${this_da_reseller_userpass}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_security_qs: ${this_da_reseller_security_qs[*]}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_security_as: ${this_da_reseller_security_as[*]}" 2>&1 | tee -a "${REPORT_FILE}"

      this_da_reseller_security_qs_count="${#this_da_reseller_security_qs[@]}"

      count_o=0

      while [ ${count_o} -le $((this_da_reseller_security_qs_count - 1)) ]; do
        security_question=${this_da_reseller_security_qs[count_o]}
        security_answer=${this_da_reseller_security_as[count_o]}

        echo "Security question for reseller: ${this_da_reseller_username}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "Security question: ${security_question}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "Security answer: ${security_answer}" 2>&1 | tee -a "${REPORT_FILE}"
        if [[ "${#security_question}" == 0 || "${#security_answer}" == 0 ]]; then
          echo "[${SCRIPT_NAME}]: [skipped]: Value defined for security_question or security answer (or both) are empty"
          ((count_o++))
          continue
        fi
        echo "[${SCRIPT_NAME}]: Setting up security question and answer for reseller ${this_da_reseller_username}" 2>&1 | tee -a "${REPORT_FILE}"
        da_api_admin "signas+${this_da_reseller_username}+${this_da_reseller_userpass}"
        da_api_admin "set-security-qna" "${security_question}" "${security_answer}"

        ((count_o++))
      done

      ((count_n++))
      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"

    done
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_da_user_security() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  # Set user security and answer questions:
  # da_admin_api "set-security-qna" "Sekolah menengah dulu aliran apa ?" "sains"
  # Don't use 2 step authentication yet because of this:
  # https://forum.directadmin.com/threads/feature-request-dont-use-online-service-to-generate-otp-qr-code-for-security.63140/
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_user_usernames da_user_usernames_count this_da_user_username this_da_user_userpass
    local this_da_user_security_qs this_da_user_security_as this_da_user_security_qs_count count_n

    da_user_usernames="${!DA_USER_USERNAME@}"
    da_user_usernames_count=$(echo "${da_user_usernames}" | wc -w)
    count_n=1
    echo "da_user_usernames: ${da_user_usernames}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "da_user_usernames_count: ${da_user_usernames_count}" 2>&1 | tee -a "${REPORT_FILE}"
    # Debug:
    while [ ${count_n} -le "${da_user_usernames_count}" ]; do

      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"
      echo "count_n INDEX = ${count_n}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "" 2>&1 | tee -a "${REPORT_FILE}"
      # Assign all variables from the config file as array index
      typeset -n "this_da_user_username"="DA_USER_USERNAME${count_n}"
      typeset -n "this_da_user_userpass"="DA_USER_USERPASS${count_n}"
      typeset -n "this_da_user_security_qs"="DA_USER_SECURITY_Q${count_n}"
      typeset -n "this_da_user_security_as"="DA_USER_SECURITY_A${count_n}"
      echo "this_da_user_username: ${this_da_user_username}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_user_userpass: ${this_da_user_userpass}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_user_security_qs: ${this_da_user_security_qs[*]}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_user_security_as: ${this_da_user_security_as[*]}" 2>&1 | tee -a "${REPORT_FILE}"

      this_da_user_security_qs_count="${#this_da_user_security_qs[@]}"

      count_o=0

      while [ ${count_o} -le $((this_da_user_security_qs_count - 1)) ]; do
        security_question=${this_da_user_security_qs[count_o]}
        security_answer=${this_da_user_security_as[count_o]}

        echo "Security question for user: ${this_da_user_username}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "Security question: ${security_question}" 2>&1 | tee -a "${REPORT_FILE}"
        echo "Security answer: ${security_answer}" 2>&1 | tee -a "${REPORT_FILE}"
        if [[ "${#security_question}" == 0 || "${#security_answer}" == 0 ]]; then
          echo "[${SCRIPT_NAME}]: [skipped]: Value defined for security_question or security answer (or both) are empty"
          ((count_o++))
          continue
        fi
        echo "[${SCRIPT_NAME}]: Setting up security question and answer for user ${this_da_user_username}" 2>&1 | tee -a "${REPORT_FILE}"
        da_api_admin "signas+${this_da_user_username}+${this_da_user_userpass}"
        da_api_admin "set-security-qna" "${security_question}" "${security_answer}"

        ((count_o++))
      done

      ((count_n++))
      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"

    done
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# Function to create all reseller databases
function configure_da_reseller_databases() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"

    local da_reseller_usernames da_reseller_usernames_count this_da_reseller_username this_da_reseller_userpass \
      this_da_reseller_dbs this_da_reseller_dbs_count count_n count_o db_name db_user db_password sql_users check_sql_user

    da_reseller_usernames="${!DA_RESELLER_USERNAME@}"
    da_reseller_usernames_count=$(echo "${da_reseller_usernames}" | wc -w)
    count_n=1
    echo "da_reseller_usernames: ${da_reseller_usernames}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "da_reseller_usernames_count: ${da_reseller_usernames_count}" 2>&1 | tee -a "${REPORT_FILE}"
    # Debug:
    while [ ${count_n} -le "${da_reseller_usernames_count}" ]; do

      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"
      echo "count_n INDEX = ${count_n}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "" 2>&1 | tee -a "${REPORT_FILE}"
      # Assign all variables from the config file as array index
      typeset -n "this_da_reseller_username"="DA_RESELLER_USERNAME${count_n}"
      typeset -n "this_da_reseller_userpass"="DA_RESELLER_USERPASS${count_n}"
      typeset -n "this_da_reseller_dbs"="DA_RESELLER_DB${count_n}"

      echo "this_da_reseller_username: ${this_da_reseller_username}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_userpass: ${this_da_reseller_userpass}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_reseller_dbs: ${this_da_reseller_dbs[*]}" 2>&1 | tee -a "${REPORT_FILE}"
      this_da_reseller_dbs_count="${#this_da_reseller_dbs[@]}"

      count_o=0

      while [ ${count_o} -le $((this_da_reseller_dbs_count - 1)) ]; do

        db_domain=$(echo "${this_da_reseller_dbs[count_o]}" | awk -F':' '{ print $1 }')
        db_name=$(echo "${this_da_reseller_dbs[count_o]}" | awk -F':' '{ print $2 }')
        db_user=$(echo "${this_da_reseller_dbs[count_o]}" | awk -F':' '{ print $3 }')
        db_password=$(echo "${this_da_reseller_dbs[count_o]}" | awk -F':' '{ print $4 }')

        if [[ "${#this_da_reseller_dbs}" == 0 ]]; then
          echo "[${SCRIPT_NAME}]: [skipped]: Value defined for this reseller database is empty"
          ((count_o++))
          continue
        fi

        sql_users=$(mysql -e "SELECT USER FROM mysql.user;" | jq -rR .)
        check_sql_user=$(echo "${sql_users}" | grep "${this_da_reseller_username}_${db_user}")

        echo "check_sql_user is: ${check_sql_user} (if empty it doesn't exist)"
        echo "api_user: ${this_da_reseller_username}"
        echo "api_password: ${this_da_reseller_userpass}"
        echo "db_domain: ${db_domain}"
        echo "db_name: ${db_name}"
        echo "db_user: ${db_user}"
        echo "db_password: ${db_password}"
        echo "========="
        # da_api_admin "create-user-database" <db_name> <db_username> <db_password> <domain>
        da_api_admin "signas+${this_da_reseller_username}+${this_da_reseller_userpass}"

        if [[ -z "${check_sql_user}" ]]; then
          echo "[${SCRIPT_NAME}]: Creating new database name ${db_name} for reseller ${this_da_reseller_username} on domain ${db_domain} ..."
          da_api_admin "create-database" "${db_name}" "${db_user}" "${db_password}" "${db_domain}"
        else
          echo "[${SCRIPT_NAME}]: Creating new database name ${db_name} for reseller ${this_da_reseller_username} on domain ${db_domain} using existing username ${db_user} ..."
          da_api_admin "create-user-database" "${db_name}" "${db_user}" "${db_domain}"
        fi

        ((count_o++))
      done

      ((count_n++))
      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"

    done

    # da_admin_api "create-user-database" <db_name> <db_username> <db_password> <domain>
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# Function to create all user databases
function configure_da_user_databases() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    local da_user_usernames da_user_usernames_count this_da_user_username this_da_user_userpass \
      this_da_user_dbs this_da_user_dbs_count count_n count_o db_name db_user db_password

    da_user_usernames="${!DA_USER_USERNAME@}"
    da_user_usernames_count=$(echo "${da_user_usernames}" | wc -w)

    count_n=1
    echo "da_user_usernames: ${da_user_usernames}" 2>&1 | tee -a "${REPORT_FILE}"
    echo "da_user_usernames_count: ${da_user_usernames_count}" 2>&1 | tee -a "${REPORT_FILE}"
    # Debug:
    while [ ${count_n} -le "${da_user_usernames_count}" ]; do

      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"
      echo "count_n INDEX = ${count_n}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "" 2>&1 | tee -a "${REPORT_FILE}"
      # Assign all variables from the config file as array index
      typeset -n "this_da_user_username"="DA_USER_USERNAME${count_n}"
      typeset -n "this_da_user_userpass"="DA_USER_USERPASS${count_n}"
      typeset -n "this_da_user_dbs"="DA_USER_DB${count_n}"

      echo "this_da_user_username: ${this_da_user_username}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_user_userpass: ${this_da_user_userpass}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "this_da_user_dbs: ${this_da_user_dbs[*]}" 2>&1 | tee -a "${REPORT_FILE}"
      this_da_user_dbs_count="${#this_da_user_dbs[@]}"

      count_o=0

      while [ ${count_o} -le $((this_da_user_dbs_count - 1)) ]; do
        db_domain=$(echo "${this_da_user_dbs[count_o]}" | awk -F':' '{ print $1 }')
        db_name=$(echo "${this_da_user_dbs[count_o]}" | awk -F':' '{ print $2 }')
        db_user=$(echo "${this_da_user_dbs[count_o]}" | awk -F':' '{ print $3 }')
        db_password=$(echo "${this_da_user_dbs[count_o]}" | awk -F':' '{ print $4 }')

        if [[ "${#this_da_user_dbs}" == 0 ]]; then
          echo "[${SCRIPT_NAME}]: [skipped]: Value defined for this user database is empty"
          ((count_o++))
          continue
        fi

        sql_users=$(mysql -e "SELECT USER FROM mysql.user;" | jq -rR .)
        check_sql_user=$(echo "${sql_users}" | grep "${this_da_user_username}_${db_user}")

        echo "check_sql_user is: ${check_sql_user} (if empty it doesn't exist)"
        echo "api_user: ${this_da_user_username}"
        echo "api_password: ${this_da_user_userpass}"
        echo "db_domain: ${db_domain}"
        echo "db_name: ${db_name}"
        echo "db_user: ${db_user}"
        echo "db_password: ${db_password}"
        echo "========="
        # da_api_admin "create-user-database" <db_name> <db_username> <db_password> <domain>
        da_api_admin "signas+${this_da_user_username}+${this_da_user_userpass}"

        if [[ -z "${check_sql_user}" ]]; then
          echo "[${SCRIPT_NAME}]: Creating new database name ${db_name} for user ${this_da_user_username} on domain ${db_domain} ..."
          da_api_admin "create-database" "${db_name}" "${db_user}" "${db_password}" "${db_domain}"
        else
          echo "[${SCRIPT_NAME}]: Creating new database name ${db_name} for reseller ${this_da_user_username} on domain ${db_domain} using existing username ${db_user} ..."
          da_api_admin "create-user-database" "${db_name}" "${db_user}" "${db_domain}"
        fi

        # There is an issue, when creating Directadmin database, a duplicated username without underscore, will be created
        # Issue described here: https://forum.directadmin.com/threads/bug-duplicated-username-when-creating-database-from-directadmin.63167/#post-327493
        ((count_o++))
      done

      ((count_n++))
      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=" 2>&1 | tee -a "${REPORT_FILE}"

    done

    # da_admin_api "create-user-database" <db_name> <db_username> <db_password> <domain>
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}
# This is a custom function used to modify user websites configuration
function configure_da_custom_webs() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    if [ "${ENABLE_CUSTOM_WEB_SETUP}" == "yes" ]; then
      local websetup_bin
      websetup_bin="${DATA_PATH}/maxisetup/storage/webapps/websetup"
      if [ -f "${websetup_bin}" ]; then
        chmod +x "${websetup_bin}"
        cd_to_path "${DATA_PATH}/maxisetup/storage/webapps"
        ./websetup
      else
        echo "[${SCRIPT_NAME}]: Unable to find websetup script at maxisetup data storage" 2>&1 | tee -a "${REPORT_FILE}"
        _exit 1
      fi
    else
      echo "[${SCRIPT_NAME}]: [Skipped]: Custom websetup is not enabled in config file" 2>&1 | tee -a "${REPORT_FILE}"
    fi
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function harden_with_lynis() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    # Suggested by lynis to disable core dump
    limitsconf="/etc/security/limits.conf"
    limit_append="*                hard    core          0"
    read -ra line_array <<<"${limit_append}"
    line_domain=${line_array[0]}
    line_type=${line_array[1]}
    line_item=${line_array[2]}
    line_value=${line_array[3]}
    gr=$(grep "$line_domain *$line_type  *$line_item *$line_value" "${limitsconf}")

    if [[ -z "${gr}" ]]; then
      echo "[${SCRIPT_NAME}]: Disabling core dump with the following options:"
      echo "${limit_append}"
      echo "${limit_append}" >>"${limitsconf}"
    else
      echo "[${SCRIPT_NAME}]: [Skipped]: Found core dump config is already disabled"
    fi

    echo "# This line disables core dumps for all users" >>/etc/profile
    echo "ulimit -S -c 0 > /dev/null 2>&1" >>/etc/profile
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

function configure_cronjobs() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    # Stopping some services to reduce memory usage like clamav:
    maxicron --stop-some-services

    # Add the above command in crontab so it will run on startup
    {
      echo "# Stop some high memory processes 180 seconds (3 minutes) after reboot"
      echo "@reboot sleep 180 && maxicron --stop-some-services"
    } >>/etc/crontab

    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
  if [[ "${option}" == "--force-exit" ]]; then
    exit 0
  fi
}

# This is used to install extra packages like ncdu, htop and more
function post_setup() {
  local option executed_function
  option="$1"
  executed_function="${CONF_PATH}/${FUNCNAME[0]}_executed"
  if [[ "${option}" == "--force" || "${option}" == "--force-exit" ]]; then
    rm -rf "${executed_function}"
  else
    option=""
  fi
  if [ ! -f "${CONF_PATH}/${FUNCNAME[0]}_executed" ]; then
    echo "[${SCRIPT_NAME}]: Executing ${FUNCNAME[0]} ..." 2>&1 | tee -a "${REPORT_FILE}"
    if [ "${DISTRO_ID}" == "debian" ]; then
      # Install speedtest-cli
      curl -s https://install.speedtest.net/app/cli/install.deb.sh | sudo bash
      apt-get install speedtest
      apt-get -y install ncdu htop mailutils gpg vim mutt 2>&1 | tee -a "${REPORT_FILE}"
    else
      echo "Warning, check the post_setup installation for ${DISTRO_ID}, it's only available for debian!"
    fi
    # TODO: Audit system here with maxinis:
    # maxinis --audit system
    check_finish_reboot "${FUNCNAME[0]}"
  else
    echo "[${SCRIPT_NAME}]: [Skipped]: ${FUNCNAME[0]} has ran before" 2>&1 | tee -a "${REPORT_FILE}"
    echo "=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
  fi
}

temp1() {
  :
}

test1() {
  :
}

# End of function

SCRIPT_NAME=$(basename -- "$0")
SCRIPT_PATH="$(dirname "$(readlink -f "$0")")"
DATE_BIN=$(command -v date)
LOG_PATH="${SCRIPT_PATH}/log"
# Configuration path for script
CONF_PATH="${SCRIPT_PATH}/conf"
DATA_PATH="${SCRIPT_PATH}/data"
CODE_PATH="${SCRIPT_PATH}/code"
TEMP_PATH="${SCRIPT_PATH}/temp"
INST_TEMP_DIR="${TEMP_PATH}/src"

mkdir -p "${LOG_PATH}"
mkdir -p "${CONF_PATH}"
mkdir -p "${DATA_PATH}"
mkdir -p "${CODE_PATH}"
mkdir -p "${TEMP_PATH}"
mkdir -p "${INST_TEMP_DIR}"

RANDSTR="$(${DATE_BIN} '+%d-%m-%Y_%H-%M-%S').${RANDOM}"
DATE_TIME_NOW="$(date '+%d-%m-%Y_%H-%M-%S')" #31-03-2020_11-56-16
if [[ "${USE_ONE_LOG_FILE}" == "yes" ]]; then
  REPORT_FILE="${LOG_PATH}/${SCRIPT_NAME}-report.log"
else
  REPORT_FILE="${LOG_PATH}/${SCRIPT_NAME}-${RANDSTR}-report.log"
fi
REPORT_FILE_ERROR="${LOG_PATH}/${SCRIPT_NAME}-${RANDSTR}-${DATE_TIME_NOW}-error-report.log"

echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
echo "Welcome to Sofibox Host Installation Script" 2>&1 | tee -a "${REPORT_FILE}"
echo "This script is part of Sofibox/MaxiNet implementation" 2>&1 | tee -a "${REPORT_FILE}"
echo "(C) Author: Arafat Ali | Email: arafat@sofibox.com" 2>&1 | tee -a "${REPORT_FILE}"
echo "Sofibox/MaxiNet was developed by Sofibox" 2>&1 | tee -a "${REPORT_FILE}"
echo "URL: http://www.sofibox.com  =~=~=~=~=  " 2>&1 | tee -a "${REPORT_FILE}"
echo "Version: ${APP_VERSION}"
echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~" 2>&1 | tee -a "${REPORT_FILE}"
echo ""

CONFIG_FILE="${SCRIPT_PATH}/maxisetup.conf"
#echo "[${SCRIPT_NAME}]: Checking setup config file ... " 2>&1 | tee -a "${REPORT_FILE}"
if [ -s "${CONFIG_FILE}" ]; then
  #if bash_errs=$(bash -n "${CONFIG_FILE}" 2>&1); then
  # This doesn't actually source it. It just test if source is working.
  # Seems like source doesn't actually return proper return code
  # I wrote a pretty good answer to handle this here:
  # https://stackoverflow.com/questions/46577973/how-to-syntax-check-a-shell-script-before-sourcing-it/65650773#65650773
  source_errs=$(source "${CONFIG_FILE}" 2>&1 >/dev/null)
  # get the return code
  retval=$?
  #echo "${retval}"
  if [ ${retval} = 0 ]; then
    # Let's do the weird thing on string:
    if [ -n "${source_errs}" ]; then
      _echo 'red' "[${SCRIPT_NAME}]: Warning, problem with config file"
      _echo 'red' "Error details:"
      printf "%s\n" "${source_errs}"
      _exit 1
    else
      #echo "[${SCRIPT_NAME}]: Sourcing environment file from ${CONFIG_FILE} ..."
      source "${CONFIG_FILE}"
      retval=$?
      _echo 'green' "[${SCRIPT_NAME}]: [${retval}] OK, config file is valid"

      echo ""
    fi
    #else
    #   echo "[${SCRIPT_NAME}]: [Warning]: The source command returns an error code of ${retval} when sourcing ${CONFIG_FILE}:" 2>&1 | tee -a "${REPORT_FILE_ERROR}"
    #  echo "Error details:"
    #  printf "%s\n" "${source_errs}"
    #  _exit 1
    #fi
  else
    echo "[${SCRIPT_NAME}]: [Warning]: The source command returns an error code of ${retval} when sourcing ${CONFIG_FILE}:" 2>&1 | tee -a "${REPORT_FILE_ERROR}"
    echo "Error details:"
    printf "%s\n" "${source_errs}"
    _exit 1
  fi
else
  echo "[${SCRIPT_NAME}]: Error, ${CONFIG_FILE} does not exist or empty. Need this configuration file" 2>&1 | tee -a "${REPORT_FILE_ERROR}"
  _exit 1
fi

# Global variable to hold progress spin
SPIN_PROGRESS='/-\|'
SPIN_COUNT=0

# A global variable that temporarily holds seconds value
HOLD_SECONDS=0

# A global variable that temporarily holds the current path
PREPATH="${PWD}"

DISTRO_ID=$(get_linux_os "id")
#DISTRO_VERSION=$(get_linux_os "version")

# Set DNS provider
EXTERNAL_DNS_PROVIDER=$(echo "${DNS_PROVIDER_API_KEY1}" | awk -F':' '{ print $1 }')
DNS_PROVIDER_USER=$(echo "${DNS_PROVIDER_API_KEY1}" | awk -F':' '{ print $2 }')
DNS_PROVIDER_API_KEY=$(echo "${DNS_PROVIDER_API_KEY1}" | awk -F':' '{ print $3 }')

ARGNUM="$#"
# Handle option arguments
if [ $ARGNUM -eq 0 ]; then
  echo "[${SCRIPT_NAME}]: Error, no argument is supplied. Use [ ${SCRIPT_NAME} --help ] to see the valid options"
  exit 1
fi

while [ "$#" -gt 0 ]; do
  case "$1" in
  -h | --help)
    usage
    exit 0
    ;;
  # Display Program version
  -V | --version)
    echo ""
    echo "Version Information:"
    echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
    echo "=${APP_SPECIFIC_NAME}-${APP_VERSION}="
    echo "=by Arafat Ali | arafat@sofibox.com ="
    echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
    break
    ;;
  #./maxisetup --setup remote - For remote setup
  #./maxisetup --setup - For local setup
  -setup | --setup)
    shift
    option="$1"
    #if [ "${option}" == "remote" ];  then
    #  _echo 'yellow' "Notice, remote setup is set"
    #  :
    #else
    # ==== Locking mechanism ====
    PID=$(pidof -x "${SCRIPT_NAME}")
    # USE ATOMIC LOCK
    LOCK_DIR="/var/lock/${SCRIPT_NAME}"
    LOCK_PID="${LOCK_DIR}/pid"

    # THIS WILL CHECK ONLY ONE INSTANCE OF SCRIPT SHOULD RUN
    if ! mkdir "${LOCK_DIR}" 2>/dev/null; then
      PID=$(cat "${LOCK_PID}")
      if ! kill -0 "${PID}" 2>/dev/null; then
        echo "[${SCRIPT_NAME}]: Removing stale lock of nonexistent PID ${PID}" 2>&1 | tee -a "${REPORT_FILE}"
        rm -rf "${LOCK_DIR}"
        echo "[${SCRIPT_NAME}]: Restarting (${SCRIPT_NAME})" 2>&1 | tee -a "${REPORT_FILE}"
        exec "$0" "$@"
      fi
      echo "[${SCRIPT_NAME}]: Warning, another instance of this script is already running with PID [${PID}]" 2>&1 | tee -a "${REPORT_FILE}"
      echo "[${SCRIPT_NAME}]: Please wait or clear the current running session to re-run this script" 2>&1 | tee -a "${REPORT_FILE}"
      exit 1
    else
      # LOCK SUCCESS NOW SAVE INFORMATION IN PID
      echo $$ >"${LOCK_PID}"

      CTRL_C_COUNT=0
      # IF SCRIPT EXIT UNSUCCESSFULLY, THEN WE CALL cleanup function
      _traps _trap_cleanup QUIT INT TERM EXIT
    fi
    # ============End of locking===============
    #fi
    echo "Remember you can always resume installation with:"
    echo "For local installation: ${SCRIPT_NAME} --setup"
    echo "For remote installation: ${SCRIPT_NAME} --ssh-login \"${BOX_HOSTNAME_FQDN}:${SSH_PORT}\" \"root:${ROOT_USERNAME}\" \"${SCRIPT_PATH}/maxisetup_ssh.sh\""
    echo ""
    _pause 5
    validate_config

    if [[ ${DISTRO_ID} == "centos" || ${DISTRO_ID} == "debian" ]]; then
      #echo "[${SCRIPT_NAME}]: OK, this operating system [${DISTRO_ID}] is supported!" 2>&1 | tee -a "${REPORT_FILE}"
      :
    else
      echo "[${SCRIPT_NAME}]: Sorry, this operating system [${DISTRO_ID}] is not supported!" 2>&1 | tee -a "${REPORT_FILE}"
      _exit 1
    fi
    if compgen -G "${CONF_PATH}/*_executed" >/dev/null; then
      echo "[${SCRIPT_NAME} | ${DATE_TIME_NOW}]: Resuming from previous installation ..." 2>&1 | tee -a "${REPORT_FILE}"
      START_OR_RESUME="Resuming"
      _pause 10
    else
      START_OR_RESUME="Starting"
    fi
    echo "[${SCRIPT_NAME}]: ${START_OR_RESUME} Installation for ${BOX_HOSTNAME_FQDN} ..." 2>&1 | tee -a "${REPORT_FILE}"
    echo "" 2>&1 | tee -a "${REPORT_FILE}"
    # Use this to install screen or disable Selinux in CentOS
    pre_setup ""
    #exit 1
    # Clone all setup script
    get_latest_maxisetup ""
    # Get the latest security codes from maxicode
    init_local_maxicode ""
    # Hardening server
    secure_box ""
    #exit 1
    # Set password for grub bootloader
    # configure_grub "" --no need because already preseeded with file (automated)
    # Configure basic network 1
    configure_net ""
    # Must run configure_net first before running configure_net2 because we need interface to be ${NIC_INTERFACE_NAME} first #OK
    configure_net2 ""
    # This is where we can configure mount option for disk
    configure_fstab ""
    # Tweaking swap for production server
    configure_sysctl_swap ""      #OK
    # Tweaking kernel etc ..
    configure_sysctl_kernel_fs "" #OK
    # Tweaking IPv4 or Ipv6
    configure_sysctl_ips "" #OK
    # Upgrade system
    upgrade_os "" #Done
    #exit 0
    if [ "${INSTALL_TYPE}" == "directadmin" ]; then
      install_da_pre ""
      #exit 1
      install_da ""
      #exit 1
      # Must run this after install_da and before install_da_post because install_da_post requires valid nginx directive which is fixed at rebuild_da_package
      rebuild_da_package "" #OK -- find more what to rebuild
      #exit 1
      install_da_post "" #OK
      #exit 1
      change_da_auth "" #OK
      #exit 1
      # Linking da ipv6 with ipv4 and vice versa
      link_da_ipv6 "" #OK
      #exit 1
    fi
    # FOR BOTH GENERAL AND DIRECTADMIN INSTALLATION TYPE:
    #Best to execute after install_da because CSF installer will detect if DA exist, it will install CSF in DA way.
    configure_csf ""
    #exit 1
    configure_maxibox ""
    #exit 1
    configure_maxicode_pre ""
    #exit 1
    configure_maxicode ""
    #exit 1
    configure_maxiperm ""
    #exit 1
    configure_maxinis ""
    #exit 1
    configure_maxigpg ""
    #exit 1
    configure_maxida ""
    #exit 1
    configure_maxicron ""
    #exit 1
    configure_maxiaide ""
    #exit 1
    configure_maxiwall ""
    #exit 1
    configure_maxicloud ""
    #exit 1
    configure_maxipass ""
    #exit 1
    # configure_maxify "" -- disable temporarily
    # Need to restart first before running next commands after enable IPv6 because 'tentative status issue with ethX + nginx'.
    # If I don't restart, I won't be able to request cert and letsencrypt will complain about firewall.
    configure_logs ""
    if [ "${INSTALL_TYPE}" == "directadmin" ]; then
      #exit 1
      configure_da_sql ""
      #exit 1
      configure_da_mail ""
      #exit 1
      configure_da_ftp ""
      #exit 1
      configure_nginx_apache ""
      #exit 1
      configure_web_apps_html ""
      #exit 1
      build_da_custom_conf ""
      #exit 1
      configure_da ""
      #exit 1
      configure_da_memcached ""
      #exit 1
      configure_da_geoip ""
      #exit 1
      # we configure dns template before creating admin, reseller and user accounts so they can use new DNS template
      configure_da_dns_templates ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_owner_accounts_executed"
      configure_da_owner_accounts ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_admin_accounts_executed"
      configure_da_admin_accounts ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_reseller_accounts_executed"
      configure_da_reseller_accounts ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_reseller_root_domains_executed"
      configure_da_reseller_root_domains ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_reseller_wildcard_domains_executed"
      configure_da_reseller_wildcard_domains ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_reseller_subdomains_executed"
      configure_da_reseller_subdomains ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_reseller_emails_executed"
      configure_da_reseller_emails ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_user_accounts_executed"
      configure_da_user_accounts ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_user_root_domains_executed"
      configure_da_user_root_domains ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_user_wildcard_domains_executed"
      configure_da_user_wildcard_domains ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_user_subdomains_executed"
      configure_da_user_subdomains ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_user_emails_executed"
      configure_da_user_emails ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_owner_skins_executed"
      configure_da_owner_skins ""
      #rm -rf "${CONF_PATH}/configure_da_admin_skins_executed"
      configure_da_admin_skins ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_reseller_skins_executed"
      configure_da_reseller_skins ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_owner_security_executed"
      configure_da_owner_security ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_admin_security_executed"
      configure_da_admin_security ""
      #exit 1
      configure_da_reseller_security ""
      #rm -rf "${CONF_PATH}/configure_da_user_security_executed"
      configure_da_user_security ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_reseller_databases_executed"
      configure_da_reseller_databases ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_user_databases_executed"
      configure_da_user_databases ""
      #exit 1
      configure_da_custom_webs ""
      #exit 1

      # Must run this functions (configure_da_ssl) after running CSF because we need to make sure all appropriate ports are opened to request certs
      # Warning do not overused configure_da_ssl function because when requesting the same cert for the same domain 7 times for a week, you will get blocked.
      # This will set the hosting to SSL:
      configure_da_ssl_pre ""
      #exit 1
      # It's best to call SSL after domain propagation few hours later.

      # Call certificate request at the end because we want to create DNS entry and propagate first
      # Don't worry if some domains are not able to have SSL because of the propagation problem using external DNS
      configure_da_ssl ""
      #exit 1
      #rm -rf "${CONF_PATH}/configure_da_reseller_domain_ssl_executed"

      configure_da_reseller_domain_ssl_pre ""
      #exit 1
      configure_da_reseller_domain_ssl ""
      #exit 1
      # rm -rf "${CONF_PATH}/configure_da_user_domain_ssl_executed"
      #configure_da_user_domain_ssl_pre
      configure_da_user_domain_ssl ""
      #exit 1
    fi
    #exit 1
    # Still need to add more based on lynis suggestion
    harden_with_lynis ""
    # exit 1
    configure_cronjobs ""
    # exit 1
    post_setup ""
    echo "" 2>&1 | tee -a "${REPORT_FILE}"
    if [ "${INSTALL_TYPE}" == "directadmin" ]; then
      echo "==============" 2>&1 | tee -a "${REPORT_FILE}"
      echo "Directadmin now can be accessed through this URL: " 2>&1 | tee -a "${REPORT_FILE}"
      echo "http://${IPV4_ADD0}:${DA_PORT} or http://${BOX_HOSTNAME_FQDN}:${DA_PORT}" 2>&1 | tee -a "${REPORT_FILE}"
      echo "Username: DA_OWNER_USERNAME1" 2>&1 | tee -a "${REPORT_FILE}"
      echo "Password: *******" 2>&1 | tee -a "${REPORT_FILE}"
      echo "==============" 2>&1 | tee -a "${REPORT_FILE}"
      echo "" 2>&1 | tee -a "${REPORT_FILE}"
      echo ""
    fi
    script_time
    echo "========== Installation Completed ==========" 2>&1 | tee -a "${REPORT_FILE}"
    echo ""
    echo "[${SCRIPT_NAME}]: Destroying setup information in 120 seconds ..." 2>&1 | tee -a "${REPORT_FILE}"
    _pause 120
    # Destroy the setup config deeply
    shred -uvz "${CONFIG_FILE}"
    # Remove all setup information (except CONF_PATH)
    rm -rf "${LOG_PATH}"
    #rm -rf "${CONF_PATH}"
    rm -rf "${DATA_PATH}"
    rm -rf "${CODE_PATH}"
    rm -rf "${TEMP_PATH}"
    rm -rf "${INST_TEMP_DIR}"
    # Clear bash history
    history -c
    exit 0
    break
    ;;
  # Clear all paths
  -cls | --clear)
    rm -rf "${LOG_PATH}"
    rm -rf "${CONF_PATH}"
    rm -rf "${DATA_PATH}"
    rm -rf "${CODE_PATH}"
    rm -rf "${TEMP_PATH}"
    rm -rf "${INST_TEMP_DIR}"
    echo "[${SCRIPT_NAME}]: Program path cleaned"
    exit 0
    break
    ;;
  # setup disk from scratch (eg: from linode)
  # maxisetup --init-server <options>
  # Deprecated documentation below (update later):
  # maxisetup --init-server optional <init-all> optional <rebuild-iso>
  # Note 1: Only use init-all to remove and start re-creating all partitions
  # Note 2: If you run like this maxisetup --init-server init-all
  #   :This will remove all existing partitions including rescue disk and profile. No rescue disk and profile is created
  # Note3: If you run like this (without argument): maxisetup --init-server
  #   :This will remove and re-create system related partitions. It will not disturb the rescue option
  -is | --init-server)
    shift
    option1="$1"
    option2="$2"
    init_all=0
    rebuild_iso=0

    if [[ "${option1}" == "init-all" || "${option2}" == "init-all" ]]; then
       _log yellow "[${SCRIPT_NAME}]: Warning, all disk partitions and configs will be removed with the option init-all"
      init_all=1
    fi
    if [[ "${option1}" == "rebuild-iso" || "${option2}" == "rebuild-iso" ]]; then
       _log yellow "[${SCRIPT_NAME}]: Warning, new ISO will be rebuilt with the config rebuild-iso (RSA key will be replaced)"
      rebuild_iso=1
    fi
    # Pause for warning message above
    _pause 10

    if [ "${EXTERNAL_DNS_PROVIDER}" == "linode" ]; then
      #echo "${rescue_disk_status}"
      box_main_disk=${BOX_MAIN_DISK_RAW_SIZE}
      box_boot_disk=${BOX_BOOT_DISK_RAW_SIZE}
      #box_rescue_disk=${BOX_RESCUE_DISK_RAW_SIZE}
      ((box_os_disk = box_main_disk - box_boot_disk))
       _log default "Configuring linode server for ${BOX_HOSTNAME_FQDN} ..."
      echo ""
      # This step is based on my own tutorial documented on gitlab:
      # 1) Turn off the linode if it's running
      linode_api_admin "shutdown-linode" "${BOX_HOSTNAME_FQDN}"
      # 2) Delete all existing disks (if exist)
      echo ""

      #2.1 Delete disk and config
      if [[ "${init_all}" -eq 1 ]]; then
        linode_api_admin "delete-disks" "${BOX_HOSTNAME_FQDN}"
        echo ""
        linode_api_admin "delete-configs" "${BOX_HOSTNAME_FQDN}"
        echo ""
      else
        # Delete specific disks
        linode_api_admin "delete-disk" "${BOX_HOSTNAME_FQDN}" "Boot_Disk"
        echo ""
        #2.2 Delete OS_Disk
        linode_api_admin "delete-disk" "${BOX_HOSTNAME_FQDN}" "OS_Disk"
        echo ""
        #linode_api_admin "delete-disk" "${BOX_HOSTNAME_FQDN}" "Rescue_Disk"
        #echo ""
        linode_api_admin "delete-config" "${BOX_HOSTNAME_FQDN}" "Boot_Config"
        echo ""
        linode_api_admin "delete-config" "${BOX_HOSTNAME_FQDN}" "OS_Config"
        echo ""
        # Don't worry deleting rescue config and recreate have no effect on OS startup (it's better to have this)
        #linode_api_admin "delete-config" "${BOX_HOSTNAME_FQDN}" "Rescue_Config"
        #echo ""
      fi
      # 3) Create a boot disk
      linode_api_admin "create-disk" "${BOX_HOSTNAME_FQDN}" "Boot_Disk" "raw" "${box_boot_disk}"
      echo ""
      # 4) Create an operating system disk
      linode_api_admin "create-disk" "${BOX_HOSTNAME_FQDN}" "OS_Disk" "raw" "${box_os_disk}"
      echo ""
      #linode_api_admin "create-disk" "${BOX_HOSTNAME_FQDN}" "Rescue_Disk" "raw" "${box_rescue_disk}"
      #echo ""

      # 6) Creating the second profile for Boot_Disk (OS_Disk=/dev/sda, Boot_Disk=/dev/sdb) start /dev/sdb
      linode_api_admin "create-config" "${BOX_HOSTNAME_FQDN}" "Boot_Config" "The installer boot configuration" "paravirt" "linode/direct-disk" "default" "/dev/sdb" "OS_Disk" "Boot_Disk"
      echo ""

      # 7) Creating the third profile for OS_Disk (OS_Disk=/dev/sda) start /dev/sda
      linode_api_admin "create-config" "${BOX_HOSTNAME_FQDN}" "OS_Config" "The operating boot configuration" "paravirt" "linode/direct-disk" "default" "/dev/sda" "OS_Disk"
      echo ""
      # Creating the first profile for Rescue_Disk (OS_Disk=/dev/sda, Boot_Disk=/dev/sdb, Rescue_Disk=/dev/sdc) start /dev/sdc
      #linode_api_admin "create-config" "${BOX_HOSTNAME_FQDN}" "Rescue_Config" "The rescue disk configuration" "paravirt" "linode/direct-disk" "default" "/dev/sdc" "OS_Disk" "Boot_Disk" "Rescue_Disk"
      #echo ""
      #rescue_disk_status=$(
      #  linode_api_admin "check-disk-status" "${BOX_HOSTNAME_FQDN}" "Rescue_Disk"
      #  echo $?
      #)
      # Only create this if the Rescue DISK exist because the config depends on this
      # 0 - exist, 1 - doesn't exist
      #if [ "${rescue_disk_status}" = 0 ]; then
      #  echo "[${SCRIPT_NAME}]: Notice, Rescue Disk exist in linode. Creating rescue disk config Rescue_Config ..."
      #  linode_api_admin "create-config" "${BOX_HOSTNAME_FQDN}" "Rescue_Config" "The rescue disk configuration" "paravirt" "linode/direct-disk" "default" "/dev/sdc" "OS_Disk" "Boot_Disk" "Rescue_Disk"
      #else
      #  echo "[${SCRIPT_NAME}]: Notice, Rescue Disk does not exist in linode. Not creating the config profile for Rescue_Config for now"
      #fi
      #echo ""
      #if [ "${create_rescue}" -eq 1 ]; then
      #2.3 Delete Rescue_Disk
      #_echo 'yellow' "[${SCRIPT_NAME}]: Warning, rescue disk partition and config will be removed and re-created with the option init-rescue at this point"
      #linode_api_admin "delete-disk" "${BOX_HOSTNAME_FQDN}" "Rescue_Disk"
      #echo ""
      #linode_api_admin "create-disk" "${BOX_HOSTNAME_FQDN}" "Rescue_Disk" "raw" "${box_rescue_disk}"
      #echo ""
      #linode_api_admin "delete-config" "${BOX_HOSTNAME_FQDN}" "Rescue_Config"
      #echo ""
      # Creating the first profile for Rescue_Disk (OS_Disk=/dev/sda, Boot_Disk=/dev/sdb, Rescue_Disk=/dev/sdc) start /dev/sdc
      #linode_api_admin "create-config" "${BOX_HOSTNAME_FQDN}" "Rescue_Config" "The rescue disk configuration" "paravirt" "linode/direct-disk" "default" "/dev/sdc" "OS_Disk" "Boot_Disk" "Rescue_Disk"
      #echo ""
      #fi

      _log default "Booting linode ${BOX_HOSTNAME_FQDN} into linode-finnix rescue mode ..."
      # linode_api_admin "rescue-mode" <optional_hostname> <optional_mount_disk1_label> <optional_mount_disk2_label> <optional_mount_diskN_label> ... <optional_mount_disk9>"
      linode_api_admin "boot-rescue" "${BOX_HOSTNAME_FQDN}" "Boot_Disk"

      if [ "${rebuild_iso}" -eq 1 ]; then
        _log red "Warning, new ISO will be rebuilt because the option 'rebuild-iso' is set"
        _pause 10
        # TODO save old ISO as backup before creating new ISO
        create_os_iso "--hdd"
      else
        _log yellow "Notice, using existing ISO because no option is passed to rebuild ISO (eg: rebuild-iso)"
      fi
      #check_linode_status_until "online"
      ssh_key_manager "copy-all-pubkeys"
      _log default "Writing OS into Boot_Disk Partition via SSH background (this will be completed until linode is turned off automatically) ..."
      # This is not a normal SSH (it use Pseudo-TTY)
      ssh -q -o "StrictHostKeyChecking no" -i /root/.ssh/linode_lish.id_rsa -tt "${DNS_PROVIDER_USER}@${DNS_PROVIDER_TERMINAL_SERVER}" "${BOX_HOSTNAME_FQDN}" <"${SCRIPT_PATH}/linode/os_write.sh" >/dev/null 2>&1 &
      check_linode_status_until "offline"
      # After system shutdown, then we can execute the following
      linode_api_admin "boot-linode" "${BOX_HOSTNAME_FQDN}" "Boot_Config"
      _log default "Installing operating system on OS_Disk via preseed file ... (approx 5 minutes. It will finish when linode is turned off automatically): "
      check_linode_status_until "offline"
      _log default "Booting into operating system (make sure to unlock LUKS)"
      linode_api_admin "boot-linode" "${BOX_HOSTNAME_FQDN}" "OS_Config"

      # check server and port if available auto unlock it
      _log default "Checking whether hostname ${BOX_HOSTNAME_FQDN} with port ${DROP_BEAR_PORT} are available ..."
      count=0
      while :; do
        drop_bear_port=$(check_server_port "${BOX_HOSTNAME_FQDN}" "${DROP_BEAR_PORT}")
        sleep 1
        ((count++))
        spinner start "[${SCRIPT_NAME}]: Dropbear port current status is ${drop_bear_port}  .."
        if [ "${drop_bear_port}" -eq 0 ]; then
          spinner stop "[${SCRIPT_NAME}]: Dropbear port is open. Unlocking LUKS encryption ..."
          sleep 5
          ssh_luks_unlock "${DROP_BEAR_PORT}" "${LUKS_PASS}"
          break
        fi
        if [ "${count}" -gt 60 ]; then
          _log red "[${SCRIPT_NAME}]: It seems like DROP_BEAR_PORT is closed. Something is wrong"
          _exit 1
        fi
      done

      # Guide: https://www.arminpech.de/2019/12/23/debian-unlock-luks-root-partition-remotely-by-ssh-using-dropbear/
      # Guide 2: https://www.gandalfk7.it/posts/20200914_02_Debian_9_and_10_boot_luks_unlock/
      # Now you can SSH with :
      # maxisetup --ssh-login sun.sofibox.com
      sleep 5
      _log default "Copying maxisetup script ..."
      ssh_transfer "${BOX_HOSTNAME_FQDN}:${SSH_PORT}" "root:${ROOT_USERNAME}" "${SCRIPT_PATH}/maxisetup ${SCRIPT_PATH}/maxisetup.conf" ~/
      sleep 2

      _log default "Connecting to ${BOX_HOSTNAME_FQDN}:${SSH_PORT} and installing server ..."

      if [ "${PRE_AUTORUN_SETUP}" == "yes" ]; then
        _log default "Setup will automatically execute remote maxisetup script and start installation of the server ... (it might take some time) ..."
        ssh_login "${BOX_HOSTNAME_FQDN}:${SSH_PORT}" "root:${ROOT_USERNAME}" "${SCRIPT_PATH}/maxisetup_ssh.sh"
        # After installation above, the system must restart once, so we execute next script to reopen LUKS
        check_linode_status_until "offline"
      else
        _log default "Auto run script is disabled. Turning off server ... "
        ssh_login "${BOX_HOSTNAME_FQDN}:${SSH_PORT}" "root:${ROOT_USERNAME}" "${SCRIPT_PATH}/reboot_ssh.sh"
      fi

      _log default "Booting into operating system (make sure to unlock LUKS)"
      linode_api_admin "boot-linode" "${BOX_HOSTNAME_FQDN}" "OS_Config"
      # check server and port if available auto unlock it
      _log default "Checking whether hostname ${BOX_HOSTNAME_FQDN} with port ${DROP_BEAR_PORT} are available ..."
      count=0
      while :; do
        drop_bear_port=$(check_server_port "${BOX_HOSTNAME_FQDN}" "${DROP_BEAR_PORT}")
        sleep 1
        ((count++))
        spinner start "[${SCRIPT_NAME}]: Dropbear port current status is ${drop_bear_port}  .."
        if [ "${drop_bear_port}" -eq 0 ]; then
          spinner stop "[${SCRIPT_NAME}]: Dropbear port is open. Unlocking LUKS encryption ..."
          sleep 5
          ssh_luks_unlock "${DROP_BEAR_PORT}" "${LUKS_PASS}"
          break
        fi
        if [ "${count}" -gt 60 ]; then
          _log red "Warning, it seems like DROP_BEAR_PORT is closed. Something is wrong"
          _exit 1
        fi
      done

      if [ "${PRE_AUTORUN_SETUP}" == "yes" ]; then
        _log default "Resuming installation ..."
        ssh_login "${BOX_HOSTNAME_FQDN}:${SSH_PORT}" "root:${ROOT_USERNAME}" "${SCRIPT_PATH}/maxisetup_ssh.sh"
      else
        _log default "Done"
      fi
    elif [ "${EXTERNAL_DNS_PROVIDER}" == "digitalocean" ]; then
      :
    elif [ "${EXTERNAL_DNS_PROVIDER}" == "local" ]; then
      :
    fi
    exit 0
    break
    ;;
  # Test or user linode API here
  # eg: maxisetup --linode-api "get-linode-id" "sun.sofibox.com"
  -la | --linode-api | --linode_api | --linode)
    shift
    linode_api_admin "$@"
    exit 0
    break
    ;;
  # This will list out what domain or subdomain that will have problem when request certificate
  -srt | --ssl-request-test | --request-ssl-test)
    # Beta test
    validate_config
    configure_da_reseller_domain_ssl_pre "--force"
    configure_da_user_domain_ssl_pre "--force"
    exit 0
    break
    ;;
  # This will request certificate
  -sr | --ssl-request | --request-ssl)
    validate_config
    configure_da_reseller_domain_ssl "--force"
    configure_da_user_domain_ssl "--force"
    exit 0
    break
    ;;

  -lui | --linode-upload-iso)
    shift
    cp "${SCRIPT_PATH}"/secure/ssh/*.id_rsa* /root/.ssh/
    chmod -R 600 /root/.ssh/
    ssh -i /root/.ssh/linode_lish.id_rsa -tt "${DNS_PROVIDER_USER}@${DNS_PROVIDER_TERMINAL_SERVER}" "${BOX_HOSTNAME_FQDN}" <linode/permit_root.sh
    echo "Script executed"
    # sleep 30
    #exit 1
    echo "Uploading ISO file into ~/ at ${IPV4_ADD0} using SCP protocol ..."
    iso_file="${SCRIPT_PATH}/storage/os/debian/deb10mod-final.iso"
    scp "${iso_file}" root@"${IPV4_ADD0}":~/mini.iso
    echo "Cloning setup file mini.iso into /dev/sda"
    ssh "root@${IPV4_ADD0}" 'bash -s' <<"ENDSSH"
      dd if=mini.iso of=/dev/sda
ENDSSH
    exit 0
    break
    ;;
  # ./maxisetup --ssh-login <optional_hostname> <optional_port> <optional_user>
  # If hostname or port are not provided, they will use the default ones from config file
  -lu | --luks-unlock)
    shift
    ssh_luks_unlock "$@"
    exit 0
    break
    ;;
  -sshl | --ssh-login)
    shift
    ssh_login "$@"
    exit 0
    break
    ;;
  -ssht | --ssh-transfer)
    shift
    ssh_transfer "$@"
    exit 0
    break
    ;;
  -csp | --check-server-port)
    shift
    check_server_port "$@"
    exit 0
    break
    ;;
  -rs | --shutdown-server)
    shift
    _shutdown "$@"
    exit 0
    break
    ;;
  # Deprecated, only use this for reboot, restart of linode etc ...
  # lish-login <option>
  -ll | --lish-login | --lish | lish-login)
    shift
    options="$*"
    # Only run this in local machine
    cp "${SCRIPT_PATH}"/secure/ssh/*.id_rsa* /root/.ssh/
    chmod -R 600 /root/.ssh/
    #  ssh -i /root/.ssh/linode.id_rsa -tt "${DNS_PROVIDER_USER}@${DNS_PROVIDER_TERMINAL_SERVER}" "${BOX_HOSTNAME_FQDN}" < linode/lish_command.sh >/dev/null &
    #ssh -i /root/.ssh/linode.id_rsa -tt "${DNS_PROVIDER_USER}@${DNS_PROVIDER_TERMINAL_SERVER}" "${BOX_HOSTNAME_FQDN}" <linode/lish_command.sh &
    #test=$(ssh -i /root/.ssh/linode.id_rsa -tt "${DNS_PROVIDER_USER}@${DNS_PROVIDER_TERMINAL_SERVER}" "${BOX_HOSTNAME_FQDN}" <linode/lish_command.sh >/dev/null 2>&1 &)
    #test=$(ssh -i /root/.ssh/linode.id_rsa -tt "${DNS_PROVIDER_USER}@${DNS_PROVIDER_TERMINAL_SERVER}" "${BOX_HOSTNAME_FQDN}" <linode/lish_command.sh)
    #echo "Allowing 30 seconds finish copying ..."
    #sleep 30
    ssh -i /root/.ssh/linode_lish.id_rsa -tt "${DNS_PROVIDER_USER}@${DNS_PROVIDER_TERMINAL_SERVER}" "${BOX_HOSTNAME_FQDN}" ${options}
    exit 0
    break
    ;;
  -cri | --create-rescue-iso | --build-rescue-iso)
    shift
    create_rescue_iso "$@"
    exit 0
    break
    ;;

  # This will generate a modified operating system ISO file that can be used to automatically install OS when booting.
  -ci | --create-iso | --build-iso | --preseediso)
    shift
    create_os_iso "$@"
    exit 0
    break
    ;;
  -b | --build)
    shift
    package_name="$1"
    cd_to_path "${HOME}"
    if [ "${package_name}" == "go" ]; then
      apt-get -y install golang-go
    elif [ "${package_name}" == "dbxcli" ]; then
      install_required "git" "golang-go" "gox"
      mkdir $HOME/go
      go get github.com/dropbox/dbxcli
      cd_to_path "$HOME/go/src/github.com/dropbox/dbxcli"
      # To be continued ...
    elif [ "${package_name}" == "dbx" ]; then
      :
    else
      echo "No known package!"
    fi
    exit 0
    break
    ;;
  -t | --test)
    _log default "hello wassup dsad dsad asd asd adas dasdsad" file
    exit 0
    shift
    # ssh_transfer "${BOX_HOSTNAME_FQDN}:${SSH_PORT}" "root:${ROOT_USERNAME}" "maxisetup maxisetup.conf" ~/
    ssh_login "${BOX_HOSTNAME_FQDN}:${SSH_PORT}" "root:${ROOT_USERNAME}" "${SCRIPT_PATH}/maxisetup_ssh.sh"
    #ssh_login "sun.sofibox.com":"893" "rescue:root"
    #ssh_key_manager "create-key" "admin" "test1" "comment1"
    #ssh_key_manager "get-public-key" "admin" "test1"
    #exit 1
    #ssh_login sun.sofibox.com 899 rescue "${SCRIPT_PATH}/linode/test.sh"
    #echo >/root/.ssh/known_hosts
    #cp "${SCRIPT_PATH}"/secure/*.id_rsa* /root/.ssh/
    #chmod -R 600 /root/.ssh/
    ## ssh -o "StrictHostKeyChecking no" -i /root/.ssh/linode_lish.id_rsa -tt "${DNS_PROVIDER_USER}@${DNS_PROVIDER_TERMINAL_SERVER}" "${BOX_HOSTNAME_FQDN}" <"${SCRIPT_PATH}/linode/rescue_write.sh" >/dev/null 2>&1 &

    #ssh -o "StrictHostKeyChecking no" -i /root/.ssh/linode_lish.id_rsa -tt "${DNS_PROVIDER_USER}@${DNS_PROVIDER_TERMINAL_SERVER}" "${BOX_HOSTNAME_FQDN}" <"${SCRIPT_PATH}/linode/test.sh"

    # Put any test scripts here
    # _confirm "Continue script? [y/Y]: "
    #linode_api_admin "boot-linode" "sun.sofibox.com" "Boot_Config"
    #ssh -i /root/.ssh/linode_lish.id_rsa -tt "${DNS_PROVIDER_USER}@${DNS_PROVIDER_TERMINAL_SERVER}" "${BOX_HOSTNAME_FQDN}" <${SCRIPT_PATH}/linode/lish_command.sh &
    #test=$(get_hash_pwd "mypassword")
    #echo "${test}"

    #create_file "debian-preseed" "${SCRIPT_PATH}/test.txt"
    #cp "${SCRIPT_PATH}"/secure/*.id_rsa* /root/.ssh/
    #chmod -R 600 /root/.ssh/
    #ssh -i /root/.ssh/linode_lish.id_rsa -tt "${DNS_PROVIDER_USER}@${DNS_PROVIDER_TERMINAL_SERVER}" "${BOX_HOSTNAME_FQDN}" <"${SCRIPT_PATH}/linode/lish_command.sh"
    #ssh -q -i /root/.ssh/linode_lish.id_rsa -tt "${DNS_PROVIDER_USER}@${DNS_PROVIDER_TERMINAL_SERVER}" "${BOX_HOSTNAME_FQDN}" screen -d -m ${SCRIPT_PATH}/linode/lish_command.sh -s 'potato' # <${SCRIPT_PATH}/linode/lish_command.sh 2>&1 &

    #ssh myuser@hostname

    #pkill ssh
    #echo "Script executed"
    #count=0
    #while :; do
    #  spinner start "panjjdk adjsak jsakdj asdk asdjslka djsajdkl"
    #  sleep 1
    #  ((count++))
    #  if [ "${count}" -eq 5 ]; then
    #    spinner stop "stoppe dsa d asd adas d"
    #    break
    #  fi
    #done

    exit 0
    break
    ;;
  --)
    break
    ;;
  -*)
    opt="$1"
    echo "Invalid option '${opt}'. Use --help to see the valid options"
    exit 1
    ;;
  *) ;;
  esac
  shift
done
