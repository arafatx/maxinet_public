#!/bin/bash

# -------------------------------------------------
# Maxiaide alpha 1.0 - For Debian
# Check file integrity aka File Monitoring Script using AIDE (https://github.com/aide/aide)
# Author - Arafat Ali. Email: webmaster@sofibox.com
# -------------------------------------------------
function usage() {
  echo "${APP_SPECIFIC_NAME} Documentation"
  echo
  echo "Usage: "
  echo "${SCRIPT_NAME} [options] OPTIONAL < --cronjob >..."
  echo
  echo "options:"
  echo
  echo "  -h, --help"
  echo "      This help text."
  echo
  echo "  -s, --scan OPTIONAL <-c, --cronjob>"
  echo "      Run file scan."
  echo
}
function is_script_running() {
  pgrep -lf ".[ /]$1( |\$)"
}

function aide_scan() {
  # First check if the backup script is running
  # TODO check if this script has the same name I did before
  # Note: The file /var/lib/aide/aide.conf.autogenerated auto generated rules from /etc/aide/aide.conf.d when we run aideinit
  local retval added_count removed_count changed_count total_count file_plural file_status
  if is_script_running "maxirsync" >/dev/null; then
    echo "[${SCRIPT_NAME}]: Warning, unable to run ${APP_SPECIFIC_NAME} because maxirsync backup script is running" | tee -a "${REPORT_FILE}"
    exit 1
  fi

  if [ "${cronjob}" == "true" ]; then
    RUN_MODE="cronjob"
  else
    RUN_MODE="manual"
  fi

  # Check if database exist, if not init and generated new db
  echo "-------" | tee -a "${REPORT_FILE}"
  if [[ ! -s "${AIDE_CONF}" ]]; then
    echo "[${SCRIPT_NAME}]: Error, config file [${AIDE_CONF}] not found. Copying from /etc/aide/aide.conf ... " | tee -a "${REPORT_FILE}"
    cp -p "/etc/aide/aide.conf" "${AIDE_CONF}"
  fi
  if [[ ! -f "${AIDE_DB}" ]]; then
    echo "[${SCRIPT_NAME}]: Warning, no database file found at [${AIDE_DB}]!" | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Initializing new AIDE database using base config ..." | tee -a "${REPORT_FILE}"
    echo "-------" | tee -a "${REPORT_FILE}"
    bash -o pipefail -c "${AIDE_INIT_BIN} -y -c ${AIDE_CONF} | tee -a ${REPORT_FILE}"
    retval=$?
    if [ ${retval} = 0 ]; then
      echo "[${SCRIPT_NAME}]: OK, database initialized successfully" | tee -a "${REPORT_FILE}"
      # Rename the init database (make a copy don't delete init db for audit purpose)
      echo "[${SCRIPT_NAME}]: Copying initialized database [${AIDE_DB_NEW}] as [${AIDE_DB}]" | tee -a "${REPORT_FILE}"
      cp -vf "${AIDE_DB_NEW}" "${AIDE_DB}" | tee -a "${REPORT_FILE}"
      # Now archived the init database
      echo "[${SCRIPT_NAME}]: Archiving [${AIDE_DB_NEW}] as ${AIDE_DB_NEW}_${DATE_TIME_NOW}" | tee -a "${REPORT_FILE}"
      mv -vf "${AIDE_DB_NEW}" "${AIDE_DB_NEW}_${DATE_TIME_NOW}.archived" | tee -a "${REPORT_FILE}"
      # Now we only want to use the autogenerated aide config (we can modify this manually later)
      echo "[${SCRIPT_NAME}]: Copying autogenerated aide config from ${AIDE_AUTO_CONF} into ${AIDE_CONF} ..." | tee -a "${REPORT_FILE}"
      cp -vp "${AIDE_AUTO_CONF}" "${AIDE_CONF}"

    else
      # List of return code for init: 14,15,16,17,.18,19 (verify this)
      echo "[${SCRIPT_NAME}]: Warning, an error occur when initializing AIDE database [Error Code: ${retval}]" | tee -a "${REPORT_FILE}"
      #${MAIL_BIN} -s "[${SCRIPT_NAME} | ${WARN_STATUS} | mode: $RUN_MODE]: AIDE File Integrity Report @ ${BOX_HOSTNAME}" "${ADMIN_EMAIL}" <"${REPORT_FILE}"
      exit 1
    fi
    echo "-------" | tee -a "${REPORT_FILE}"
  fi

  echo "[${SCRIPT_NAME}]: =~=~=~= FILE CHECK AND UPDATE START =~=~=~=" | tee -a "${REPORT_FILE}"
  echo "[${SCRIPT_NAME}]: Scanning system file integrity and updating AIDE database ... (this may take some time):" | tee -a "${REPORT_FILE}"
  bash -o pipefail -c "${AIDE_BIN} --update --config=${AIDE_CONF} | tee -a ${REPORT_FILE}"
  retval=$?

  # ((total_entries = added_count = removed_count = changed_count = 0))
  ((added_count = removed_count = changed_count = 0))
  #total_entries=$(grep -oP 'Total number of entries:\s*\K\d+' "${REPORT_FILE}")
  added_count=$(grep -oP 'Added entries:\s*\K\d+' "${REPORT_FILE}")
  removed_count=$(grep -oP 'Removed entries:\s*\K\d+' "${REPORT_FILE}")
  changed_count=$(grep -oP 'Changed entries:\s*\K\d+' "${REPORT_FILE}")
  total_count=$((added_count + removed_count + changed_count))

  if [ ${total_count} -gt 1 ]; then
    file_plural="files"
  else
    file_plural="file"
  fi

  if [ ${retval} = 0 ]; then
    echo "[${SCRIPT_NAME}]: Ok, no changes detected" | tee -a "${REPORT_FILE}"
    file_status="No changes detected"
  elif [ ${retval} = 1 ]; then
    WARN_STATUS="WARNING"
    echo "[${SCRIPT_NAME}]: Warning, ${added_count} new ${file_plural} detected" | tee -a "${REPORT_FILE}"
    file_status="${added_count} new ${file_plural} detected"
  elif [ ${retval} = 2 ]; then
    WARN_STATUS="WARNING"
    echo "[${SCRIPT_NAME}]: Warning, ${removed_count} removed ${file_plural} detected" | tee -a "${REPORT_FILE}"
    file_status="${removed_count} removed ${file_plural} detected"
  elif [ ${retval} = 3 ]; then
    WARN_STATUS="WARNING"
    echo "[${SCRIPT_NAME}]: Warning, ${added_count} new and ${removed_count} removed ${file_plural} detected" | tee -a "${REPORT_FILE}"
    file_status="${added_count} new and ${removed_count} removed ${file_plural} detected"
  elif [ ${retval} = 4 ]; then
    WARN_STATUS="WARNING"
    echo "[${SCRIPT_NAME}]: Warning, ${changed_count} changed ${file_plural} detected" | tee -a "${REPORT_FILE}"
    file_status="${changed_count} changed ${file_plural} detected"
  elif [ ${retval} = 5 ]; then
    WARN_STATUS="WARNING"
    echo "[${SCRIPT_NAME}]: Warning, ${added_count} new and ${changed_count} changed ${file_plural} detected" | tee -a "${REPORT_FILE}"
    file_status="${added_count} new and ${changed_count} changed ${file_plural} detected"
  elif [ ${retval} = 6 ]; then
    WARN_STATUS="WARNING"
    echo "[${SCRIPT_NAME}]: Warning, ${removed_count} removed and ${changed_count} changed ${file_plural} detected" | tee -a "${REPORT_FILE}"
    file_status="${removed_count} removed and ${changed_count} changed ${file_plural} detected"
  elif [ ${retval} = 7 ]; then
    WARN_STATUS="WARNING"
    echo "[${SCRIPT_NAME}]: Warning, ${added_count} new, ${removed_count} removed and ${changed_count} changed ${file_plural} detected" | tee -a "${REPORT_FILE}"
    file_status="${added_count} new, ${removed_count} removed and ${changed_count} changed ${file_plural} detected"
  elif [ ${retval} = 14 ]; then
    WARN_STATUS="WARNING"
    echo "[${SCRIPT_NAME}]: Warning, writing error" | tee -a "${REPORT_FILE}"
  elif [ ${retval} = 15 ]; then
    WARN_STATUS="WARNING"
    echo "[${SCRIPT_NAME}]: Warning, Invalid argument error" | tee -a "${REPORT_FILE}"
  elif [ ${retval} = 16 ]; then
    WARN_STATUS="WARNING"
    echo "[${SCRIPT_NAME}]: Warning, unimplemented function error" | tee -a "${REPORT_FILE}"
  elif [ ${retval} = 17 ]; then
    WARN_STATUS="WARNING"
    echo "[${SCRIPT_NAME}]: Warning, invalid configureline error" | tee -a "${REPORT_FILE}"
  elif [ ${retval} = 18 ]; then
    WARN_STATUS="WARNING"
    echo "[${SCRIPT_NAME}]: Warning, IO error" | tee -a "${REPORT_FILE}"
  elif [ ${retval} = 19 ]; then
    WARN_STATUS="WARNING"
    echo "[${SCRIPT_NAME}]: Warning, version mismatch error" | tee -a "${REPORT_FILE}"
  else
    WARN_STATUS="WARNING"
    echo "[${SCRIPT_NAME}]: Error, unknown return code: [${RET_VAL}]" | tee -a "${REPORT_FILE}"
    exit 1
  fi
  # test
  if [[ ! -f ${AIDE_DB_NEW} ]]; then
    # In case if suddenly the DB file is not found
    echo "[${SCRIPT_NAME}]: Warning, DB [${AIDE_DB_NEW}] is not found. Inspect why" | tee -a "${REPORT_FILE}"
    exit 1
  else
    mv -f "${AIDE_DB_NEW}" "${AIDE_DB}" | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: AIDE database of [${AIDE_DB_NEW}] was renamed as [${AIDE_DB}]" | tee -a "${REPORT_FILE}"
  fi
  echo "[${SCRIPT_NAME}]: AIDE has finished checking" | tee -a "${REPORT_FILE}"
  echo "" | tee -a "${REPORT_FILE}"
  echo "---= FILE CHECK AND UPDATE END =---" | tee -a "${REPORT_FILE}"

  echo "" | tee -a "${REPORT_FILE}"

  echo "=============================================" | tee -a "${REPORT_FILE}"
  echo "================ SUMMARY ====================" | tee -a "${REPORT_FILE}"
  echo "=============================================" | tee -a "${REPORT_FILE}"
  echo "[${SCRIPT_NAME}]: Running mode: [$RUN_MODE]" | tee -a "${REPORT_FILE}"
  echo "[${SCRIPT_NAME}]: Scan completed successfully" | tee -a "${REPORT_FILE}"
  echo "[${SCRIPT_NAME}]: Scan status: ${WARN_STATUS} | ${file_status}" | tee -a "${REPORT_FILE}"
  echo "[${SCRIPT_NAME}]: Log file is located at ${REPORT_FILE}" | tee -a "${REPORT_FILE}"
  echo "=============================================" | tee -a "${REPORT_FILE}"

  # Only upload if log files have warning
  # TODO log file upload should be handled by maxilog
  if [ "${WARN_STATUS}" == "WARNING" ]; then
    echo "[${SCRIPT_NAME}]: Preparing to upload log file into [onedrive] ..." | tee -a "${REPORT_FILE}"
    echo "[${SCRIPT_NAME}]: Decrypting rclone config file ..." | tee -a "${REPORT_FILE}"
    # Only decrypt if passphrase is correctly given
    RCLONE_CONFIG_PASS=$(gpg --decrypt "/usr/local/maxicron/rsync/conf/rclone_pass")
    RET_VAL=$?
    if [ $RET_VAL = 0 ]; then
      echo "[${SCRIPT_NAME}]: OK, rclone config file decrypted successfully" | tee -a "${REPORT_FILE}"
      export RCLONE_CONFIG_PASS
      # I put this because this is custom rclone.conf (default location was /etc/rclone.conf).
      # When RCLONE_CONFIG_PASS is given and exported as global variable, this will be automatically decrypt the following file:
      RCLONE_CONFIG="/usr/local/maxicron/rsync/conf/rclone.conf"
      export RCLONE_CONFIG
    else
      WARN_STATUS="WARNING"
      echo "[${SCRIPT_NAME}]: Error, rclone config file decrypting failed. Perhaps passphrase is not cached ?" | tee -a "${REPORT_FILE}"
      echo "[${SCRIPT_NAME}]: Report file will not be uploaded into [onedrive] because failed to decrypt rclone config file" | tee -a "${REPORT_FILE}"
      $MAIL_BIN -s "[${SCRIPT_NAME} | ${WARN_STATUS} | mode: $RUN_MODE]: AIDE File Integrity Scan Report @ ${BOX_HOSTNAME}" "${ADMIN_EMAIL}" <"${REPORT_FILE}"
      exit 1
    fi

    #create_backup_dir
    echo "[${SCRIPT_NAME}]: Creating new backup directory in [onedrive] as [${REPORT_CLOUD_PATH}] ..." | tee -a "${REPORT_FILE}"
    bash -o pipefail -c "rclone mkdir onedrive-backup:${REPORT_CLOUD_PATH} | tee -a ${REPORT_FILE}"
    RET_VAL=$?
    if [ ${RET_VAL} == 0 ]; then
      echo "[${SCRIPT_NAME}]: OK, new report folder [${REPORT_CLOUD_PATH}] created at [onedrive]" | tee -a "${REPORT_FILE}"
    else
      WARN_STATUS="WARNING"
      echo "[${SCRIPT_NAME}]: [${RET_VAL}] Warning, something is wrong while creating directory [${REPORT_CLOUD_PATH}] at [onedrive]" | tee -a "${REPORT_FILE}"
    fi

    bash -o pipefail -c "rclone copy ${REPORT_FILE} onedrive-backup:${REPORT_CLOUD_PATH} --stats-one-line -P --stats 2s"
    RET_VAL=$?
    if [ ${RET_VAL} == 0 ]; then
      echo "[${SCRIPT_NAME}]: Success, report file of [$REPORT_FILE] has been successfully uploaded into [onedrive]" | tee -a "${REPORT_FILE}"
    else
      WARN_STATUS="WARNING"
      echo "[${SCRIPT_NAME}]: Error, unknown error while performing file upload [$REPORT_FILE]: [${RET_VAL}]" | tee -a "${REPORT_FILE}"
    fi
    $MAIL_BIN -s "[${SCRIPT_NAME} | ${WARN_STATUS} | mode: $RUN_MODE] AIDE: ${file_status} @ ${BOX_HOSTNAME}" "${ADMIN_EMAIL}" <"${REPORT_FILE}"

  fi

}

# USER SPECIFIC CONFIGURATION
ADMIN_EMAIL="webmaster@sofibox.com"
APP_SPECIFIC_NAME="MaxiAIDE"

# SYSTEM VARIABLE, FILE AND BINARY
SCRIPT_PATH="$(dirname "$(readlink -f "$0")")"
SCRIPT_NAME=$(basename -- "$0")
BOX_HOSTNAME=$(hostname)
MAIL_BIN=$(command -v mail)
DATE_BIN=$(command -v date)

# == Automatic install missing components ====
missing_count=0
install_success=0
# List out required components here:
required_cmds=("aide" "mail" "date")
for required_cmd in "${required_cmds[@]}"; do
  if ! command -v "${required_cmd}" &>/dev/null; then
    ((missing_count++))
    echo "Warning, missing ${required_cmd} component. Installing ${required_cmd} ..."
    # Debian
    apt-get -y install "${required_cmd}"
    retval=$?
    if [[ ${retval} -eq 0 ]]; then
      ((install_success++))
    fi
  fi
done
if [ "${missing_count}" -gt 0 ]; then
  echo "There was/were ${missing_count} missing component(s) to run ${SCRIPT_NAME} and ${install_success} component(s) was/were successfully installed!"
fi
# ================================================
# Since we know that aide and aideinit has been installed we must put this here:
AIDE_BIN=$(command -v aide)
# If we install aide, we will get this aideinit
AIDE_INIT_BIN=$(command -v aideinit)
# LOG, CONF, DB PATHS
LOG_PATH="${SCRIPT_PATH}/log/"
CONFIG_PATH="${SCRIPT_PATH}/conf"
DB_PATH="${SCRIPT_PATH}/db"
TEMP_PATH="${SCRIPT_PATH}/tmp"

mkdir -p "${LOG_PATH}"
mkdir -p "${CONFIG_PATH}"
mkdir -p "${DB_PATH}"
mkdir -p "${TEMP_PATH}"

AIDE_CONF="${CONFIG_PATH}/aide.conf"
AIDE_AUTO_CONF="/var/lib/aide/aide.conf.autogenerated"
AIDE_DB_NEW="/var/lib/aide/aide.db.new"
AIDE_DB="/var/lib/aide/aide.db"

# REPORT FILES
RANDSTR="$(${DATE_BIN} '+%d-%m-%Y_%H-%M-%S').${RANDOM}"
DATE_TIME_NOW="$(date '+%d-%m-%Y_%H-%M-%S')" #31-03-2020_11-56-16
MONTH_NOW=$(date +%B)
DATE_NOW="$(date '+%d-%m-%Y')" #31-03-2020
REPORT_FILE="${LOG_PATH}/${SCRIPT_NAME}-${RANDSTR}-${DATE_TIME_NOW}-report.log"
REPORT_CLOUD_PATH="Earthbox/maxicode_logs/${SCRIPT_NAME}/${MONTH_NOW}/${DATE_NOW}/"

# STATUS VARIABLE
RUN_MODE="N/A"
WARN_STATUS="OK"
RET_VAL=0

# Clear log file for 1 day
find "${LOG_PATH}" -name "*.log" -mtime +1 -exec rm {} \;
# initialize an empty log file
cat /dev/null >"${REPORT_FILE}"

# PROCESS AND LOCKING

#PID_COUNT=$(pidof -x "${SCRIPT_NAME}" | wc -w)
PID=$(pidof -x "${SCRIPT_NAME}")
# PID_FILE="/var/run/${SCRIPT_NAME}.pid"
# USE ATOMIC LOCK
LOCK_DIR="/var/lock/${SCRIPT_NAME}"
LOCK_PID="${LOCK_DIR}/pid"
ARGNUM="$#"
OPTS=""

# Handle option arguments
if [ $ARGNUM -eq 0 ]; then
  echo "[${SCRIPT_NAME}]: Error, no argument is supplied. Use --help to see the valid options"
  exit 1
fi

# For now just 2 options, next version will have many options so if we got extra option just increase this value (I also have argument check below)
#if [ $ARGNUM -gt 2 ]; then
#  echo "[${SCRIPT_NAME}]: Error, too many arguments. Current maximum option accepted is 2"
#  exit 1
#fi

scan="false"
cronjob="false"

#echo ${ARGNUM}
while [ "$#" -gt 0 ]; do
  case "$1" in
  # Display help and usage
  -h | --help)
    usage
    exit 0
    ;;
  -v | --version) # Display Program version
    echo "v0.2 - ${APP_SPECIFIC_NAME} by MaXi32 (Arafat Ali - sofibox.com)"
    exit 0
    break
    ;;
  -s | --scan | --check)
    opt="$1"
    if [[ "${opt}" == "-s" || "${opt}" == "--check" ]]; then
      opt="--scan"
    fi
    if [ -n "${OPTS}" ]; then
      OPTS="${OPTS} ${opt}"
    else
      OPTS="${opt}"
    fi
    scan="true"
    ;;
  -c | --cronjob)
    opt="$1"
    if [ "${opt}" == "-c" ]; then
      opt="--cronjob"
    fi
    if [ -n "${OPTS}" ]; then
      OPTS="${OPTS} ${opt}"
    else
      OPTS="${opt}"
    fi
    cronjob="true"
    ;;
  -* | *)
    opt="${opt}"
    if [ -n "${opt}" ]; then
      echo "Invalid option after ${SCRIPT_NAME} ${opt} '?'. Use --help to see the valid options"
    else
      echo "Invalid first option $1. Use --help to see the valid options"
    fi
    exit 1
    ;;
  esac
  shift
done

# THIS WILL CHECK ONLY ONE INSTANCE OF SCRIPT SHOULD RUN
if ! mkdir "${LOCK_DIR}" 2>/dev/null; then
  PID=$(cat "${LOCK_PID}")
  if ! kill -0 "${PID}" 2>/dev/null; then
    echo "Removing stale lock of nonexistent PID ${PID}" >&2
    rm -rf "${LOCK_DIR}"
    echo "Restarting myself (${SCRIPT_NAME})" >&2
    exec "$0" "$@"
  fi
  echo "${SCRIPT_NAME} is already running, bailing out" >&2
  WARN_STATUS="WARNING"
  echo "[${SCRIPT_NAME}]: Warning, another instance of [${APP_SPECIFIC_NAME}] process is already running with PID [${PID}]" | tee -a "${REPORT_FILE}"
  echo "[${SCRIPT_NAME}]: Please wait for or clear the current running session to run this script" | tee -a "${REPORT_FILE}"
  if [ "$RUN_MODE" == "cronjob" ]; then
    echo "[${SCRIPT_NAME}]: [${APP_SPECIFIC_NAME}] script was executed as cronjob and is now terminated" | tee -a "${REPORT_FILE}"
    exit 1
  else
    echo "[${SCRIPT_NAME}]: [${SCRIPT_NAME}] script is now terminated" | tee -a "${REPORT_FILE}"
  fi
  exit 1
else
  # LOCK SUCCESS NOW SAVE INFORMATION IN PID
  echo $$ >"${LOCK_PID}"
fi

# IF SCRIPT EXIT UNSUCCESSFULLY, THEN WE REMOVE THE LOCK
trap 'rm -rf ${LOCK_DIR}' QUIT INT TERM EXIT

# RUN THE SCAN IF AN OPTION IS TRUE
if [ ${scan} == "true" ]; then
  # At this point we have the value scan and cronjob either true or false (global vars)
  # Can create more options later
  aide_scan
else
  echo "[${SCRIPT_NAME}]: Error, need an option --scan to run" | tee -a "${REPORT_FILE}"
fi
